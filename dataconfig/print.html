<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DataConfig Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Serialization framework for Unreal Engine that just works!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="Examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Examples/Custom.html"><strong aria-hidden="true">2.1.</strong> Custom</a></li><li class="chapter-item expanded "><a href="Examples/DebugDump.html"><strong aria-hidden="true">2.2.</strong> Debug Dump</a></li></ol></li><li class="chapter-item expanded "><a href="Integration.html"><strong aria-hidden="true">3.</strong> Integration</a></li><li class="chapter-item expanded "><a href="Design.html"><strong aria-hidden="true">4.</strong> Design</a></li><li class="chapter-item expanded "><a href="Programming/index.html"><strong aria-hidden="true">5.</strong> Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Programming/DataModel.html"><strong aria-hidden="true">5.1.</strong> Data Model</a></li><li class="chapter-item expanded "><a href="Programming/ErrorHandling.html"><strong aria-hidden="true">5.2.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="Programming/Env.html"><strong aria-hidden="true">5.3.</strong> Env</a></li><li class="chapter-item expanded "><a href="Programming/ReaderWriter.html"><strong aria-hidden="true">5.4.</strong> Reader Writer</a></li><li class="chapter-item expanded "><a href="Programming/SerializerDeserializer.html"><strong aria-hidden="true">5.5.</strong> Serializer Deserializer</a></li></ol></li><li class="chapter-item expanded "><a href="Formats/index.html"><strong aria-hidden="true">6.</strong> Formats</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Formats/JSON.html"><strong aria-hidden="true">6.1.</strong> JSON</a></li><li class="chapter-item expanded "><a href="Formats/MsgPack.html"><strong aria-hidden="true">6.2.</strong> MsgPack</a></li><li class="chapter-item expanded "><a href="Formats/Property.html"><strong aria-hidden="true">6.3.</strong> Property</a></li></ol></li><li class="chapter-item expanded "><a href="Extra/index.html"><strong aria-hidden="true">7.</strong> Extra</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Extra/FColor.html"><strong aria-hidden="true">7.1.</strong> FColor</a></li><li class="chapter-item expanded "><a href="Extra/Base64.html"><strong aria-hidden="true">7.2.</strong> Base64 Blob</a></li><li class="chapter-item expanded "><a href="Extra/WriterAPI.html"><strong aria-hidden="true">7.3.</strong> WriterAPI</a></li><li class="chapter-item expanded "><a href="Extra/JsonConverter.html"><strong aria-hidden="true">7.4.</strong> JsonConverter</a></li><li class="chapter-item expanded "><a href="Extra/AnyStruct.html"><strong aria-hidden="true">7.5.</strong> AnyStruct</a></li><li class="chapter-item expanded "><a href="Extra/InlineStruct.html"><strong aria-hidden="true">7.6.</strong> InlineStruct</a></li><li class="chapter-item expanded "><a href="Extra/FieldRenamer.html"><strong aria-hidden="true">7.7.</strong> Field Renamer</a></li><li class="chapter-item expanded "><a href="Extra/PropertyPath.html"><strong aria-hidden="true">7.8.</strong> Property Path</a></li><li class="chapter-item expanded "><a href="Extra/SQLite.html"><strong aria-hidden="true">7.9.</strong> SQLite</a></li><li class="chapter-item expanded "><a href="Extra/ModuleSetup.html"><strong aria-hidden="true">7.10.</strong> Module Setup</a></li><li class="chapter-item expanded "><a href="Extra/DumpAssetToLog.html"><strong aria-hidden="true">7.11.</strong> Dump Asset To Log</a></li><li class="chapter-item expanded "><a href="Extra/Blueprint.html"><strong aria-hidden="true">7.12.</strong> Blueprint</a></li><li class="chapter-item expanded "><a href="Extra/GameplayTag.html"><strong aria-hidden="true">7.13.</strong> Gameplay Tag</a></li><li class="chapter-item expanded "><a href="Extra/GameplayAbility.html"><strong aria-hidden="true">7.14.</strong> Gameplay Ability</a></li><li class="chapter-item expanded "><a href="Extra/InstancedStruct.html"><strong aria-hidden="true">7.15.</strong> InstancedStruct</a></li></ol></li><li class="chapter-item expanded "><a href="Advanced/index.html"><strong aria-hidden="true">8.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Advanced/Benchmark.html"><strong aria-hidden="true">8.1.</strong> Benchmark</a></li><li class="chapter-item expanded "><a href="Advanced/WritingHandlers.html"><strong aria-hidden="true">8.2.</strong> Writing Handlers</a></li><li class="chapter-item expanded "><a href="Advanced/NonClassStructRoot.html"><strong aria-hidden="true">8.3.</strong> Non Class/Struct Root</a></li><li class="chapter-item expanded "><a href="Advanced/Automation.html"><strong aria-hidden="true">8.4.</strong> Automation</a></li><li class="chapter-item expanded "><a href="Advanced/UEUpgrades.html"><strong aria-hidden="true">8.5.</strong> UE Upgrades</a></li></ol></li><li class="chapter-item expanded "><a href="Changes.html"><strong aria-hidden="true">9.</strong> Changes</a></li><li class="chapter-item expanded "><a href="License.html"><strong aria-hidden="true">10.</strong> License</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DataConfig Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/slowburn-dev/DataConfig" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dataconfig-book"><a class="header" href="#dataconfig-book">DataConfig Book</a></h1>
<p><strong>Serialization framework for Unreal Engine that just works!</strong></p>
<p><a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig"><strong>DataConfig</strong></a> is a serialization framework built on top of Unreal Engine's Property System. It aims to be friendly and robust while offering good performance. Notably features:</p>
<ul>
<li>Out of the box JSON/MsgPack read write.</li>
<li>Full support for <code>UPROPERTY()/UCLASS()/USTRUCT()/UENUM()</code>.</li>
<li>Pull/Push style API for verbatim data access and lossless type information.</li>
<li>Designed as a collection of tools that can be easily extended to support other formats.</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ul>
<li>Get the code on <a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig">github</a>.</li>
<li>See <a href="Examples/index.html">Examples</a> for code examples.</li>
<li>See <a href="Integration.html">Integration</a> for quick integration guide.</li>
<li>See <a href="Design.html">Design</a> for more context about the project.</li>
<li>See <a href="Extra/index.html">Extra</a> for more advanced usages.</li>
<li>See <a href="Changes.html">Changes</a> for versioning history.</li>
</ul>
<p>There's also <a href="https://www.unrealengine.com/marketplace/en-US/product/dataconfig-json-asset" title="DataConfig JSON Asset">DataConfig JSON Asset</a> on UE Marketplace. It's a premium plugin for importing JSON to UE data assets.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p><strong>DataConfig</strong> is released under free and permissive MIT license. We'd really appreciate to credit us if you find it useful. See <a href="License.html">License</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Here're some short and quick examples showcasing DataConfig API usage and features. All code shown here can be found in the <a href="https://github.com/slowburn-dev/DataConfig/blob/release/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp" title="DcTestBlurb.cpp">repo</a>.</p>
<h2 id="json-deserialization"><a class="header" href="#json-deserialization">JSON Deserialization</a></h2>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp#L20">DcTestBlurb.cpp</a></li>
</ul>
<p>Given the struct<code>FDcTestExampleStruct</code>:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.h
UENUM()
enum class EDcTestExampleEnum
{
    Foo, Bar, Baz
};

USTRUCT()
struct FDcTestExampleStruct
{
    GENERATED_BODY()
    UPROPERTY() FString StrField;
    UPROPERTY() EDcTestExampleEnum EnumField;
    UPROPERTY() TArray&lt;FColor&gt; Colors;
};
</code></pre>
<p>We can deserialize an instance from JSON with the snippet below:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
        &quot;EnumField&quot; : &quot;Bar&quot;,
        &quot;Colors&quot; : [
            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
        ]
    }
)&quot;);

FDcTestExampleStruct Dest;

//  create and setup a deserializer
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);
Deserializer.AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(DcExtra::PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(DcExtra::HandlerColorDeserialize)
);

//  prepare context for this run
FDcPropertyDatum Datum(&amp;Dest);
FDcJsonReader Reader(Str);
FDcPropertyWriter Writer(Datum);

FDcDeserializeContext Ctx;
Ctx.Reader = &amp;Reader;
Ctx.Writer = &amp;Writer;
Ctx.Deserializer = &amp;Deserializer;
DC_TRY(Ctx.Prepare());

//  kick off deserialization
DC_TRY(Deserializer.Deserialize(Ctx));

//  validate results
check(Dest.StrField == TEXT(&quot;Lorem ipsum dolor sit amet&quot;));
check(Dest.EnumField == EDcTestExampleEnum::Bar);
check(Dest.Colors[0] == FColor::Red);
check(Dest.Colors[1] == FColor::Green);
check(Dest.Colors[2] == FColor::Blue);
</code></pre>
<p>Note that <code>EDcTestExampleEnum</code> is deserialized by its name and <code>FColor</code> is deserialized from a html color string like <code>#RRGGBBAA</code>.</p>
<p>Say if we accidentally mistyped the <code>EnumField</code> value:</p>
<pre><code class="language-json">{
    &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
    &quot;EnumField&quot; : &quot;Far&quot;,
}
</code></pre>
<p>It would fail gracefully with diagnostics:</p>
<pre><code># DataConfig Error: Enum name not found in enum type: EDcTestExampleEnum, Actual: 'Far'
- [JsonReader] --&gt; &lt;in-memory&gt;4:25
   2 |    {
   3 |        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
   4 |        &quot;EnumField&quot; : &quot;Far&quot;,
     |                           ^
   5 |        &quot;Colors&quot; : [
   6 |            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
- [PropertyWriter] Writing property: (FDcTestExampleStruct)$root.(EEDcTestExampleEnum)EnumField
</code></pre>
<p>As bonus we serialize the struct into MsgPack: </p>
<pre><code class="language-c++">FDcSerializer Serializer;
DcSetupMsgPackSerializeHandlers(Serializer);

FDcPropertyDatum Datum(&amp;Dest);
FDcPropertyReader Reader(Datum);
FDcMsgPackWriter Writer;

//  prepare serialize context
FDcSerializeContext Ctx;
Ctx.Reader = &amp;Reader;
Ctx.Writer = &amp;Writer;
Ctx.Serializer = &amp;Serializer;
DC_TRY(Ctx.Prepare());

//  kick off serialization
DC_TRY(Serializer.Serialize(Ctx));

auto&amp; Buffer = Writer.GetMainBuffer();
//  starts withMsgPack FIXMAP(3) header
check(Buffer[0] == 0x83);   
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-serialization-and-deserialization"><a class="header" href="#custom-serialization-and-deserialization">Custom Serialization And Deserialization</a></h1>
<p>DataConfig support custom serialization and deserialization logic by implementing <code>FDcSerializeDelegate/FDcDeserializeDelegate</code>.</p>
<p>In this example, we'd like to convert <code>FColor</code> into <code>#RRGGBBAA</code> and vice versa: </p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeColor.h">DcSerdeColor.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp">DcSerdeColor.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Public/DataConfig/Extra/Deserialize/DcSerDeColor.h
USTRUCT()
struct FDcExtraTestStructWithColor1
{
    GENERATED_BODY()

    UPROPERTY() FColor ColorField1;
    UPROPERTY() FColor ColorField2;
};

// DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeColor.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
        &quot;ColorField2&quot; : &quot;#FF0000FF&quot;,
    }
)&quot;);
</code></pre>
<p>First you'll need to implement a <code>FDcDeserializePredicate</code> delegate to pick out <code>FColor</code> properties:</p>
<pre><code class="language-c++">//  DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
EDcDeserializePredicateResult PredicateIsColorStruct(FDcDeserializeContext&amp; Ctx)
{
    return DcDeserializeUtils::PredicateIsUStruct&lt;FColor&gt;(Ctx);
}
</code></pre>
<p>Then we'll need to implement a <code>FDcDeserializeDelegate</code> to deserialize a <code>FColor</code>. Here we'll do it by writing through <code>R/G/B/A</code> fields by name with the <code>FDcWriter</code> API.</p>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeColor.cpp
FDcResult HandlerColorDeserialize(FDcDeserializeContext&amp; Ctx)
{
    FDcPropertyDatum Datum;
    DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

    FString ColorStr;
    DC_TRY(Ctx.Reader-&gt;ReadString(&amp;ColorStr));
    FColor Color = FColor::FromHex(ColorStr);

    FColor* ColorPtr = (FColor*)Datum.DataPtr;
    *ColorPtr = Color;

    return DcOk();
}
</code></pre>
<p>Note how we retrieve the hex string, then parse it with <code>FColor::FromHex</code>.</p>
<p>Upon deserializing we'll need to register these pair of delegates to the <code>FDcDeserializer</code>.</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);
Deserializer.AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(DcExtra::PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(DcExtra::HandlerColorDeserialize)
);
</code></pre>
<p>And then it's done! It would work recursively on <code>FColor</code> everywhere, like in <code>UCLASS/USTRUCT</code> members, in <code>TArray/TSet</code> and in <code>TMap</code> as key or values.</p>
<p>Note that DataConfig completely separate serialization and deserialization logic. To serialize <code>FColor</code> into <code>#RRGGBBAA</code> string one needs to implement a similar set of methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-dump"><a class="header" href="#debug-dump">Debug Dump</a></h1>
<p><code>DcAutomationUtils::DumpToLog()</code> can dump a <code>FDcPropertyDatum</code> to a string representation, in which <code>FDcPropertyDatum</code> is simply a <code>(FProperty</code>, <code>void*</code>) fat pointer tuple that can represent anything in the property system:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp#L97">DcTestBlurb.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FVector Vec(1.0f, 2.0f, 3.0f);
FDcPropertyDatum VecDatum(TBaseStructure&lt;FVector&gt;::Get(), &amp;Vec);

DcAutomationUtils::DumpToLog(VecDatum);
</code></pre>
<p>Output would be:</p>
<pre><code>-----------------------------------------
# Datum: 'ScriptStruct', 'Vector'
&lt;StructRoot&gt; 'Vector'
|---&lt;Name&gt; 'X'
|---&lt;Float&gt; '1.000000'
|---&lt;Name&gt; 'Y'
|---&lt;Float&gt; '2.000000'
|---&lt;Name&gt; 'Z'
|---&lt;Float&gt; '3.000000'
&lt;StructEnd&gt; 'Vector'
-----------------------------------------
</code></pre>
<p>Additionally we wrapped this into <code>gDcDebug</code> that can be invoked in MSVC immediate window. Calling it during debug would dump into MSVC <strong>Output</strong> window:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/Automation/DcAutomationUtils.h
struct DATACONFIGCORE_API FDcDebug
{
    FORCENOINLINE void DumpStruct(char* StructNameChars, void* Ptr);
    FORCENOINLINE void DumpObject(UObject* Obj);
    FORCENOINLINE void DumpDatum(void* DatumPtr);
};

/// Access `gDcDebugg` in MSVC immediate window:
///
/// - in monolith builds:
/// gDcDebug.DumpObject(Obj)
///
/// - in DLL builds prefix with dll name:
/// ({,,UE4Editor-DataConfigCore}gDcDebug).DumpObject(ObjPtr)

extern FDcDebug gDcDebug;
</code></pre>
<p>Here's an animated demo showing dumping the vector above <em>during debug break</em> in MSVC:</p>
<p><img src="Examples/Images/Examples-DebugDumpVecDatum.png" alt="Examples-DebugDumpVecDatum" /></p>
<p>The full expression to evaluate is:</p>
<pre><code>({,,UE4Editor-DataConfigCore}gDcDebug).DumpDatum(&amp;VecDatum)
</code></pre>
<p>We need DLL name to locate <code>gDcDebug</code> in a non monolith build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration"><a class="header" href="#integration">Integration</a></h1>
<p>At the moment it supports these the engine versions below:</p>
<ul>
<li>UE 4.25</li>
<li>UE 4.26</li>
<li>UE 4.27</li>
<li>UE 5.0 </li>
<li>UE 5.1 </li>
</ul>
<h2 id="integrate-dataconfig-plugin"><a class="header" href="#integrate-dataconfig-plugin">Integrate <code>DataConfig</code> Plugin</a></h2>
<p>The easiest way to try out DataConfig is to add it as a plugin into your C++ project.  In this section we'll walk through the steps of integrating DataConfig plugin into a empty UE C++ Project.</p>
<h3 id="generate-dataconfig-plugin-for-ue4ue5"><a class="header" href="#generate-dataconfig-plugin-for-ue4ue5">Generate DataConfig Plugin for UE4/UE5</a></h3>
<p>DataConfig now uses separated <code>uplugin</code> files for UE4 and UE5 so that we can try out new features in UE5 without dropping support for UE4. We bundled scripts to generate clean plugins for UE4 and UE5. You can also find these on <a href="https://github.com/slowburn-dev/DataConfig/releases">DataConfig releases</a> page.</p>
<pre><code class="language-shell">git clone https://github.com/slowburn-dev/DataConfig
# requires python 3.6+
python ./DataConfig/Misc/Scripts/make_dataconfig_ue4.py
python ./DataConfig/Misc/Scripts/make_dataconfig_ue5.py
</code></pre>
<h3 id="manual-steps-for-ue5"><a class="header" href="#manual-steps-for-ue5">Manual Steps for UE5</a></h3>
<ol>
<li>
<p>Get a copy of <a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig">DataConfig repository</a>. Then copy  <code>./DataConfig</code> (where <code>DataConfig.uplugin</code> is located) into your project's <code>Plugins</code> directory.</p>
</li>
<li>
<p>Delete <code>DataConfig4.uplugin</code>.</p>
</li>
<li>
<p><strong>Delete <code>DataConfig/Source/DataConfigHeadless</code></strong> folder. <strong>This step is crucial or you your project won't build</strong>.</p>
</li>
</ol>
<h3 id="manual-steps-for-ue4"><a class="header" href="#manual-steps-for-ue4">Manual Steps for UE4</a></h3>
<ol>
<li>
<p>Get a copy of <a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig">the repository</a>. Then copy  <code>./DataConfig</code> (where <code>DataConfig.uplugin</code> is located) into your project's <code>Plugins</code> directory.</p>
</li>
<li>
<p>Delete <code>DataConfig.uplugin</code>, then rename <code>DataConfig4.uplugin</code> to <code>DataConfig.uplugin</code>.</p>
</li>
<li>
<p><strong>Delete <code>DataConfig/Source/DataConfigHeadless</code></strong> folder. <strong>This step is crucial or you your project won't build</strong>.</p>
</li>
<li>
<p>Additionally delete UE5 specific modules.</p>
<ul>
<li><code>DataConfig/Source/DataConfigEditorExtra5</code></li>
</ul>
</li>
</ol>
<h3 id="validate-integration"><a class="header" href="#validate-integration">Validate integration</a></h3>
<p>Follow these steps to ensure DataConfig is properly integrated into your project.</p>
<ol>
<li>
<p>Restart your project. There should be a prompt to compile plugin sources. Confirm and wait until your project launches. Then open <code>Settings -&gt; Plugins</code> you should see <strong>Data Config</strong> listed under Project Editor category.</p>
<p><img src="Images/Integration-DataConfigPlugin.png" alt="Integration-DataConfigPlugin" /></p>
</li>
<li>
<p>The plugin comes with a set of tests. Open menu <code>Window -&gt; Developer Tools  -&gt; Session Frontend</code>. Find and run the <code>DataConfig</code> tests and it should all pass.</p>
<p><img src="Images/Integration-DataConfigAutomations.png" alt="Integration-DataConfigAutomations" /></p>
</li>
</ol>
<h2 id="integrate-dataconfigcore-module"><a class="header" href="#integrate-dataconfigcore-module">Integrate <code>DataConfigCore</code> Module</a></h2>
<p>DataConfig is packed into a plugin to bundle automation tests with a few assets. You're encouraged to integrate only the <code>DataConfigCore</code> module. It contains all core features with minimal dependencies. </p>
<p>Most projects should has a editor module already setup. In this section we'll go through the steps of integrating <code>DataConfigCore</code> and build it with the project's <code>FooProjectEditor</code> module.</p>
<ol>
<li>
<p>Get a copy of this repository. Then copy <code>DataConfig/Source/DataConfigCore</code> into your project's <code>Source</code> directory.</p>
</li>
<li>
<p>Edit <code>FooProjectEditor.Build.cs</code> add add <code>DataConfigCore</code> as an extra module:</p>
<pre><code class="language-c++">using UnrealBuildTool;

public class FooProjectEditor : ModuleRules
{
    public FooProjectEditor(ReadOnlyTargetRules Target) : base(Target)
    {
        PublicDependencyModuleNames.AddRange(new string[] { 
			//...
            &quot;DataConfigCore&quot;,	// &lt;- add this
            });
    }
}
</code></pre>
</li>
<li>
<p>DataConfig needs to be explicitly initialized before use. Find <code>FooProjectEditor</code> module's start up and shut down methods and setup DataConfig accordingly.</p>
<pre><code class="language-c++">#include &quot;DataConfig/DcEnv.h&quot;
#include &quot;DataConfig/Automation/DcAutomationUtils.h&quot;

void FFooProjectEditorModule::StartupModule()
{
    // ...
    DcStartUp(EDcInitializeAction::SetAsConsole);
    // dump a FVector to try it out
    FVector Vec(1.0f, 2.0f, 3.0f);
    FDcPropertyDatum VecDatum(TBaseStructure&lt;FVector&gt;::Get(), &amp;Vec);

    DcAutomationUtils::DumpToLog(VecDatum);
}

void FFooProjectEditorModule::ShutdownModule()
{
    // ...
	DcShutDown();
}
</code></pre>
</li>
<li>
<p>Rebuild the project and restart the editor. Open <code>Output Log</code> and you should be able to find the dump results (to filter use <code>Categories -&gt; None</code> ).</p>
<p><img src="Images/Integration-DataConfigCoreOutput.png" alt="Integration-DataConfigCoreOutput" /></p>
</li>
</ol>
<p>You can refer to <a href="Extra/ModuleSetup.html">Module Setup</a> for more detailed integration instructions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>This page documents the overall design, goals and reasoning around DataConfig.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>At the time we started this project we were looking for a JSON parser that:</p>
<ul>
<li>Supports a relaxed JSON spec, i.e. comment and trailing comma.</li>
<li>Supports custom deserialization logic, i.e. deserializes <code>FColor</code> from <code>#RRGGBBAA</code>.</li>
<li>Supports UE instanced sub objects and polymorphism.</li>
</ul>
<p>Ultimately we implemented all these in DataConfig. We also tried not to limit this to be a JSON parser but to provide a set of tools for reading-from and writing-to the property system. </p>
<p>If you are an Unreal Engine C++ developers that:</p>
<ul>
<li>Looking for alternative JSON reader/writer.</li>
<li>Looking for MsgPack serializer.</li>
<li>Looking for a textual configuration format.</li>
<li>Thinking of implementing custom textual/binary format.</li>
<li>Write code that deals with <code>FProperty</code> on a daily bases.</li>
</ul>
<p>You should try DataConfig and it's highly likely DataConfig will fit into your solution.</p>
<h2 id="manifesto"><a class="header" href="#manifesto">Manifesto</a></h2>
<ul>
<li>
<p>Deliver as a quality C++ source library.</p>
<p>DataConfig should ship with no UI nor tooling code. Users are expected to integrate only <code>DataConfigCore</code> as a source module. We intentionally limit the scope of DataConfig to a &quot;C++ Library&quot;. Our users should be proficient UE C++ programmers.</p>
<ul>
<li>DataConfig should ship with good testing and documentation coverage.</li>
<li>DataConfig follows idiomatic UE C++ conventions and has no external dependencies.</li>
<li><code>DataConfigCore</code> depends only on <code>Core</code> and <code>CoreUObject</code> and can be used in standalone <code>Program</code> targets.</li>
<li>DataConfig API are <code>UObject</code> free and stack friendly.</li>
<li>Built-in features serve as examples and sensible defaults. Users are expected to write on their own <code>Reader/Writer/Handlers</code>.</li>
</ul>
</li>
<li>
<p>Runtime performance is <em>not</em> our top priority.</p>
<p>We expect users to use DataConfig in an offline, editor only scenario. In this use case we favor some other aspects over runtime performance:</p>
<ul>
<li>Idiomatic. We follow <a href="https://docs.unrealengine.com/en-US/ProductionPipelines/DevelopmentSetup/CodingStandard/index.html" title="Epic C++ Coding StandardBlueprint Debugging in Unreal Engine">Unreal Engine C++ coding conventions</a> and keep core dependency to only <code>Core</code> and <code>CoreUObject</code>.</li>
<li>Friendly. When processing invalid data and invalid API usage DataConfig should not crash. It should fail explicitly with detailed context and diagnostics.</li>
<li>Small code size / fast compile time. DataConfig tries not to expose template API. <code>TDcJsonReader</code> is explicit instantiated with its definition in private files.</li>
<li>Light memory footprint. Our JSON parser does stream parsing and would <em>not</em> construct the loaded JSON document in memory at all.</li>
</ul>
</li>
<li>
<p>Works with whatever property system supports.</p>
<p>The idea is that DataConfig supports everything that can be tagged with <code>UCLASS/USTRUCT/UPROPERTY/UENUM</code> macros, which covers the full data model of the property system.</p>
<p>Fields such as weak object reference and delegates doesn't make much sense to be serialized into textual format. However it turns out supporting the full data model makes it suitable to some other tasks like debug dump and in-memory data wrangling.</p>
<p>This also means that DataConfig focuses only on reading from and writing into C++ data structures. For example we do not have a DOM or object like API for JSON at all. The only use case DataConfig supports is to deserialize from JSON into native C++ objects.</p>
</li>
</ul>
<h2 id="acknowledgement"><a class="header" href="#acknowledgement">Acknowledgement</a></h2>
<ul>
<li>References <a href="https://serde.rs/" title="SerDe">serde.rs</a> on API and the <code>SerDe</code> acronym.</li>
<li>References <a href="https://github.com/jacobdufault/fullserializer" title="jacobdufault/fullserializer">FullSerializer</a> and <a href="https://github.com/TeamSirenix/odin-serializer" title="TeamSirenix/odin-serializer">OdinSerializer</a> on API.</li>
<li>JSON parser/writer implementation and test cases references <a href="https://json.nlohmann.me" title="JSON for Modern C++">JSON for Modern C++ </a> and <a href="https://rapidjson.org/" title="RapidJSON">RapidJson</a>.</li>
<li>Integrated <a href="https://github.com/nst/JSONTestSuite" title="JSON Parsing Test Suite">nst/JSONTestSuite</a>.</li>
<li>Integrated <a href="https://github.com/kawanet/msgpack-test-suite" title="a dataset for testing msgpack library">kawanet/msgpack-test-suite</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-guides"><a class="header" href="#programming-guides">Programming Guides</a></h1>
<p>This section contains doc for programming DataConfig APIs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dataconfig-data-model"><a class="header" href="#dataconfig-data-model">DataConfig Data Model</a></h1>
<p>Conceptually the DataConfig data model is defined by 3 C++ types:</p>
<ol>
<li><code>EDcDataEntry</code> - enum covers every possible data type.</li>
<li><code>FDcReader</code> - methods to read from the data model.</li>
<li><code>FDcWriter</code> - methods to write into the data model.</li>
</ol>
<p>And that's it. The obvious missing thing is a DOM like object that you can random access and serialize into -  we choose to not implement that and it's crucial to understand this to get to know how DataConfig works.</p>
<h2 id="edcdataentry"><a class="header" href="#edcdataentry"><code>EDcDataEntry</code></a></h2>
<p>The enum covers all possible types:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/DcTypes.h
UENUM()
enum class EDcDataEntry : uint16
{
	Nil,

	Bool,
	Name,
	String,
	Text,
	Enum,

	Float,
	Double,

	Int8,
	Int16,
	Int32,
	Int64,

	UInt8,
	UInt16,
	UInt32,
	UInt64,

	//	Struct
	StructRoot,
	StructEnd,

	//	Class
	ClassRoot,
	ClassEnd,

	//	Map
	MapRoot,
	MapEnd,

	//	Array
	ArrayRoot,
	ArrayEnd,

	//	Set,
	SetRoot,
	SetEnd,

	//	Reference
	ObjectReference,
	ClassReference,

	WeakObjectReference,
	LazyObjectReference,
	SoftObjectReference,
	SoftClassReference,
	InterfaceReference,

	//	Delegates
	Delegate,
	MulticastInlineDelegate,
	MulticastSparseDelegate,

	//	Field
	FieldPath,

	//	Extra
	Blob,

	//	Extension
	Extension,

	//	End
	Ended,
};
</code></pre>
<p>Most enumerators directly maps to a <code>FProperty</code> type:</p>
<ul>
<li><code>EDcDataEntry::Bool</code>  - <code>FBoolProperty</code></li>
<li><code>EDcDataEntry::Name</code> - <code>FNameProperty</code></li>
<li><code>EDcDataEntry::String</code> - <code>FStrProperty</code></li>
<li><code>EDcDataEntry::ArrayRoot/ArrayEnd</code>- <code>FArrayProperty</code></li>
</ul>
<p>It should've covered all possible <code>FProperty</code> types. There're some additions that has no direct <code>FProperty</code> mapping:</p>
<ul>
<li><code>EDcDataEntry::Nil</code> -  It's maps <code>null</code> in JSON, and it's also used to explicitly represent null object reference.</li>
<li><code>EDcDataEntry::Ended</code> - It's a phony type that is returned when there's no more data or reader/writer is in a invalid state.</li>
<li><code>EDcDataEntry::Blob</code> - It's an extension to allow direct memory read/write from given fields. </li>
<li><code>EDcDataEntry::Extension</code> - It's an extension that allows additional data formats. MsgPack reader/writer uses this to support its <code>extension</code> data types.</li>
</ul>
<h2 id="fdcreader"><a class="header" href="#fdcreader"><code>FDcReader</code></a></h2>
<p><code>FDcReader</code> is the one and only way to read from DataConfig data model. For every enumerator in <code>EDcDataEntry</code> there's a member method on <code>FDcReader</code> to from it.</p>
<p>Here we set up a simple struct trying out the reader methods:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.h
USTRUCT()
struct FDcTestExampleSimple
{
	GENERATED_BODY()

	UPROPERTY() FString StrField;
	UPROPERTY() int IntField;
};

// DataConfigTests/Private/DcTestBlurb.cpp
FDcTestExampleSimple SimpleStruct;
SimpleStruct.StrField = TEXT(&quot;Foo Str&quot;);
SimpleStruct.IntField = 253;
</code></pre>
<p>Since we know exactly how the <code>FDcTestExampleSimple</code> looks like we can manually arrange the read calls:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FDcPropertyReader Reader{FDcPropertyDatum(&amp;SimpleStruct)};

DC_TRY(Reader.ReadStructRoot(&amp;Struct));   // `FDcTestExampleSimple` Struct Root

    DC_TRY(Reader.ReadName(&amp;FieldName));  // 'StrField' as FName
    DC_TRY(Reader.ReadString(&amp;StrValue)); // &quot;Foo STr&quot;

    DC_TRY(Reader.ReadName(&amp;FieldName));  // 'IntField' as FName
    DC_TRY(Reader.ReadInt32(&amp;IntValue));  // 253

DC_TRY(Reader.ReadStructEnd(&amp;Struct));    // `FDcTestExampleSimple` Struct Root
</code></pre>
<p>In the example above <code>FDcReader</code> behave like a iterator as each <code>ReadXXX()</code> call emits value and move the internal cursor into the next slot. In case we're reading a unknown structure, we can use <code>FReader::PeekRead()</code> to peek what's coming next.</p>
<h2 id="fdcwriter"><a class="header" href="#fdcwriter"><code>FDcWriter</code></a></h2>
<p><code>FDcWriter</code> is the counter part of writing into the data config model. To write into the example instance above:</p>
<pre><code class="language-c++">DC_TRY(Writer.WriteStructRoot(FDcStructStat{})); // `FDcTestExampleSimple` Struct Root

    DC_TRY(Writer.WriteName(TEXT(&quot;StrField&quot;)));      // 'StrField' as FName
    DC_TRY(Writer.WriteString(TEXT(&quot;Alt Str&quot;)));     // &quot;Foo STr&quot;

    DC_TRY(Writer.WriteName(TEXT(&quot;IntField&quot;)));      // 'IntField' as FName
    DC_TRY(Writer.WriteInt32(233));                  // 233

DC_TRY(Writer.WriteStructEnd(FDcStructStat{}));  // `FDcTestExampleSimple` Struct Root
</code></pre>
<p>There's also <code>FDcWriter::PeekRead()</code> to query whether it's possible to write given data type.</p>
<h2 id="sum-up"><a class="header" href="#sum-up">Sum Up</a></h2>
<p>DataConfig provide <code>FDcReader</code> and <code>FDcWriter</code> to access the property system. It can be considered as a friendly alternative to the property system API. This is also how we support <a href="Programming/../Formats/JSON.html" title="JSON">JSON</a> and <a href="Programming/../Formats/MsgPack.html" title="MsgPack">MsgPack</a> in an uniform API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Proper error handling is crucial to implement robust serialization as it needs to deal with unknown user input. DataConfig also provide diagnostic to help users quickly pin down common errors such as typos or missing colons in JSON. Here's an example:</p>
<pre><code># DataConfig Error: Enum name not found in enum type: EDcTestExampleEnum, Actual: 'Far'
- [JsonReader] --&gt; &lt;in-memory&gt;4:25
   2 |    {
   3 |        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
   4 |        &quot;EnumField&quot; : &quot;Far&quot;,
     |                           ^
   5 |        &quot;Colors&quot; : [
   6 |            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
- [PropertyWriter] Writing property: (FDcTestExampleStruct)$root.(EEDcTestExampleEnum)EnumField
</code></pre>
<p>Internally DataConfig applies a consistent error handling strategy across all API. User code is expected to follow along.</p>
<h2 id="returning-fdcresult"><a class="header" href="#returning-fdcresult">Returning <code>FDcResult</code></a></h2>
<p>The gist is that <strong>if a method can fail, it should return a <code>FDcResult</code></strong>. It's a simple struct:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/DcTypes.h
struct DATACONFIGCORE_API DC_NODISCARD FDcResult
{
    enum class EStatus : uint8
    {
        Ok,
        Error
    };

    EStatus Status;

    FORCEINLINE bool Ok() const
    {
        return Status == EStatus::Ok;
    }
};

//  See FDcReader's methods as example
// DataConfigCore/Public/DataConfig/Reader/DcReader.h
struct DATACONFIGCORE_API FDcReader
{
    //...
    virtual FDcResult ReadBool(bool* OutPtr);
    virtual FDcResult ReadName(FName* OutPtr);
    virtual FDcResult ReadString(FString* OutPtr);
    virtual FDcResult ReadText(FText* OutPtr);
    virtual FDcResult ReadEnum(FDcEnumData* OutPtr);
    //...
};
</code></pre>
<p>Then use <code>DC_TRY</code> to call these kinds of functions. The macro itself does early return when result is not <code>Ok</code>:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/DcTypes.h
#define DC_TRY(expr)                        \
    do {                                    \
        ::FDcResult Ret = (expr);           \
        if (!Ret.Ok()) {                    \
            return Ret;                     \
        }                                   \
    } while (0)

//  Example of calling methods returning `FDcResult`
// DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriterAPI&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    DC_TRY(Ctx.Writer-&gt;WriteStructRoot(FDcStructStat{ TEXT(&quot;Color&quot;), FDcStructStat::WriteCheckName }));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;B&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.B));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;G&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.G));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;R&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.R));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;A&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.A));

    DC_TRY(Ctx.Writer-&gt;WriteStructEnd(FDcStructStat{ TEXT(&quot;Color&quot;), FDcStructStat::WriteCheckName }));

    return DcOk();
}
</code></pre>
<p>This pattern is similar to <a href="https://ned14.github.io/outcome/">Outcome</a> and <a href="https://wg21.link/p0323">std::expected</a> except we give up using the return value. Return values should be passed through reference or pointers in function arguments.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p>When implementing a method that returns <code>FDcResult</code> you have 2 options:</p>
<ul>
<li>Return <code>DcOk()</code> on succeed.</li>
<li>Return <code>DC_FAIL(&lt;Catetory&gt;, &lt;ErrId&gt;)</code> on error.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FDcResult Succeed() {
    // succeed
    return DcOk();
}

FDcResult Fail() {
    // fail !
    return DC_FAIL(DcDCommon, Unexpected1) &lt;&lt; &quot;My Custom Message&quot;;
}
</code></pre>
<p>In the examples above <code>DcDCommon</code> and <code>Unexpected1</code> are called <strong>error category</strong> and <strong>error id</strong> respectively. <code>DcDCommon</code> is a built-in error category:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/Diagnostic/DcDiagnosticCommon.h
namespace DcDCommon
{
static const uint16 Category = 0x1;

enum Type : uint16
{
    //...
    Unexpected1,
};

} // namespace DcDCommon

// DataConfigCore/Private/DataConfig/Diagnostic/DcDiagnosticCommon.cpp
namespace DcDCommon
{
static FDcDiagnosticDetail _CommonDetails[] = {
    // ...
    { Unexpected1, TEXT(&quot;Unexpected: '{0}'&quot;) },
};
</code></pre>
<p>Note that we can pipe argument into the diagnostic. The diagnostic reported by invoking <code>Fail()</code> would be like:</p>
<pre><code>* # DataConfig Error: Unexpected: 'My Custom Message'
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>DataConfig uses <code>FDcResult</code>, <code>DC_TRY</code>, <code>DC_FAIL</code> for error handling. It's lightweight and relatively easy to grasp. There's still some limitations though:</p>
<ul>
<li><code>FDcResult</code> occupied the return position making passing value to parent a bit cumbersome.</li>
<li>For now we always stop as the first error. There's no plan to support error recovery.</li>
</ul>
<p>Some closing notes:</p>
<ul>
<li>Reported diagnostics get queued. You'll need to call <code>FDcEnv::FlushDiags()</code> to flush them to consumers.</li>
<li>See <code>DcDiagnosticExtra.h/cpp</code> for how to register user category.</li>
<li>See <code>DcEditorExtraModule.cpp - FDcMessageLogDiagnosticConsumer</code> for custom diagnostic handler and formatting.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env"><a class="header" href="#env">Env</a></h1>
<p>DataConfig put most global state into a stack of <code>FDcEnv</code>:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/DcEnv.h
struct DATACONFIGCORE_API FDcEnv
{
    TArray&lt;FDcDiagnostic&gt; Diagnostics;

    TSharedPtr&lt;IDcDiagnosticConsumer&gt; DiagConsumer;

    TArray&lt;FDcReader*&gt; ReaderStack;
    TArray&lt;FDcWriter*&gt; WriterStack;

    bool bExpectFail = false;   // mute debug break

    FDcDiagnostic&amp; Diag(FDcErrorCode InErr);

    void FlushDiags();

    FORCEINLINE FDcDiagnostic&amp; GetLastDiag() 
    {
        checkf(Diagnostics.Num(), TEXT(&quot;&lt;empty diagnostics&gt;&quot;));
        return Diagnostics.Last();
    }

    ~FDcEnv();
};
</code></pre>
<p>DataConfig needs explicit initializatioon before use. This is done through manually <code>DcStartUp()</code>. There's also a paired <code>DcShutdown()</code> that should be called when DataConfig isn't used anymore. Here's an example:</p>
<pre><code class="language-c++">// DataConfigEditorExtra/Private/DcEditorExtraModule.cpp
void FDcEditorExtraModule::StartupModule()
{
    UE_LOG(LogDataConfigCore, Log, TEXT(&quot;DcEditorExtraModule module starting up&quot;));
    DcRegisterDiagnosticGroup(&amp;DcDExtra::Details);
    DcRegisterDiagnosticGroup(&amp;DcDEditorExtra::Details);

    DcStartUp(EDcInitializeAction::Minimal);
    //...
}

void FDcEditorExtraModule::ShutdownModule()
{
    DcShutDown();
    //...
}
</code></pre>
<p>The active <code>FDcEnv</code> is accessed by calling global function <code>DcEnv()</code>. Inside the Env:</p>
<ul>
<li><code>Diagnostics</code>: all diagnostics are flushed into env.</li>
<li><code>DiagConsumer</code>: diagnostic handler, format and print diagnostic to log or <code>MessageLog</code> or even on screen.</li>
<li><code>ReaderStack/WriterStack</code>: used to pass along reader/writer down the callstack. See <code>FScopedStackedReader</code> uses for example.</li>
<li>... and everything else.</li>
</ul>
<p>You can use <code>DcPushEnv()</code> to create new env then destroy it calling <code>DcPopEnv()</code>. At this moment it's mostly used to handle reentrant during serialization. See <code>FDcScopedEnv</code> uses for examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="readerwriter"><a class="header" href="#readerwriter">Reader/Writer</a></h1>
<p>FDcReader/FDcWriter defines the set of API for accessing DataConfig data model. Here's a check list for implementing a reader/writer:</p>
<ol>
<li>Implement <code>GetID()/ClassID()</code> for RTTI.</li>
<li>Implement <code>PeekRead()/PeekWriter()</code> and selected set of <code>ReadXXX()/WriteXXX()</code>.</li>
<li>Implement <code>FormatDiagnostic()</code> for error reporting.</li>
</ol>
<p>You should look at builtin implementation for references. Here's some general rules and caveats:</p>
<ul>
<li>
<p><code>PeekRead()/PeekWrite()</code> should act like it's side-effect free.</p>
<p>This means that it's OK to call <code>PeekRead()/PeekWrite()</code> multiple times. In comparison access methods like <code>ReadBool()/WriteBool()</code> consume the data and alternate internal state. Note that under the hood it might do anything. Both returns <code>FDcResult</code> so the peek can fail. The reason behind this is that calling <code>PeekRead()/PeekWrite()</code> is totally optional. In <code>FDcJsonReader::PeekRead()</code> we do parsing and cache the parsed result to follow this convention.</p>
</li>
<li>
<p><code>CastByID()</code> does not respect inheritance hierarchy.</p>
<p>We have this very minimal RTTI implemetantion that only allow casting to the exact type.</p>
</li>
<li>
<p>Implement a subset of the data model.</p>
<p>The API is designed in a way that it covers the whole Property System. It's also a super set that can express common formats like JSON/MsgPack. For example JSON don't have struct, class or set. It's actually the job of Serializer/Deserializer to convert between these subsets to the property system.</p>
</li>
</ul>
<h2 id="builtin-readerwriter"><a class="header" href="#builtin-readerwriter">Builtin Reader/Writer</a></h2>
<p>We have 3 major pairs of reader/writers:</p>
<ul>
<li><code>FDcPropertyReader/FDcPropertyWriter</code> - Accesing Unreal Engin property system.</li>
<li><code>FDcJsonReader/FDcJsonWriter</code> - JSON support.</li>
<li><code>FDcMsgPackReader/FDcMsgPackWriter</code> - MsgPack support.</li>
</ul>
<p>These are all talked about in details in the <a href="Programming/../Formats/index.html" title="Formats">formats section</a>. We'll go through other builtin Reader/Writers below.</p>
<h2 id="fdcpipevisitor-and-fdcprettyprintwriter"><a class="header" href="#fdcpipevisitor-and-fdcprettyprintwriter"><code>FDcPipeVisitor</code> and <code>FDcPrettyPrintWriter</code></a></h2>
<p><code>FDcPipeVisitor</code> takes a <code>FDcReader</code> and a <code>FDcWriter</code> then start peek-read-write loop until it peeks <code>EDcDataEntry::Ended</code> from reader or an error happens </p>
<p>Then there's <code>FDcPrettyPrintWriter</code> that dumps everything that got write to it as string.</p>
<p>Combining these two we get a way to dump arbitrary <code>FDcReader</code> into a string!. This is how built-in debug dump features are implemented:</p>
<pre><code class="language-c++">// DataConfigCore/Private/DataConfig/Automation/DcAutomationUtils.cpp
void DumpToOutputDevice(...)
{
    //...
    FDcPropertyReader PropReader(Datum);
    FDcPrettyPrintWriter PrettyWriter(Output);
    FDcPipeVisitor PrettyPrintVisit(&amp;PropReader, &amp;PrettyWriter);

    if (!PrettyPrintVisit.PipeVisit().Ok())
        ScopedEnv.Get().FlushDiags();
    //...
}
</code></pre>
<p><code>FDcPipeVisitor</code> is a handy utility that we use it extensively through the code base for various cases. Try <code>FDcPipeVisitor</code> when you got a reader/writer pair.</p>
<p>There's also <code>FNoopWriter</code> takes every write and do nothing with it.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Reader/Writers can also be composited and nested:</p>
<ul>
<li><code>FDcWeakCompositeWriter</code> is a writer that multiplex into a list of writers. You can combine an arbitrary writer with a <code>FPrettyPrintWriter</code> then get a tracing writer.</li>
<li><code>FDcPutbackReader/FPutbackWriter</code>: Reader/writers don't support lookahead. It can only peek next item's type but not value. This class is used to support limited lookahead by <em>putting back</em> read value. We'll see it being used in implementing custom deserializer handlers.</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Implement new <code>FDcReader/FDcWriter</code> when you want to support a new file format. You can also write utility reader/writer that composite existing ones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serializerdeserializer"><a class="header" href="#serializerdeserializer">Serializer/Deserializer</a></h1>
<p>Serializer/Deserializer are built on top of the data model to convert between external format and Unreal Engine property system.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>A company class to the deserializer is <code>FDcDeserializeContext</code>:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/Deserialize/DcDeserializeTypes.h
struct DATACONFIGCORE_API FDcDeserializeContext
{
    //...
    FDcDeserializer* Deserializer;
    FDcReader* Reader;
    FDcPropertyWriter* Writer;
    //...
};
</code></pre>
<p>Note how it takes an <code>FDcReader</code> and a <code>FPropertyWriter</code> - we're deserializing arbitrary format into the property system.</p>
<p>The mirrored version for serializer is <code>FDcSerializeContext</code>.</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/Serialize/DcSerializeTypes.h
struct DATACONFIGCORE_API FDcSerializeContext
{
    //...
    FDcSerializer* Serializer = nullptr;
    FDcPropertyReader* Reader = nullptr;
    FDcWriter* Writer = nullptr;
    //...
};
</code></pre>
<p>Note how it takes an <code>FDcWriter</code> and a <code>FDcPropertyReader</code> - we're serializing data from the property system to arbitrary format.</p>
<p>Since serializer and deserializer have extremely similar APIs, we're showing examples using deserializer below from here. </p>
<h2 id="handlers"><a class="header" href="#handlers">Handlers</a></h2>
<p>Say that we're deserializing a JSON object into a <code>USTRUCT</code> instance. The <code>FDcJsonReader</code> implements <code>ReadMapRoot()/ReadMapEnd()</code> but doesn't have <code>ReadStructRoot()/ReadStructEnd()</code>. To make the conversion we basically want to map <code>ReadMap()</code> and calls into <code>WriteStruct()</code> calls. This is where <strong>handlers</strong> come into play:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/SerDe/DcDeserializeCommon.inl
FDcResult DcHandlerDeserializeMapToStruct(FDcDeserializeContext&amp; Ctx)
{
    FDcStructAccess Access;
    DC_TRY(Ctx.Reader-&gt;ReadMapRoot());
    DC_TRY(Ctx.Writer-&gt;WriteStructRootAccess(Access));

    EDcDataEntry CurPeek;
    while (true)
    {
        DC_TRY(Ctx.Reader-&gt;PeekRead(&amp;CurPeek));
        if (CurPeek == EDcDataEntry::MapEnd)
            break;

        FName FieldName;
        DC_TRY(Ctx.Reader-&gt;ReadName(&amp;FieldName));
        DC_TRY(Ctx.Writer-&gt;WriteName(FieldName));

        DC_TRY(DcDeserializeUtils::RecursiveDeserialize(Ctx));
    }

    DC_TRY(Ctx.Reader-&gt;ReadMapEnd());
    DC_TRY(Ctx.Writer-&gt;WriteStructEnd());

    return DcOk();
}

// DataConfigCore/Private/DataConfig/Deserialize/Handlers/Json/DcJsonCommonDeserializers.cpp
FDcResult HandlerStructRootDeserialize(FDcDeserializeContext&amp; Ctx)
{
    return DcHandlerDeserializeMapToStruct(Ctx);
}
</code></pre>
<p>Note that <code>Ctx.Reader</code> is a <code>FDcReader</code> that can be any derived class, while <code>Ctx.Writer</code> is always a <code>FDcPropertyWriter</code>. Deserialize handlers have an uniform signature:</p>
<pre><code class="language-c++">using FDcDeserializeDelegateSignature = FDcResult(*)(FDcDeserializeContext&amp; Ctx);
</code></pre>
<h2 id="deserializer-setup"><a class="header" href="#deserializer-setup">Deserializer Setup</a></h2>
<p>Note how deserialize handler above doesn't specify when it should be invoked. 
These info are described in <code>FDcDeserializer</code>:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/Deserialize/DcDeserializer.h
struct DATACONFIGCORE_API FDcDeserializer : public FNoncopyable
{
    //...
    FDcResult Deserialize(FDcDeserializeContext&amp; Ctx);

    void AddDirectHandler(FFieldClass* PropertyClass, FDcDeserializeDelegate&amp;&amp; Delegate);
    void AddDirectHandler(UClass* PropertyClass, FDcDeserializeDelegate&amp;&amp; Delegate);
    void AddPredicatedHandler(FDcDeserializePredicate&amp;&amp; Predicate, FDcDeserializeDelegate&amp;&amp; Delegate);
    //...
};
</code></pre>
<p>Comparing to <code>FDcDeserializeContext</code>, which describes data needed for a single run, 
<code>FDcDeserializer</code> contains info on what handlers to execute. Deserializer can also be reused across multiple
runs.</p>
<p>We use &quot;direct handlers&quot; to cover common cases:</p>
<pre><code class="language-c++">// DataConfigCore/Private/DataConfig/Deserialize/DcDeserializerSetup.cpp
Deserializer.AddDirectHandler(FArrayProperty::StaticClass(), FDcDeserializeDelegate::CreateStatic(HandlerArrayDeserialize));
Deserializer.AddDirectHandler(FSetProperty::StaticClass(), FDcDeserializeDelegate::CreateStatic(HandlerSetDeserialize));
Deserializer.AddDirectHandler(FMapProperty::StaticClass(), FDcDeserializeDelegate::CreateStatic(HandlerMapDeserialize));
</code></pre>
<p>These basically says that &quot;when running into array, set, map properties, use these provided handlers&quot;. </p>
<p>Then we have &quot;predicated handler&quot; that get tested very early. This is how we allow custom conversion logic
setup for very specific class:</p>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeColor.cpp
EDcDeserializePredicateResult PredicateIsColorStruct(FDcDeserializeContext&amp; Ctx)
{
    UScriptStruct* Struct = DcPropertyUtils::TryGetStructClass(Ctx.TopProperty());
    return Struct &amp;&amp; Struct == TBaseStructure&lt;FColor&gt;::Get()
        ? EDcDeserializePredicateResult::Process
        : EDcDeserializePredicateResult::Pass;
}

// ...
Ctx.Deserializer-&gt;AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(HandlerColorDeserialize)
);
</code></pre>
<p>By convention the current deserializing property can be retrieved with <code>Ctx.TopProperty()</code>. 
Here we simply test if it's a <code>UScriptStruct</code> that's equal to <code>FColor::StaticClass()</code>.
If that's the case execute the provided handler.</p>
<h2 id="sum-up-1"><a class="header" href="#sum-up-1">Sum Up</a></h2>
<p>Serializer/Deserializer are built on top of Reader/Writer, to convert between Unreal Engine 
property system and external data formats.</p>
<ul>
<li><code>FDcSerializeContext/FDcDeserializeContext</code> contains data.</li>
<li><code>FDcSerializer/FDcDeserializer</code> contains setup.</li>
<li>Implement <code>FDcDeserializeDelegate/FDcSerializeDelegate</code> and <code>FDcDeserializePredicate/FDcSerializePredicate</code>
pair for custom conversion logic.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formats"><a class="header" href="#formats">Formats</a></h1>
<p>This section contains documentation for supported formats.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">JSON</a></h1>
<p><a href="https://www.json.org/json-en.html" title="Introducing JSON">JSON</a> is likely the most popular data interchange format. Unreal Engine already supports it with <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/JsonUtilities/" title="JsonUtilities"><code>JsonUtilities</code></a> and some related modules. We provide an alternative implementation along with DataConfig.</p>
<h2 id="json-reader"><a class="header" href="#json-reader">JSON Reader</a></h2>
<p><code>FDcJsonReader</code> is the DataConfig JSON reader:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;Str&quot;:    &quot;Fooo&quot;,
        &quot;Number&quot;: 1.875,
        &quot;Bool&quot;:   true
    } 
)&quot;);

FDcJsonReader Reader(Str);

//  calling read methods
FString KeyStr;
FString GotStr;
double GotNumber;
bool GotBool;

DC_TRY(Reader.ReadMapRoot());

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadString(&amp;GotStr));

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadDouble(&amp;GotNumber));

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadBool(&amp;GotBool));

DC_TRY(Reader.ReadMapEnd());

//  validate results
check(GotStr == TEXT(&quot;Fooo&quot;));
check(GotNumber == 1.875);
check(GotBool == true);
</code></pre>
<p>In the example above we deserialized a <code>JSON</code> object from string. The first and last calls are <code>ReadMapRoot</code> and <code>ReadMapEnd</code>, which are also used to read Unreal's <code>TMap</code> properties. The difference is that UE's <code>TMap</code> is strictly typed while JSON object values can have arbitrary type. This means that if you use <code>FDcPipeVisitor</code> to pipe a <code>FDcJsonReader</code> into a <code>FDcPropertyWriter</code> it won't work.</p>
<p>Remember that DataConfig data model is designed to support conversion between subsets within the data model. As long as you can use <code>FDcReader/FDcWriter</code> API to describe the format you want to serialize you're good to go. Mapping and conversion between these different shapes of reader/writers are handled by <a href="Formats/../Programming/SerializerDeserializer.html">deserializers</a>.</p>
<p>Some additional caveats:</p>
<ul>
<li>Similar to stock <code>TJsonReader</code>, we provide <code>TDcJsonReader</code> with 2 specializations:
<ul>
<li>Usually you just use <code>FDcJsonReader</code> that reads from <code>FString, TCHAR*</code>.</li>
<li>Under the hood there're <code>FDcAnsiJsonReader</code> that reads ANSICHAR string
and <code>FDcWideJsonReader</code> that reads WIDECHAR string.</li>
</ul>
</li>
<li>We support a relaxed superset of JSON:
<ul>
<li>Allow C Style comments, i.e <code>/* block */</code> and <code>// line</code> .</li>
<li>Allow trailing comma, i.e <code>[1,2,3,],</code> .</li>
<li>Allow non object root. You can put a list as the root, or even string, numbers.</li>
</ul>
</li>
<li>Number parsing are delegated to Unreal's built-ins to reduce dependencies. We might change this in the future.
<ul>
<li>Parse numbers: <code>TCString::Atof/Strtoi/Strtoi64</code></li>
</ul>
</li>
</ul>
<h2 id="json-writer"><a class="header" href="#json-writer">JSON Writer</a></h2>
<p><code>FDcJsonWriter</code> is the DataConfig JSON writer:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FDcJsonWriter Writer;

DC_TRY(Writer.WriteMapRoot());

    DC_TRY(Writer.WriteString(TEXT(&quot;Str&quot;)));
    DC_TRY(Writer.WriteString(TEXT(&quot;Fooo&quot;)));

    DC_TRY(Writer.WriteString(TEXT(&quot;Number&quot;)));
    DC_TRY(Writer.WriteFloat(1.875f));

    DC_TRY(Writer.WriteString(TEXT(&quot;Bool&quot;)));
    DC_TRY(Writer.WriteBool(true));

DC_TRY(Writer.WriteMapEnd());
Writer.Sb.Append(TCHAR('\n'));

FString Str = TEXT(R&quot;(
    {
        &quot;Str&quot; : &quot;Fooo&quot;,
        &quot;Number&quot; : 1.875,
        &quot;Bool&quot; : true
    }
)&quot;);

//  validate results
check(DcReindentStringLiteral(Str) == Writer.Sb.ToString());
return DcOk();
</code></pre>
<ul>
<li>Similar to stock <code>TJsonWriter</code>, we provide <code>TDcJsonWriter</code> with 2 specializations:
<ul>
<li>Usually you just use <code>FDcJsonWriter</code> that writes <code>FString, TCHAR*</code>.</li>
<li>Under the hood there're <code>FDcAnsiJsonWriter</code> that writes ANSICHAR string
and <code>FDcWideJsonWriter</code> that writes WIDECHAR string.</li>
</ul>
</li>
<li>It takes a <code>Config</code> object that specify formatting settings like indentation size and new lines.
<ul>
<li><code>FDcPrettyJsonWriter</code> is a type alias that formats indented JSON.</li>
<li><code>FDcCondensedJsonWriter</code> is a type alias that format single line, condensed output. </li>
</ul>
</li>
<li><code>FDcJsonWriter</code> owns the output string buffer, in <code>FDcJsonWriter::Sb</code>.
<ul>
<li>By writing to a single writer and appending a new line after each serialization, we can output <a href="http://ndjson.org/" title="ndjson">NDJSON</a>. </li>
<li>Our JSON reader is also flexible enough to directly load NDJSON. See <a href="Formats/../Advanced/Benchmark.html">corpus benchmark</a>. </li>
</ul>
</li>
</ul>
<h2 id="json-serializedeserialize"><a class="header" href="#json-serializedeserialize">JSON Serialize/Deserialize</a></h2>
<p>DataConfig bundles a set of JSON serialize and deserialize handlers, which are all roundtrip-able:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
#include &quot;DataConfig/Deserialize/DcDeserializerSetup.h&quot;

// ...
//  create and setup a deserializer
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);

//  create and setup a serializer
FDcSerializer Serializer;
DcSetupJsonSerializeHandlers(Serializer);
</code></pre>
<h3 id="schema"><a class="header" href="#schema">Schema</a></h3>
<p>JSON types get mapped into DataConfig data model in a very unsurprising way.</p>
<table><thead><tr><th style="text-align: left">JSON Type</th><th>DcDataEntry</th></tr></thead><tbody>
<tr><td style="text-align: left">Boolean</td><td>Bool</td></tr>
<tr><td style="text-align: left">Null</td><td>Nil</td></tr>
<tr><td style="text-align: left">String</td><td>String, Name, Text, Enum</td></tr>
<tr><td style="text-align: left">Number</td><td>(All numerics)</td></tr>
<tr><td style="text-align: left">Array</td><td>Array, Set</td></tr>
<tr><td style="text-align: left">Object</td><td>Class, Struct, Map</td></tr>
</tbody></table>
<p>Here's an example:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;BoolField&quot; : true,
        &quot;NameField&quot; : &quot;AName&quot;,
        &quot;StringField&quot; : &quot;AStr&quot;,
        &quot;TextField&quot; : &quot;AText&quot;,
        &quot;EnumField&quot; : &quot;Tard&quot;,

        &quot;FloatField&quot; : 17.5,
        &quot;DoubleField&quot; : 19.375,

        &quot;Int8Field&quot; : -43,
        &quot;Int16Field&quot; : -2243,
        &quot;Int32Field&quot; : -23415,
        &quot;Int64Field&quot; : -1524523,

        &quot;UInt8Field&quot; : 213,
        &quot;UInt16Field&quot; : 2243,
        &quot;UInt32Field&quot; : 23415,
        &quot;UInt64Field&quot; : 1524523,
    }
)&quot;);

//  deserialized equivelent

FDcTestStruct1 Expect;
Expect.BoolField = true;
Expect.NameField = TEXT(&quot;AName&quot;);
Expect.StringField = TEXT(&quot;AStr&quot;);
Expect.TextField = FText::FromString(TEXT(&quot;AText&quot;));
Expect.EnumField = EDcTestEnum1::Tard;

Expect.FloatField = 17.5f;
Expect.DoubleField = 19.375;

Expect.Int8Field = -43;
Expect.Int16Field = -2243;
Expect.Int32Field = -23415;
Expect.Int64Field = -1524523;

Expect.UInt8Field = 213;
Expect.UInt16Field = 2243,
Expect.UInt32Field = 23415;
Expect.UInt64Field = 1524523;
</code></pre>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>JSON only allow string as object/mapping keys, while in UE <code>TMap&lt;&gt;</code> can use any type. When doing serialization <code>TMap&lt;FString/FName/FText,(TValue)&gt;</code> types would be directly converted to a JSON object:</p>
<pre><code class="language-c++">// DataConfigTests/Public/DcTestDeserialize.h
USTRUCT()
struct FDcTestStruct3
{
    // ...
    UPROPERTY() TMap&lt;FString, FString&gt; StringMap;
};

// DataConfigTests/Public/DcTestDeserialize.cpp
{
    // ...
    &quot;StringMap&quot; : {
        &quot;One&quot;: &quot;1&quot;,
        &quot;Two&quot;: &quot;2&quot;, 
        &quot;Three&quot;: &quot;3&quot;,
    },
}
</code></pre>
<p>For other key types it would be serialized as an array of objects:</p>
<pre><code class="language-c++">// DataConfigTests/Public/DcTestSerDe.h
USTRUCT()
struct FDcTestStructMaps
{
    // ...
    UPROPERTY() TMap&lt;FColor, FString&gt; ColorKeyMap;
    UPROPERTY() TMap&lt;EDcTestEnumFlag, FString&gt; EnumFlagsMap;
};

// DataConfigTests/Public/DcTestDeserialize.cpp
{
    &quot;ColorKeyMap&quot; : {
        &quot;#FF0000FF&quot; : &quot;Red&quot;,
        &quot;#00FF00FF&quot; : &quot;Green&quot;,
        &quot;#0000FFFF&quot; : &quot;Blue&quot;
    },
    &quot;EnumFlagsMap&quot; : [
        {
            &quot;$key&quot; : [],
            &quot;$value&quot; : &quot;None&quot;
        },
        {
            &quot;$key&quot; : [
                &quot;One&quot;,
                &quot;Three&quot;
            ],
            &quot;$value&quot; : &quot;One | Three&quot;
        },
        {
            &quot;$key&quot; : [
                &quot;Five&quot;
            ],
            &quot;$value&quot; : &quot;Five&quot;
        }
    ]
}
</code></pre>
<h3 id="enum-flags"><a class="header" href="#enum-flags">Enum Flags</a></h3>
<p><code>UENUM</code> that get marked with <code>Bitflags</code> meta are deserialized from a list of strings:</p>
<pre><code class="language-c++">// DataConfigTests/Public/DcTestDeserialize.h
UENUM(meta = (Bitflags))
enum class EDcTestEnumFlag :uint32
{
    None    = 0,
    One     = (1 &lt;&lt; 0),
    Two     = (1 &lt;&lt; 1),
    //...
};
ENUM_CLASS_FLAGS(EDcTestEnumFlag);

// DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;EnumFlagField1&quot; : [],
        &quot;EnumFlagField2&quot; : [&quot;One&quot;, &quot;Three&quot;, &quot;Five&quot;],
    }
)&quot;);

//  deserialized equivelent
FDcTestStructEnumFlag1 Expect;
Expect.EnumFlagField1 = EDcTestEnumFlag::None;
Expect.EnumFlagField2 = EDcTestEnumFlag::One | EDcTestEnumFlag::Three | EDcTestEnumFlag::Five;
</code></pre>
<h3 id="sub-objects"><a class="header" href="#sub-objects">Sub Objects</a></h3>
<p>By default we treat <code>UOBJECT</code> marked with <code>DefaultToInstanced, EditInlineNew</code> and <code>UPROPERTY</code> marked with <code>Instanced</code> as sub object. In this case we'll actually instantiate new object during deserialization, using <code>Ctx.TopObject()</code> as parent:</p>
<pre><code class="language-c++">// DataConfigTests/Public/DcTestProperty.h
UCLASS(BlueprintType, EditInlineNew, DefaultToInstanced)
class UDcBaseShape : public UObject
{
    //...
    UPROPERTY() FName ShapeName;
};

UCLASS()
class UDcShapeBox : public UDcBaseShape
{
    //...
    UPROPERTY() float Height;
    UPROPERTY() float Width;
};

UCLASS()
class UDcShapeSquare : public UDcBaseShape
{
    //...
    UPROPERTY() float Radius;
};

// DataConfigTests/Public/DcTestDeserialize.h
USTRUCT()
struct FDcTestStructShapeContainer1
{
    GENERATED_BODY()

    UPROPERTY() UDcBaseShape* ShapeField1;
    UPROPERTY() UDcBaseShape* ShapeField2;
    UPROPERTY() UDcBaseShape* ShapeField3;
}USTRUCT()
struct FDcEditorExtraTestObjectRefs1
{
    GENERATED_BODY()

    UPROPERTY() UObject* ObjField1;
    UPROPERTY() UObject* ObjField2;
    UPROPERTY() UObject* ObjField3;
    UPROPERTY() UObject* ObjField4;
};

// DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ShapeField1&quot; :  {
            &quot;$type&quot; : &quot;DcShapeBox&quot;,
            &quot;ShapeName&quot; : &quot;Box1&quot;,
            &quot;Height&quot; : 17.5,
            &quot;Width&quot; : 1.9375
        },
        &quot;ShapeField2&quot; : {
            &quot;$type&quot; : &quot;DcShapeSquare&quot;,
            &quot;ShapeName&quot; : &quot;Square1&quot;,
            &quot;Radius&quot; : 1.75,
        },
        &quot;ShapeField3&quot; : null
    }
)&quot;);

//  deserialized equivelent
UDcShapeBox* Shape1 = NewObject&lt;UDcShapeBox&gt;();
Shape1-&gt;ShapeName = TEXT(&quot;Box1&quot;);
Shape1-&gt;Height = 17.5;
Shape1-&gt;Width = 1.9375;
Expect.ShapeField1 = Shape1;

UDcShapeSquare* Shape2 = NewObject&lt;UDcShapeSquare&gt;();
Shape2-&gt;ShapeName = TEXT(&quot;Square1&quot;);
Shape2-&gt;Radius = 1.75;
Expect.ShapeField2 = Shape2;

Expect.ShapeField3 = nullptr;
</code></pre>
<p>Note that criteria for sub object selection can be easily overridden with a new deserialize predicate or alternative <code>FDcPropertyConfig</code> when constructing the reader.</p>
<p>Also see <a href="Formats/../Extra/AnyStruct.html">AnyStruct</a>, <a href="Formats/../Extra/InlineStruct.html">InlineStruct</a> and <a href="Formats/../Extra/InstancedStruct.html">InstancedStruct</a> for lighter weight alternatives.</p>
<h3 id="object-and-class-reference"><a class="header" href="#object-and-class-reference">Object and Class Reference</a></h3>
<p>We support multiple ways of referencing a <code>UObject</code> in memory or serialized on disk:</p>
<pre><code class="language-c++">// DataConfigEditorExtra/Private/DataConfig/EditorExtra/Tests/DcTestDeserializeEditor.h
USTRUCT()
struct FDcEditorExtraTestObjectRefs1
{
    GENERATED_BODY()

    UPROPERTY() UObject* ObjField1;
    UPROPERTY() UObject* ObjField2;
    UPROPERTY() UObject* ObjField3;
    UPROPERTY() UObject* ObjField4;
};

// DataConfigEditorExtra/Private/DataConfig/EditorExtra/Tests/DcTestDeserializeEditor.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ObjField1&quot; : &quot;DcEditorExtraNativeDataAsset'/DataConfig/DcFixture/DcTestNativeDataAssetAlpha.DcTestNativeDataAssetAlpha'&quot;,
        &quot;ObjField2&quot; : &quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;,
        &quot;ObjField3&quot; : 
        {
            &quot;$type&quot; : &quot;DcEditorExtraNativeDataAsset&quot;,
            &quot;$path&quot; : &quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;
        },
        &quot;ObjField4&quot; : null,
    }
)&quot;);

//  deserialized equivelent
UDcEditorExtraNativeDataAsset* DataAsset = Cast&lt;UDcEditorExtraNativeDataAsset&gt;(StaticLoadObject(
    UDcEditorExtraNativeDataAsset::StaticClass(),
    nullptr,
    TEXT(&quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;),
    nullptr
));

Expect.ObjField1 = DataAsset;
Expect.ObjField2 = DataAsset;
Expect.ObjField3 = DataAsset;
Expect.ObjField4 = nullptr;
</code></pre>
<p>In the example above, <code>ObjField1</code> uses the reference string that can be retrieved in editor context menu:</p>
<p><img src="Formats/Images/Deserialize-CopyReference.png" alt="Deserialize-CopyReference" /></p>
<p>For <code>ObjField2/ObjField3</code>  relative path to the <code>uasset</code> is used, but without file name suffix.</p>
<p>We also support class reference fields of <code>TSubclassOf&lt;&gt;</code>s:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestDeserialize.h
USTRUCT()
struct FDcTestStructSubClass1
{
    GENERATED_BODY()

    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField1;
    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField2;
    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField3;
};

// DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StructSubClassField1&quot; : null,
        &quot;StructSubClassField2&quot; : &quot;ScriptStruct&quot;,
        &quot;StructSubClassField3&quot; : &quot;DynamicClass&quot;,
    }
)&quot;);

//  deserialized equivelent
FDcTestStructSubClass1 Expect;
Expect.StructSubClassField1 = nullptr;
Expect.StructSubClassField2 = UScriptStruct::StaticClass();
Expect.StructSubClassField3 = UDynamicClass::StaticClass();
</code></pre>
<p>Note that these do not support Blueprint classes. The direct reason is that Blueprint depends on <code>Engine</code> module and we'd like not to take dependency on in <code>DataConfigCore</code>. </p>
<p>We do have an example that supports Blueprint classes, see <code>DataConfigEditorExtra -  DcDeserializeBPClass.h/cpp</code></p>
<h2 id="soft-lazy-as-string"><a class="header" href="#soft-lazy-as-string">Soft Lazy as String</a></h2>
<p><code>DcSetupJsonSerializeHandlers()/DcSetupJsonDeserializeHandlers()</code> accepts an enum to setup alternative handlers. For now <code>StringSoftLazy</code> branch would setup special <code>FSoftObjectProperty/FLazyObjectProperty</code> handlers that directly serialize these into string. Comparing to this the default setup would always resolve the indirect reference into memory, which maybe isn't always desirable. </p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FDcTestStructRefs1 Source{};
UObject* TestsObject = StaticFindObject(UObject::StaticClass(), nullptr, TEXT(&quot;/Script/DataConfigTests&quot;));

Source.SoftField1 = TestsObject;
Source.LazyField1 = TestsObject;

FDcJsonWriter Writer;
DC_TRY(DcAutomationUtils::SerializeInto(&amp;Writer, FDcPropertyDatum(&amp;Source),
[](FDcSerializeContext&amp; Ctx) {
    DcSetupJsonSerializeHandlers(*Ctx.Serializer, EDcJsonSerializeType::StringSoftLazy);
}, DcAutomationUtils::EDefaultSetupType::SetupNothing));

//  serialized result
{
    // ...
    &quot;SoftField1&quot; : &quot;/Script/DataConfigTests&quot;,
    &quot;SoftField2&quot; : &quot;&quot;,
    &quot;LazyField1&quot; : &quot;C851179E-45A51045-0006AE91-F9B16EC0&quot;,
    &quot;LazyField2&quot; : &quot;00000000-00000000-00000000-00000000&quot;
}
</code></pre>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p>Here're some closing notes:</p>
<ul>
<li>
<p>For meta fields like <code>$type</code> it must be the first member, meaning object fields are order dependent. This means that the JSON we're supporting is a super set of standard JSON spec (again).</p>
</li>
<li>
<p>Bundled serializers and deserializers are designed to be roundtrip-able. For example in test <code>DataConfig.Core.RoundTrip.JsonRoundtrip1_Default</code>:</p>
<ol>
<li>Serialize <code>UDcTestRoundtrip1</code> instance <code>Source</code> into JSON.</li>
<li>Then deserialize JSON above into instance <code>Dest</code>.</li>
<li>Deep-compare <code>Source</code> and <code>Dest</code>. If they're equal them we say it's a roundtrip.</li>
</ol>
<p>Note that we carefully picked float and doubles in the test case, as it's tricky to support floating point roundtrip. We might consider supporting this with alternative float parse and format routines.</p>
</li>
<li>
<p>There're many data types that can not be deserialized from JSON, for example <code>Delegate/WeakObjectReference</code>. Remember that you always have the option to override or selectively enable handlers to support additional properties that make sense in your context. See <code>DcSetupJsonDeserializeHandlers()</code> body on how handlers are registered. You can skip this method and select the ones you want and provide additional handlers.</p>
</li>
<li>
<p>The JSON handlers are designed to <em>NOT</em> read anything during the deserialization. This is crucial since <code>USTRUCT</code> can contain uninitialized fields. For example:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        // pass
    } 
)&quot;);
FDcJsonReader Reader(Str);

FDcTestExampleSimple Dest;
FDcPropertyDatum DestDatum(&amp;Dest);

DC_TRY(DcAutomationUtils::DeserializeJsonInto(&amp;Reader, DestDatum));

check(Dest.StrField.IsEmpty());
//  but Dest.IntField contains uninitialized value
DcAutomationUtils::DumpToLog(DestDatum);

// dump results
&lt;StructRoot&gt; 'DcTestExampleSimple'
|---&lt;Name&gt; 'StrField'
|---&lt;String&gt; ''
|---&lt;Name&gt; 'IntField'
|---&lt;Int32&gt; '1689777552' // &lt;- arbitrary value
&lt;StructEnd&gt; 'DcTestExampleSimple'
</code></pre>
<p>This would cause trouble when you try read a pointer field during deserialization. Remember that primitive fields might be uninitialized during deserialization when implementing your own handlers.</p>
</li>
<li>
<p>One interesting trait of the pull/push styled API is that <code>FDcJsonReader</code> does <strong>not</strong> preemptively parse number into double and convert it to <code>int/float</code> later on. When reading a number token it would do the number parsing at call site. If <code>ReadIntX()</code> is called then the number is parsed as integer. If <code>ReadFloat()/ReadDouble()</code> is called the token will be parsed as floating point.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msgpack"><a class="header" href="#msgpack">MsgPack</a></h1>
<p><a href="https://msgpack.org/index.html" title="MsgPack">MsgPack</a> is an popular binary serialization format. It can be considered as a binary superset of JSON. Unreal Engine already supports <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Cbor" title="Cbor"><code>Cbor</code></a> module which is a format which is very similar to MsgPack.</p>
<p>We choose to implement MsgPack as we're more familiar with it and also providing an alternative.</p>
<h2 id="msgpack-readerwriter"><a class="header" href="#msgpack-readerwriter">MsgPack Reader/Writer</a></h2>
<p>For the most part MsgPack reader/writer works just like their <a href="Formats/./Json.html">JSON counterpart</a>. There're just a few additional data types that belongs to this:</p>
<h3 id="binary"><a class="header" href="#binary">Binary</a></h3>
<p>MsgPack directly supports <code>bin format family</code> which directly maps to <code>EDcDataEntry::Blob</code>:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
DC_TRY(Writer.WriteBlob({Bytes, 0}));
TArray&lt;uint8&gt; Arr = {1,2,3,4,5};

FDcMsgPackWriter Writer;
DC_TRY(Writer.WriteBlob(FDcBlobViewData::From(Arr)));
auto&amp; Buf = Writer.GetMainBuffer();

FDcMsgPackReader Reader(FDcBlobViewData::From(Buf));
FDcBlobViewData Blob;
DC_TRY(Reader.ReadBlob(&amp;Blob));

check(Blob.Num == 5);
check(FPlatformMemory::Memcmp(Arr.GetData(), Blob.DataPtr, Blob.Num) == 0);
</code></pre>
<h3 id="extension"><a class="header" href="#extension">Extension</a></h3>
<p>MsgPack also supports <code>ext format family</code> which is basically fixed size binary data with a header:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb.cpp
FDcMsgPackWriter Writer;
DC_TRY(Writer.WriteFixExt2(1, {2, 3}));
auto&amp; Buf = Writer.GetMainBuffer();

FDcMsgPackReader Reader(FDcBlobViewData::From(Buf));
uint8 Type;
FDcBytes2 Bytes;
DC_TRY(Reader.ReadFixExt2(&amp;Type, &amp;Bytes));

check(Type == 1);
check(Bytes.Data[0] == 2);
check(Bytes.Data[1] == 3);
</code></pre>
<h2 id="msgpack-serializedeserialize"><a class="header" href="#msgpack-serializedeserialize">MsgPack Serialize/Deserialize</a></h2>
<p>MsgPack handlers also support multiple setup types:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/Serialize/DcSerializerSetup.h
enum class EDcMsgPackSerializeType
{
    Default,
    StringSoftLazy, // Serialize Soft/Lazy references as string
    InMemory,       // Serialize pointer/enum/FName etc as underlying integer values
};
</code></pre>
<h3 id="persistent-handlers"><a class="header" href="#persistent-handlers">Persistent handlers</a></h3>
<p>The <code>Default</code> and <code>StringSoftLazy</code> options would setup a set of handlers that behaves
like their JSON counterparts. </p>
<p>We have a &quot;Property -&gt; Json -&gt; MsgPack -&gt; Json -&gt; Property&quot; roundtrip test setup in <code>DataConfig.Core.RoundTrip.Property_Json_MsgPack_Json_Property</code> test.</p>
<h3 id="in-memory-handlers"><a class="header" href="#in-memory-handlers">In Memory handlers</a></h3>
<p>This is a special set of handlers that only makes sense for binary formats. For example pointers are serialized as memory addresses.</p>
<table><thead><tr><th>EDcDataEntry</th><th>Serialized</th></tr></thead><tbody>
<tr><td>Name</td><td><code>[uint32, uint32, int32]</code></td></tr>
<tr><td>Text</td><td><code>[void*, void*, uint32]</code></td></tr>
<tr><td>ObjectReference, ClassReference</td><td><code>void*</code></td></tr>
<tr><td>SoftObjectReference, SoftClassReference</td><td><code>FString or void*</code></td></tr>
<tr><td>WeakObjectReference</td><td><code>[int32, int32]</code></td></tr>
<tr><td>LazyObjectReference</td><td><code>&lt;uuid as FIXEXT16&gt;</code></td></tr>
<tr><td>InterfaceReference</td><td><code>[void*, void*]</code></td></tr>
<tr><td>Delegate</td><td><code>[int32, int32, (FName)[uint32, uint32, int32]]</code></td></tr>
<tr><td>MulticastInlineDelegate, MulticastSparseDelegate</td><td><code>[(list of &lt;Delegate&gt;)]</code></td></tr>
<tr><td>FieldPath</td><td><code>void*</code></td></tr>
<tr><td>Enum</td><td><code>uint64</code></td></tr>
</tbody></table>
<p>With these handlers all data types can be serialized. Note that serializing stuff as memory address isn't always what you want. These are provided as soft of a reference on how to access various data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property"><a class="header" href="#property">Property</a></h1>
<p>The property system is at the heart of DataConfig: serializer read from property system, while deserializer writes into it. This is directly reflected in the types:</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/Serialize/DcSerializeTypes.h
struct DATACONFIGCORE_API FDcSerializeContext
{
    // ...
    FDcPropertyReader* Reader = nullptr;
    FDcWriter* Writer = nullptr;
};

// DataConfigCore/Public/DataConfig/Deserialize/DcDeserializeTypes.h
struct DATACONFIGCORE_API FDcDeserializeContext
{
    FDcReader* Reader = nullptr;
    FDcPropertyWriter* Writer = nullptr;
};
</code></pre>
<h2 id="property-datum-and-readerwriter"><a class="header" href="#property-datum-and-readerwriter">Property Datum and Reader/Writer</a></h2>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyDatum.h">DcPropertyDatum.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyReader.h">DcPropertyReader.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyWriter.h">DcPropertyWriter.h</a></li>
</ul>
<p>Property reader/writer are usually constructed from a <code>FDcPropertyDatum</code>, which is a &quot;fat pointer&quot; that represents an entry in the property system.</p>
<pre><code class="language-c++">// DataConfigCore/Public/DataConfig/Property/DcPropertyDatum.h
struct DATACONFIGCORE_API FDcPropertyDatum
{
    FFieldVariant Property;
    void* DataPtr;
    //...
}
</code></pre>
<p>Recall that <a href="Formats/../Programming/DataModel.html">DataConfig data model</a> expands to a set of <code>Read/Write</code> calls. In the example below we setup a <code>FDcPropertyReader</code> with a simple struct and dump it out:</p>
<pre><code class="language-c++">//  DataConfigTests/Private/DcTestBlurb2.h
USTRUCT()
struct FDcTestExample2
{
    GENERATED_BODY()

    UPROPERTY() FString StrField;
    UPROPERTY() FString StrArrField[3];

    UPROPERTY() UDcBaseShape* InlineField;
    UPROPERTY() UDcTestClass1* RefField;
    // ...
};

//  DataConfigTests/Private/DcTestBlurb2.cpp
FDcTestExample2 Value;
Value.MakeFixture();

FDcPropertyDatum Datum(&amp;Value);
FDcPropertyReader Reader(Datum);
DcAutomationUtils::DumpToLog(&amp;Reader);
</code></pre>
<p>The results are like this:</p>
<pre><code>&lt;StructRoot&gt; 'DcTestExample2'
|---&lt;Name&gt; 'StrField'
|---&lt;String&gt; 'Foo'
|---&lt;Name&gt; 'StrArrField'
|---&lt;ArrayRoot&gt;
|   |---&lt;String&gt; 'One'
|   |---&lt;String&gt; 'Two'
|   |---&lt;String&gt; 'Three'
|---&lt;ArrayEnd&gt;
|---&lt;Name&gt; 'InlineField'
|---&lt;ClassRoot&gt; 'DcShapeSquare'
|   |---&lt;Name&gt; 'Radius'
|   |---&lt;Float&gt; '2.000000'
|   |---&lt;Name&gt; 'ShapeName'
|   |---&lt;Name&gt; 'MyBox'
|---&lt;ClassEnd&gt; 'DcBaseShape'
|---&lt;Name&gt; 'RefField'
|---&lt;ClassRoot&gt; 'DcTestClass1'
|   |---&lt;ObjectReference&gt; '337' 'DcTestClass1_0'
|---&lt;ClassEnd&gt; 'DcTestClass1'
&lt;StructEnd&gt; 'DcTestExample2'
</code></pre>
<p>Some caveats:</p>
<ul>
<li>
<p>Note that <code>DcTestExample2::StrArrField</code> is dumped into a array. Note that DataConfig can't distinguish between <code>Foo</code> and <code>Foo[1]</code> that's a 1 element array. It would be read as a normal field.</p>
</li>
<li>
<p>Note that <code>DcTestExample2::InlineField</code> is expanded and <code>DcTestExample2::RefField</code> is read as an reference. This is determined by <code>FDcPropertyConfig::ExpandObjectPredicate</code>, which by default expands:</p>
<ul>
<li>Field marked with <code>UPROPERTY(Instanced)</code></li>
<li>Class marked with <code>UCLASS(DefaultToInstanced, EditInlineNew)</code></li>
</ul>
</li>
</ul>
<h3 id="configuring-with-fdcpropertyconfig"><a class="header" href="#configuring-with-fdcpropertyconfig">Configuring with <code>FDcPropertyConfig</code></a></h3>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyTypes.h">DcPropertyTypes.h</a></li>
</ul>
<p>Property reader/writer accepts <code>FDcPropertyConfig</code> class for customizing behaviors. By default we've implemented <code>DcSkip</code> metadata that you can mark on <code>given reader/writer.URPOPERTY()</code> and the field would be skipped by given reader/writer:</p>
<pre><code class="language-c++">//  DataConfigTests/Private/DcTestProperty3.h
USTRUCT()
struct FDcTestMeta1
{
    GENERATED_BODY()

    UPROPERTY(meta = (DcSkip)) int SkipField1;
};
</code></pre>
<p>Though that <code>DcSkip</code> behavior is enabled by default, you can override this with a custom <code>FPropertyConfig</code> instance. Here's an example of processing only fields with <code>DcTestSerialize</code> meta:</p>
<pre><code class="language-c++">//  DataConfigTests/Private/DcTestProperty4.h
USTRUCT()
struct FDcTestSerializeMeta1
{
	GENERATED_BODY()

	UPROPERTY(meta = (DcTestSerialize)) int SerializedField;
	UPROPERTY() int IgnoredField;
};

//  DataConfigTests/Private/DcTestProperty4.cpp
FDcPropertyConfig Config;
//  only process fields that has `DcTestSerialize` meta
Config.ProcessPropertyPredicate = FDcProcessPropertyPredicateDelegate::CreateLambda([](FProperty* Property)
{
    const static FName TestSerializeMeta = FName(TEXT(&quot;DcTestSerialize&quot;));
    return DcPropertyUtils::IsEffectiveProperty(Property)
        &amp;&amp; Property-&gt;HasMetaData(TestSerializeMeta);
});
Config.ExpandObjectPredicate = FDcExpandObjectPredicateDelegate::CreateStatic(DcPropertyUtils::IsSubObjectProperty);
Ctx.Reader-&gt;SetConfig(Config);
</code></pre>
<h2 id="pipe-property-handlers"><a class="header" href="#pipe-property-handlers">Pipe Property Handlers</a></h2>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Public/DataConfig/Serialize/Handlers/Property/DcPropertyPipeSerializers.h">DcPropertyPipeSerializers.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Private/DataConfig/Serialize/Handlers/Property/DcPropertyPipeSerializers.cpp">DcPropertyPipeSerializers.cpp</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Public/DataConfig/Deserialize/Handlers/Property/DcPropertyPipeDeserializers.h">DcPropertyPipeDeserializers.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Private/DataConfig/Deserialize/Handlers/Property/DcPropertyPipeDeserializers.cpp">DcPropertyPipeDeserializers.cpp</a></li>
</ul>
<p>There's a set of deserialize handlers in <code>DcPropertyPipeHandlers</code> namespace. It's used to roundtripping property system objects.</p>
<p>Simply speaking it's equivalent to doing a <code>FDcPipeVisitor</code>  pipe visit.</p>
<pre><code class="language-c++">//  DataConfigTests/Private/DcTestBlurb.cpp
//  these two blocks are equivalent
{
    FDcPropertyReader Reader(FromDatum);
    FDcPropertyWriter Writer(ToDatum);
    FDcPipeVisitor RoundtripVisit(&amp;Reader, &amp;Writer);

    DC_TRY(RoundtripVisit.PipeVisit());
}

{
    FDcDeserializer Deserializer;
    DcSetupPropertyPipeDeserializeHandlers(Deserializer);

    FDcPropertyReader Reader(FromDatum);
    FDcPropertyWriter Writer(ToDatum);

    FDcDeserializeContext Ctx;
    Ctx.Reader = &amp;Reader;
    Ctx.Writer = &amp;Writer;
    Ctx.Deserializer = &amp;Deserializer;
    DC_TRY(Ctx.Prepare());

    DC_TRY(Deserializer.Deserialize(Ctx));
}
</code></pre>
<p>These are provided as a set of basis to for building custom property wrangling utils. See <a href="Formats/../Extra/FieldRenamer.html">Field Renamer</a> for example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extra"><a class="header" href="#extra">Extra</a></h1>
<p>Alongside <code>DataConfigCore</code> we have two other modules <code>DataConfigExtra</code> and <code>DataConfigEditorExtra</code>. It have self contained samples built on top of DataConfig framework.</p>
<p>Note that these are not intended to be integrated directly. You can take these as references when implementing custom features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fcolor-serializationdeserialization"><a class="header" href="#fcolor-serializationdeserialization">FColor Serialization/Deserialization</a></h1>
<p>This example has been shown in <a href="Extra/../Examples/Custom.html" title="Custom">previous chapter</a>. It's also a benchmark use case for our custom deserialization logic:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeColor.h">DcSerDeColor.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp">DcSerDeColor.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeColor.h
USTRUCT()
struct FDcExtraTestStructWithColor1
{
    GENERATED_BODY()

    UPROPERTY() FColor ColorField1;
    UPROPERTY() FColor ColorField2;
};

// DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
        &quot;ColorField2&quot; : &quot;#FF0000FF&quot;,
    }
)&quot;);
</code></pre>
<p><code>FColor</code> is converted into a <code>#RRGGBBAA</code> hex string. The corresponding handlers looks pretty mirrored.</p>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
FDcResult HandlerColorDeserialize(FDcDeserializeContext&amp; Ctx)
{
	FDcPropertyDatum Datum;
	DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

	FString ColorStr;
	DC_TRY(Ctx.Reader-&gt;ReadString(&amp;ColorStr));
	FColor Color = FColor::FromHex(ColorStr);

	FColor* ColorPtr = (FColor*)Datum.DataPtr;
	*ColorPtr = Color;

	return DcOk();
}

FDcResult HandlerColorSerialize(FDcSerializeContext&amp; Ctx)
{
	FDcPropertyDatum Datum;
	DC_TRY(Ctx.Reader-&gt;ReadDataEntry(FStructProperty::StaticClass(), Datum));

	FColor* ColorPtr = (FColor*)Datum.DataPtr;
	DC_TRY(Ctx.Writer-&gt;WriteString(TEXT(&quot;#&quot;) + ColorPtr-&gt;ToHex()));

	return DcOk();
}
</code></pre>
<p>Note how <code>FDcPropertyReader::ReadDataEntry</code> and <code>FDcPropertyWriter::WriteDataEntry</code> retrieves the next property as a <code>FDcPropertyDatum</code>, which allows us to directly manipulate a <code>FColor</code> pointer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base64-blob-serializationdeserialization"><a class="header" href="#base64-blob-serializationdeserialization">Base64 Blob Serialization/Deserialization</a></h1>
<p>This demonstrates conversion between<code>TArray&lt;uint8&gt;</code> and Base64 encoded strings in JSON:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeBase64.h">DcSerDeBase64.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeBase64.cpp">DcSerDeBase64.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Public/DataConfig/Extra/Deserialize/DcSerDeBase64.h
USTRUCT()
struct FDcExtraTestStructWithBase64
{
    GENERATED_BODY()

    UPROPERTY(meta = (DcExtraBase64)) TArray&lt;uint8&gt; BlobField1;
    UPROPERTY(meta = (DcExtraBase64)) TArray&lt;uint8&gt; BlobField2;
};

// DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeBase64.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;BlobField1&quot; : &quot;dGhlc2UgYXJlIG15IHR3aXN0ZWQgd29yZHM=&quot;,
        &quot;BlobField2&quot; : &quot;&quot;,
    }
)&quot;);
</code></pre>
<p>Note that we're tagging the <code>BlobField</code> with <code>(meta = (DcExtraBase64))</code> to explicitly show that we' want this member to be converted into Base64.</p>
<p>UE support <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/GameplayArchitecture/Metadata/" title="Metadata Specifiers">arbitrary meta data in the <code>meta = ()</code> segment</a>. But beware that the meta data is only available when <code>WITH_EDITORDATA</code> flag is defined. In predicate we check for this <code>DcExtraBase64</code> like this:</p>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeBase64.cpp
EDcDeserializePredicateResult PredicateIsBase64Blob(FDcDeserializeContext&amp; Ctx)
{
	FArrayProperty* ArrayProperty = DcPropertyUtils::CastFieldVariant&lt;FArrayProperty&gt;(Ctx.TopProperty());

	//	check for only TArray&lt;uint8&gt;
	if (ArrayProperty == nullptr)
		return EDcDeserializePredicateResult::Pass;
	if (!ArrayProperty-&gt;Inner-&gt;IsA&lt;FByteProperty&gt;())
		return EDcDeserializePredicateResult::Pass;

	return ArrayProperty-&gt;HasMetaData(TEXT(&quot;DcExtraBase64&quot;))
		? EDcDeserializePredicateResult::Process
		: EDcDeserializePredicateResult::Pass;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writer-api-alternatives"><a class="header" href="#writer-api-alternatives">Writer API Alternatives</a></h1>
<p>Previously we're deserializing <code>FColor</code> by writing into its member fields separately, which is a bit cumbersome. In this case DataConfig do support better alternatives.</p>
<p>Since we know that <code>FColor</code> is POD type we can construct one by filling in correct bit pattern. In this case <code>FDcPropertyWriter</code> allow struct property to be coerced from a blob:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeColor.h">DcSerDeColor.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp">DcSerDeColor.cpp</a></li>
</ul>
<pre><code class="language-c++">//  DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriteBlob&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    return Ctx.Writer-&gt;WriteBlob({
        (uint8*)&amp;Color, // treat `Color` as opaque blob data
        sizeof(FColor)
    });
}
</code></pre>
<p>Alternatively we can get <code>FProperty</code> and data pointer in place and setting the value through Unreal's <code>FProperty</code> API:</p>
<pre><code class="language-c++">//  DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriteDataEntry&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    FDcPropertyDatum Datum;
    DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

    Datum.CastFieldChecked&lt;FStructProperty&gt;()-&gt;CopySingleValue(Datum.DataPtr, &amp;Color);
    return DcOk();
}
</code></pre>
<p>Note that we already know that <code>Datum.DataPtr</code> points to a allocated <code>FColor</code> instance. Thus we can simply cast it into a <code>FColor*</code> and directly manipulate the pointer.</p>
<pre><code class="language-c++">//  DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WritePointer&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    FDcPropertyDatum Datum;
    DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

    FColor* ColorPtr = (FColor*)Datum.DataPtr;
    *ColorPtr = Color;  // deserialize by assignment

    return DcOk();
}
</code></pre>
<p>Note that these techniques also applies on serialization:</p>
<pre><code class="language-c++">//  DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
FDcResult HandlerColorSerialize(FDcSerializeContext&amp; Ctx)
{
    FDcPropertyDatum Datum;
    DC_TRY(Ctx.Reader-&gt;ReadDataEntry(FStructProperty::StaticClass(), Datum));

    FColor* ColorPtr = (FColor*)Datum.DataPtr;
    DC_TRY(Ctx.Writer-&gt;WriteString(TEXT(&quot;#&quot;) + ColorPtr-&gt;ToHex()));

    return DcOk();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsonconverter-in-dataconfig"><a class="header" href="#jsonconverter-in-dataconfig">JsonConverter in DataConfig</a></h1>
<p>UE comes with a handy module <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/JsonUtilities/"><code>JsonUtilities</code></a> that handles conversion between <code>USTRUCT</code>s and JSON. In this example we've implemented similar functionalities that behaves almost identical to stock <code>FJsonConverter</code>.</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Types/DcJsonConverter.h">DcJsonConverter.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcJsonConverter.cpp">DcJsonConverter.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/Types/DcJsonConverter.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;strField&quot; : &quot;Foo&quot;,
        &quot;nestField&quot; : {
            &quot;strArrayField&quot; : [
                &quot;One&quot;,
                &quot;Two&quot;,
                &quot;Three&quot;
            ],
            &quot;strIntMapField&quot; : {
                &quot;One&quot;: 1,
                &quot;Two&quot;: 2,
                &quot;Three&quot;: 3
            }
        },
        &quot;intField&quot; : 253,
        &quot;boolField&quot; : true
    }
)&quot;);

{
	FDcTestJsonConverter1 Lhs;
	bool LhsOk = DcExtra::JsonObjectStringToUStruct(Str, &amp;Lhs);

    FDcTestJsonConverter1 Rhs;
	bool RhsOk = FJsonObjectConverter::JsonObjectStringToUStruct(Str, &amp;Rhs);
}    
{
	FString Lhs;
	bool LhsOk = DcExtra::UStructToJsonObjectString(Data, Lhs);

	FString Rhs;
	bool RhsOk = FJsonObjectConverter::UStructToJsonObjectString(Data, Rhs);
}
</code></pre>
<p><code>DcExtra::JsonObjectStringToUStruct()</code> body is trivia as it delegates most of the work to <code>DcDeserializer</code>:</p>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/Types/DcJsonConverter.cpp
bool JsonObjectReaderToUStruct(FDcReader* Reader, FDcPropertyDatum Datum)
{
	FDcResult Ret = [&amp;]() -&gt; FDcResult {
		using namespace JsonConverterDetails;
		LazyInitializeDeserializer();

		FDcPropertyWriter Writer(Datum);

		FDcDeserializeContext Ctx;
		Ctx.Reader = Reader;
		Ctx.Writer = &amp;Writer;
		Ctx.Deserializer = &amp;Deserializer.GetValue();
		DC_TRY(Ctx.Prepare());

		DC_TRY(Deserializer-&gt;Deserialize(Ctx));
		return DcOk();
	}();

	if (!Ret.Ok())
	{
		DcEnv().FlushDiags();
		return false;
	}
	else
	{
		return true;
	}
}
</code></pre>
<p>The serializing function <code>DcExtra::UStructToJsonObjectString()</code> needs some customization as default <code>DcJsonWriter</code> and <code>DcSerializer</code> handlers behaves a bit different against stock <code>FDcJsonConverter</code>:</p>
<ul>
<li>It serialize field names as <code>camelCase</code>.</li>
<li>It uses platform dependent line endings, that is <code>\r\n</code> on Windows.</li>
<li>It have subtle new line breaking rules on nested array and object, and on spacing around <code>:</code> token.</li>
</ul>
<p>The good news is that one can customize these behaviors with DataConfig to match it:</p>
<pre><code class="language-c++">// DataConfigExtra/Public/DataConfig/Extra/Types/DcJsonConverter.h
template&lt;typename InStructType&gt;
static bool UStructToJsonObjectString(const InStructType&amp; InStruct, FString&amp; OutJsonString)
{
    static FDcJsonWriter::ConfigType _JSON_CONVERTER_CONFIG = []
	{
		FDcJsonWriter::ConfigType Config = FDcJsonWriter::DefaultConfig;
		Config.IndentLiteral = TEXT(&quot;\t&quot;);
		Config.LineEndLiteral = LINE_TERMINATOR;
		Config.LeftSpacingLiteral = TEXT(&quot;&quot;);
		Config.bNestedArrayStartsOnNewLine = false;
		Config.bNestedObjectStartsOnNewLine = true;
		return Config;
	}();

	FDcJsonWriter Writer(_JSON_CONVERTER_CONFIG);
    ...
}

// DataConfigExtra/Private/DataConfig/Extra/Types/DcJsonConverter.cpp
static FDcResult HandlerStructRootSerializeCamelCase(FDcSerializeContext&amp; Ctx)
{
    ...
	else if (CurPeek == EDcDataEntry::Name)
	{
		FName Value;
		DC_TRY(Ctx.Reader-&gt;ReadName(&amp;Value));
		DC_TRY(Ctx.Writer-&gt;WriteString(FJsonObjectConverter::StandardizeCase(Value.ToString())));
    }
}
</code></pre>
<p>We aim to support flexible serialization and formatting behaviors without modifying <code>DataConfigCore</code> code:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anystruct"><a class="header" href="#anystruct">AnyStruct</a></h1>
<p>This is an intermediate example that takes advantage of the flexibility provided by the property system. <code>FDcAnyStruct</code> is a struct that stores a heap allocated <code>USTRUCT</code> of any type while maintaining value semantic on itself. If you're familiar with the concept of variant type, just think of it as a variant type that supports all <code>USTRUCT</code>:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Types/DcAnyStruct.h">DcAnyStruct.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcAnyStruct.cpp">DcAnyStruct.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeAnyStruct.cpp
//  instantiate from heap allocated structs
FDcAnyStruct Any1 = new FDcExtraTestSimpleStruct1();
Any1.GetChecked&lt;FDcExtraTestSimpleStruct1&gt;()-&gt;NameField = TEXT(&quot;Foo&quot;);

//  supports moving
FDcAnyStruct Any2 = MoveTemp(Any1);
check(!Any1.IsValid());
check(Any2.GetChecked&lt;FDcExtraTestSimpleStruct1&gt;()-&gt;NameField == TEXT(&quot;Foo&quot;));
Any2.Reset();

//  supports shared referencing
Any2 = new FDcExtraTestSimpleStruct2();
Any2.GetChecked&lt;FDcExtraTestSimpleStruct2&gt;()-&gt;StrField = TEXT(&quot;Bar&quot;);

Any1 = Any2;

check(Any1.DataPtr == Any2.DataPtr);
check(Any1.StructClass == Any2.StructClass);
</code></pre>
<p>We then implemented conversion logic between <code>FDcAnyStruct</code> and JSON:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeAnyStruct.h">DcSerDeAnyStruct.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeAnyStruct.cpp">DcSerDeAnyStruct.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeAnyStruct.h
USTRUCT()
struct FDcExtraTestWithAnyStruct1
{
    GENERATED_BODY()

    UPROPERTY() FDcAnyStruct AnyStructField1;
    UPROPERTY() FDcAnyStruct AnyStructField2;
    UPROPERTY() FDcAnyStruct AnyStructField3;
};

// DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeAnyStruct.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;AnyStructField1&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestSimpleStruct1&quot;,
            &quot;NameField&quot; : &quot;Foo&quot;
        },
        &quot;AnyStructField2&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestStructWithColor1&quot;,
            &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
            &quot;ColorField2&quot; : &quot;#FF0000FF&quot;
        },
        &quot;AnyStructField3&quot; : null
    }
)&quot;);
</code></pre>
<p>Note how the custom <code>FColor &lt;-&gt; &quot;#RRGGBBAA&quot;</code> conversion recursively works within <code>FDcAnyStruct</code>. This should be a good starting point for you to implement your own nested variant types and containers. For more details refer to the implementation of <code>HandlerDcAnyStruct[Serialize/Deserialize]</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-struct"><a class="header" href="#inline-struct">Inline Struct</a></h1>
<p>In <a href="Extra/AnyStruct.html">AnyStruct</a> we implemented <code>FDcAnyStruct</code> that can store arbitrary heap allocated <code>USTRUCT</code>. A shortcoming of this approach is that it introduces overhead of heap allocated memory, which also have worse cache locality comparing to stack allocated structs.</p>
<p>In this example we implemented a series of structs <code>FDcInlineStruct64/FDcInlineStruct128/FDcInlineStruct256/FDcInlineStruct512</code> which stores a USTRUCT inline. Think it as a small buffer optimized version of <code>FDcAnyStruct</code>. These can also be used as a cheap alternative to UCLASS based polymorphism.</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Types/DcInlineStruct.h">DcInlineStruct.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcInlineStruct.cpp">DcInlineStruct.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeInlineStruct.cpp
//  stack allocated usage
FDcInlineStruct64 Inline1;
Inline1.Emplace&lt;FColor&gt;(255, 0, 0, 255);
UTEST_TRUE(&quot;Inline Struct&quot;, *Inline1.GetChecked&lt;FColor&gt;() == FColor::Red);

//  support copy 
FDcInlineStruct64 Inline2 = Inline1;
UTEST_TRUE(&quot;Inline Struct&quot;, *Inline2.GetChecked&lt;FColor&gt;() == FColor::Red);
</code></pre>
<p>Serialization handlers for inline structs are similar to any struct ones:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeInlineStruct.h">DcSerDeInlineStruct.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeInlineStruct.cpp">DcSerDeInlineStruct.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeInlineStruct.h
USTRUCT()
struct FDcExtraTestWithInlineStruct1
{
    GENERATED_BODY()

    UPROPERTY() FDcInlineStruct64 InlineField1;
    UPROPERTY() FDcInlineStruct64 InlineField2;;
};

// DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeInlineStruct.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;InlineField1&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestSimpleStruct1&quot;,
            &quot;NameField&quot; : &quot;Foo&quot;
        },
        &quot;InlineField2&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestStructWithColor1&quot;,
            &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
            &quot;ColorField2&quot; : &quot;#FF0000FF&quot;
        }
    }
)&quot;);
</code></pre>
<p>Note that one limitation with inline structs the USTRUCT get put in must have smaller size than the inline struct storage. Deserialize handlers would check for these cases:</p>
<pre><code>LogDataConfigCore: Display: # DataConfig Error: Inline struct too big: BufSize '56', Struct 'DcExtraTestStruct128' Size '128'
LogDataConfigCore: Display: - [WideCharDcJsonReader] --&gt; &lt;in-memory&gt;5:38
   3 |        {
   4 |            &quot;InlineField1&quot; : {
   5 |                &quot;$type&quot; : &quot;DcExtraTestStruct128&quot;,
     |                                                ^
   6 |                &quot;NameField&quot; : &quot;Foo&quot;
   7 |            },
LogDataConfigCore: Display: - [DcPropertyWriter] Writing property: (FDcExtraTestWithInlineStruct1)$root.(FDcInlineStruct64)InlineField1
LogDataConfigCore: Display: - [DcSerializer]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-renamer"><a class="header" href="#field-renamer">Field Renamer</a></h1>
<p>DataConfig can also be used to author one-off utility. In this example we implemented <code>DcExtra::DeserializeStructRenaming()</code> that copies data between structural identical data structures, while renaming field names by a user function.</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Deserialize/DcDeserializeRenameStructFieldNames.h">DcDeserializeRenameStructFieldNames.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeRenameStructFieldNames.cpp">DcDeserializeRenameStructFieldNames.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeRenameStructFieldNames.cpp
//  struct equivelent to this:
FString Str = TEXT(R&quot;(
    {
        &quot;FromName1&quot; : &quot;Foo&quot;,
        &quot;FromStructSet1&quot; : 
        [
            {
                &quot;FromStr1&quot; : &quot;One&quot;,
                &quot;FromInt1&quot; : 1,
            },
            {
                &quot;FromStr1&quot; : &quot;Two&quot;,
                &quot;FromInt1&quot; : 2,
            }
        ]
    }
)&quot;);

// ... deserialize with a functor renaming `FromXXX` to `ToXXX`:
UTEST_OK(&quot;...&quot;, DcExtra::DeserializeStructRenaming(
    FromDatum, ToDatum, FDcExtraRenamer::CreateLambda([](const FName&amp; FromName){
    FString FromStr = FromName.ToString();
    if (FromStr.StartsWith(TEXT(&quot;From&quot;)))
        return FName(TEXT(&quot;To&quot;) + FromStr.Mid(4));
    else
        return FromName;
})));

// ... results into a struct equivelent to this: 
FString Str = TEXT(R&quot;(
    {
        &quot;ToName1&quot; : &quot;Foo&quot;,
        &quot;ToStructSet1&quot; : 
        [
            {
                &quot;ToStr1&quot; : &quot;One&quot;,
                &quot;ToInt1&quot; : 1,
            },
            {
                &quot;ToStr1&quot; : &quot;Two&quot;,
                &quot;ToInt1&quot; : 2,
            }
        ]
    }
)&quot;);
</code></pre>
<p>This takes advantage of the <code>DcPropertyPipeHandlers</code> that simply do verbatim data piping. </p>
<p>The gist is that you should consider DataConfig an option when working with batch data processing within Unreal Engine. We are trying to provide tools to support these use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-property-by-path"><a class="header" href="#access-property-by-path">Access property by path</a></h1>
<p>This example demonstrates that <code>FReader/FWriter</code> can be used standalone, without <code>FDcSerializer/FDcDeserializer</code>.</p>
<p>UE built-in module <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/PropertyPath" title="PropertyPath"><code>PropertyPath</code></a> allow accessing nested object properties by a path like <code>Foo.Bar.Baz</code>:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Types/DcPropertyPathAccess.h">DcPropertyPathAccess.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcPropertyPathAccess.cpp">DcPropertyPathAccess.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/Types/DcPropertyPathAccess.cpp
FString Str;
UTEST_TRUE(&quot;...&quot;, PropertyPathHelpers::GetPropertyValue(Outer, TEXT(&quot;StructRoot.Middle.InnerMost.StrField&quot;), Str));
UTEST_TRUE(&quot;...&quot;, Str == TEXT(&quot;Foo&quot;));

UTEST_TRUE(&quot;...&quot;, PropertyPathHelpers::SetPropertyValue(Outer, TEXT(&quot;StructRoot.Middle.InnerMost.StrField&quot;), FString(TEXT(&quot;Bar&quot;))));
UTEST_TRUE(&quot;...&quot;, Outer-&gt;StructRoot.Middle.InnerMost.StrField == TEXT(&quot;Bar&quot;));
</code></pre>
<p>We implemented a pair of methods <code>DcExtra::GetDatumPropertyByPath/SetDatumPropertyByPath</code> with <code>FDcPropertyReader</code>:</p>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/Extra/Types/DcPropertyPathAccess.cpp
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Middle.InnerMost.StrField&quot;), TEXT(&quot;Foo&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.0.StrField&quot;), TEXT(&quot;Bar0&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.1.StrField&quot;), TEXT(&quot;Bar1&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.NameMap.FooKey.StrField&quot;), TEXT(&quot;FooValue&quot;)));

UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Middle.InnerMost.StrField&quot;, TEXT(&quot;AltFoo&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.0.StrField&quot;, TEXT(&quot;AltBar0&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.1.StrField&quot;, TEXT(&quot;AltBar1&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.NameMap.FooKey.StrField&quot;, TEXT(&quot;AltFooValue&quot;)));
</code></pre>
<p>Comparing to <code>PropertyPathHelpers</code> these new ones support <code>Array</code> and <code>Map</code>, and support <code>USTRUCT</code> roots. We're missing some features like expanding weak/lazy object references but it should be easy to implement.</p>
<p>Remember that we have bundled JSON/MsgPack reader/writers that can also be used standalone.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deserialize-from-sqlite-query"><a class="header" href="#deserialize-from-sqlite-query">Deserialize From SQLite Query</a></h1>
<p>Unreal Engine bundles SQLite3 in SQLiteCore plugin and bundled with minimal C++ abstractions. In this example we implemented <code>LoadStructArrayFromSQLite</code> to load a SQLite query into a <code>TArray</code> of structs:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Misc/DcSqlite.h">DcSqlite.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Misc/DcSqlite.cpp">DcSqlite.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Public/DataConfig/Extra/Misc/DcSqlite.h
template&lt;typename TStruct&gt;
FDcResult LoadStructArrayFromSQLite(FSQLiteDatabase* Db, const TCHAR* Query, TArray&lt;TStruct&gt;&amp; Arr)
// ...
</code></pre>
<p>With this method we can easily turn SQLite query results into structs that's easy to manipulate with:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Misc/DcSqlite.cpp
/// data fixture
FString Statement = TEXT(&quot;CREATE TABLE users (id INTEGER NOT NULL,name TEXT, title TEXT)&quot;);
bSuccess &amp;= TestDb.Execute(*Statement);
Statement = TEXT(&quot;INSERT INTO users (id, name, title) VALUES (1, 'John', 'Manager')&quot;);
bSuccess &amp;= TestDb.Execute(*Statement);
Statement = TEXT(&quot;INSERT INTO users (id, name, title) VALUES (2, 'Mark', 'Engineer')&quot;);
bSuccess &amp;= TestDb.Execute(*Statement);
Statement = TEXT(&quot;INSERT INTO users (id, name, title) VALUES (3, 'Bob', 'Engineer')&quot;);
bSuccess &amp;= TestDb.Execute(*Statement);
Statement = TEXT(&quot;INSERT INTO users (id, name, title) VALUES (4, 'Mike', 'QA')&quot;);

//  execute query and deserialize
TArray&lt;FDcExtraTestUser&gt; Arr;
UTEST_OK(&quot;Extra Sqlite&quot;, DcExtra::LoadStructArrayFromSQLite(
    &amp;TestDb,
    TEXT(&quot;SELECT * FROM users WHERE title == 'Engineer' ORDER BY id&quot;),
    Arr
    ));

//  equivalent fixture
FString Fixture = TEXT(R&quot;(
    [
        {
            &quot;Id&quot; : 2,
            &quot;Name&quot; : &quot;Mark&quot;,
            &quot;Title&quot; : &quot;Engineer&quot;
        },
        {
            &quot;Id&quot; : 3,
            &quot;Name&quot; : &quot;Bob&quot;,
            &quot;Title&quot; : &quot;Engineer&quot;
        }
    ]
)&quot;);
</code></pre>
<p>For this to work we'll need to implement <code>FSqliteReader</code> which implements <code>FDcReader</code> API so it can be consumed by deserializer. The cool thing is that <code>FSqliteReader</code> works very well with SQLite's step API and can wrap SQLite error reporting into diagnostics that DataConfig can report.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extra-module-setups"><a class="header" href="#extra-module-setups">Extra Module Setups</a></h1>
<p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Modules/" title="								Unreal Engine Modules 						">Unreal Engine Modules</a> is how the engine handles its C++ code physical design. You'll need to be pretty familiar with the system to scale up your C++ project.</p>
<p>We split extra samples in two modules. The first is <code>DataConfigExtra</code> which does <strong>not</strong> depend on <code>Engine/UnrealEd</code> module. It can be built along program target. <code>DataConfigExtra</code> is basically a set of C++ source files bundled and there's no special setup for it. The key setup is to set <code>ModuleRules.bRequiresImplementModule</code> to be <code>false</code>:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/DataConfigExtra.Build.cs">DataConfigExtra.Build.cs</a></li>
</ul>
<pre><code class="language-c#">// DataConfigExtra/DataConfigExtra.Build.cs
public class DataConfigExtra : ModuleRules
{
	public DataConfigExtra(ReadOnlyTargetRules Target) : base(Target)
	{
	    bRequiresImplementModule = false;
	    Type = ModuleType.CPlusPlus;
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
		PublicDependencyModuleNames.AddRange(
			new string[] {
			&quot;DataConfigCore&quot;,
			&quot;Core&quot;,
			&quot;CoreUObject&quot;,
             // ...
			});
	}
}
</code></pre>
<p>The other module is <code>DcEditorExtraModule</code>, a more conventional editor only module. It's also the recommended setup for integrating DataConfig as an editor only dependency into your project. We also put samples that depends on <code>Engine</code> and other gameplay system in here.</p>
<p>Most of integration code is in <code>IModuleInterface::StartUpModule/ShutdownModule()</code>. </p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra/Private/DcEditorExtraModule.cpp">DcEditorExtraModule.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigEditorExtra/Private/DcEditorExtraModule.cpp
void FDcEditorExtraModule::StartupModule()
{
    // ...
	DcRegisterDiagnosticGroup(&amp;DcDExtra::Details);
	DcRegisterDiagnosticGroup(&amp;DcDEditorExtra::Details);

	DcStartUp(EDcInitializeAction::Minimal);
	DcEnv().DiagConsumer = MakeShareable(new FDcMessageLogDiagnosticConsumer());
	// ...
}

void FDcEditorExtraModule::ShutdownModule()
{
	DcShutDown();
    // ...
}

</code></pre>
<p>Here's a checklist for integration:</p>
<ul>
<li>Register additional diagnostics early. </li>
<li>Call <code>DcStartUp()/DcShutDonw()</code> pair.</li>
<li>Register custom diagnostic consumer.</li>
</ul>
<p><code>FDcMessageLogDiagnosticConsumer</code> is an example of redirecting diagnostics to the UE Message Log window with its own category.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dump-asset-to-log"><a class="header" href="#dump-asset-to-log">Dump Asset To Log</a></h1>
<p>In this example we added a <code>Dump Asset To Log</code> menu entry. After enabling it you can see it on the context menu on all asset types:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-DumpAssetToLog.png" alt="DataConfigEditorExtra-DumpAssetToLog" /></p>
<p>On clicking it would use the pretty print writer to dump the asset into Output Log:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-DumpOutputLog.png" alt="DataConfigEditorExtra-DumpOutputLog" /></p>
<p>This is implemented as an editor menu extender:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/EditorExtra/Editor/DcEditorDumpAssetToLog.cpp">DcEditorDumpAssetToLog.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra/Private/DataConfig/EditorExtra/Editor/DcEditorDumpAssetToLog.cpp
TSharedRef&lt;FExtender&gt; DumpAssetToLogExtender(const TArray&lt;FAssetData&gt;&amp; SelectedAssets)
{
    // ...
    Extender-&gt;AddMenuExtension(&quot;GetAssetActions&quot;, EExtensionHook::After, TSharedPtr&lt;FUICommandList&gt;(),
        FMenuExtensionDelegate::CreateLambda([Asset](FMenuBuilder&amp; MenuBuilder)
        {
        MenuBuilder.AddMenuEntry(
        // ...
        FUIAction(
            FExecuteAction::CreateLambda([Asset]{
                if (UBlueprint* Blueprint = Cast&lt;UBlueprint&gt;(Asset.GetAsset()))
                {
                    //  dump BP class generated class CDO as it makes more sense
                    DcAutomationUtils::DumpToLog(FDcPropertyDatum(Blueprint-&gt;GeneratedClass-&gt;ClassDefaultObject));
                }
                else
                {
                    DcAutomationUtils::DumpToLog(FDcPropertyDatum(Asset.GetAsset()));
                }
                }),
                FCanExecuteAction()
            )
        );
        }));
    }
    // ...
</code></pre>
<p>When asset is a Blueprint we dump its CDO instead as it makes more sense.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprint-serializationdeserialization"><a class="header" href="#blueprint-serializationdeserialization">Blueprint Serialization/Deserialization</a></h1>
<p>The Property System is so powerful that you can create new Blueprint Class/Struct, which is equivalent to C++ <code>UCLASS/USTRUCT</code> to some extents. In this example we'll show how to handle these in DataConfig. </p>
<p>The whole blueprint stuff depends on <code>Engine</code> module. This is also why we put related code into <code>DataConfigEditorExtra</code> module.</p>
<h2 id="blueprint-class-and-object-references"><a class="header" href="#blueprint-class-and-object-references">Blueprint Class and Object references</a></h2>
<p>Blueprint class are stored within <code>UBlueprint</code> typed assets. Note that we automatically unwrap the container in handlers.</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra/Public/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.h">DcSerDeBlueprint.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.cpp">DcSerDeBlueprint.cpp</a></li>
</ul>
<pre><code class="language-c++">//DataConfigEditorExtra/Public/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.h
USTRUCT()
struct DATACONFIGEDITOREXTRA_API FDcEditorExtraTestStructWithBPClass
{
    GENERATED_BODY()

    UPROPERTY() TSubclassOf&lt;UDcTestBPClassBase&gt; ClassField1;
    UPROPERTY() TSubclassOf&lt;UDcTestBPClassBase&gt; ClassField2;
    UPROPERTY() TSubclassOf&lt;UDcTestBPClassBase&gt; ClassField3;
};

USTRUCT()
struct DATACONFIGEDITOREXTRA_API FDcEditorExtraTestStructWithBPInstance
{
    GENERATED_BODY()

    UPROPERTY() UDcTestBPClassBase* InstanceField1;
    UPROPERTY() UDcTestBPClassBase* InstanceField2;
    UPROPERTY() UDcTestBPClassBase* InstanceField3;
};

//DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ClassField1&quot; : null,
        &quot;ClassField2&quot; : &quot;DcTestNativeDerived1&quot;,
        &quot;ClassField3&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintClassBeta&quot;
    }
)&quot;);

FString Str = TEXT(R&quot;(
    {
        &quot;InstanceField1&quot; : null,
        &quot;InstanceField2&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintInstanceAlpha&quot;,
        &quot;InstanceField3&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintInstanceBeta&quot;
    }
)&quot;);
</code></pre>
<h2 id="blueprint-class-instance"><a class="header" href="#blueprint-class-instance">Blueprint Class Instance</a></h2>
<p>In this example we roundtrip a Blueprint class instance from JSON:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-BlueprintClass.png" alt="Blueprint Class" /></p>
<pre><code class="language-c++">//DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StrField&quot; : &quot;Foo&quot;,
        &quot;BPEnumField&quot; : &quot;Baz&quot;,
        &quot;IntField&quot; : 345
    }
)&quot;);
</code></pre>
<p>You can also reference on how to handle Blueprint enum in this example. It need some special care to convert between int value and the descriptive text set within the editor.</p>
<h2 id="blueprint-struct-instance"><a class="header" href="#blueprint-struct-instance">Blueprint Struct Instance</a></h2>
<p>Finally we're combined <code>FColor</code>, <code>FDcAnyStruct</code> and Blueprint struct into one single example:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-BlueprintStruct.png" alt="DataConfigEditorExtra-BlueprintStruct" /></p>
<pre><code class="language-c++">//DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;AnyStructField1&quot; : {
            &quot;$type&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintStructWithColor&quot;,
            &quot;NameField&quot; : &quot;Foo&quot;,
            &quot;StrField&quot; : &quot;Bar&quot;,
            &quot;IntField&quot; : 123,
            &quot;ColorField&quot; : &quot;#FF0000FF&quot;
        }
    }
)&quot;);
</code></pre>
<p>Under the hood Blueprint struct mangles its field names. The struct above dumps to something like this:</p>
<pre><code>-----------------------------------------
# Datum: 'UserDefinedStruct', 'DcTestBlueprintStructWithColor'
&lt;StructRoot&gt; 'DcTestBlueprintStructWithColor'
|---&lt;Name&gt; 'NameField_5_97BFF114405C1934C2F33E8668BF1652'
|---&lt;Name&gt; 'Foo'
|---&lt;Name&gt; 'StrField_9_FAA71EFE4896F4E6B1478B9C13B2CE52'
|---&lt;String&gt; 'Bar'
|---&lt;Name&gt; 'IntField_11_3BC7CB0F42439CE2196F7AA82A1AC374'
|---&lt;Int32&gt; '123'
|---&lt;Name&gt; 'ColorField_14_F676BCF245B2977B678B65A8216E94EB'
|---&lt;StructRoot&gt; 'Color'
|   |---&lt;Name&gt; 'B'
|   |---&lt;UInt8&gt; '0'
|   |---&lt;Name&gt; 'G'
|   |---&lt;UInt8&gt; '0'
|   |---&lt;Name&gt; 'R'
|   |---&lt;UInt8&gt; '255'
|   |---&lt;Name&gt; 'A'
|   |---&lt;UInt8&gt; '255'
|---&lt;StructEnd&gt; 'Color'
&lt;StructEnd&gt; 'DcTestBlueprintStructWithColor'
-----------------------------------------
</code></pre>
<p>The good news is that DataConfig already got this covered. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gameplay-tag-serializationdeserialization"><a class="header" href="#gameplay-tag-serializationdeserialization">Gameplay Tag Serialization/Deserialization</a></h1>
<p><a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Tags/index.html" title="Gameplay Tags">GameplayTags</a> is a built-in runtime module that implements hierarchical tags. </p>
<p>In this example we have roundtrip handlers for <code>FGameplayTag</code> and <code>FGameplayTagContainer</code>.</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra/Public/DataConfig/EditorExtra/SerDe/DcSerDeGameplayTags.h">DcSerDeGameplayTags.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeGameplayTags.cpp">DcSerDeGameplayTags.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigEditorExtra/Public/DataConfig/EditorExtra/SerDe/DcSerDeGameplayTags.h
USTRUCT()
struct FDcEditorExtraTestStructWithGameplayTag1
{
    GENERATED_BODY()

    UPROPERTY() FGameplayTag TagField1;
    UPROPERTY() FGameplayTag TagField2;
};

// DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeGameplayTags.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;TagField1&quot; : null,
        &quot;TagField2&quot; : &quot;DataConfig.Foo.Bar&quot;
    }
)&quot;);
</code></pre>
<p><code>FGameplayTagContainer</code> converts to a list of strings:</p>
<pre><code class="language-c++">// DataConfigEditorExtra/Public/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.h
USTRUCT()
struct FDcEditorExtraTestStructWithGameplayTag2
{
    GENERATED_BODY()

    UPROPERTY() FGameplayTagContainer TagContainerField1;
    UPROPERTY() FGameplayTagContainer TagContainerField2;
};

// DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;TagContainerField1&quot; : [],
        &quot;TagContainerField2&quot; : [
            &quot;DataConfig.Foo.Bar&quot;,
            &quot;DataConfig.Foo.Bar.Baz&quot;,
            &quot;DataConfig.Tar.Taz&quot;,
        ]
    }
)&quot;);
</code></pre>
<p>Note that gameplay tag parsing has error reporting built-in. In this case we can pipe it into our diagnostic:</p>
<pre><code class="language-c++">// DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.cpp
static FDcResult _StringToGameplayTag(FDcDeserializeContext&amp; Ctx, const FString&amp; Str, FGameplayTag* OutTagPtr)
{
    FString FixedString;
    FText Err;
    if (!FGameplayTag::IsValidGameplayTagString(Str, &amp;Err, &amp;FixedString))
    {
        return DC_FAIL(DcDEditorExtra, InvalidGameplayTagStringFixErr)
            &lt;&lt; Str &lt;&lt; FixedString &lt;&lt; Err;
    }
    //...
}
</code></pre>
<p>In case of a invalid tag it would report the reason and fixed string:</p>
<pre><code># DataConfig Error: Invalid Gameplay Tag String, Actual: 'DataConfig.Invalid.Tag.', Fixed: 'DataConfig.Invalid.Tag', Error: 'Tag ends with .'
- [JsonReader] --&gt; &lt;in-memory&gt;5:4
   3 |        { 
   4 |            &quot;TagField1&quot; : null, 
   5 |            &quot;TagField2&quot; : &quot;DataConfig.Invalid.Tag.&quot; 
     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^
   6 |        } 
   7 |    
- [PropertyWriter] Writing property: (FDcEditorExtraTestStructWithGameplayTag1)$root.(FGameplayTag)TagField2
 [C:\DevUE\UnrealEngine\Engine\Source\Developer\MessageLog\Private\Model\MessageLogListingModel.cpp(73)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deserialize-gameplay-abilities"><a class="header" href="#deserialize-gameplay-abilities">Deserialize Gameplay Abilities</a></h1>
<p>We'll conclude with a concrete user story: populating <code>GameplayAbility</code> and <code>GameplayEffect</code> blueprint from JSON file.</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra/Public/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayAbility.h">DcDeserializeGameplayAbility.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayAbility.cpp">DcDeserializeGameplayAbility.cpp</a></li>
</ul>
<p><a href="https://docs.unrealengine.com/en-US/InteractiveExperiences/GameplayAbilitySystem/index.html" title="Gameplay Ability System">Gameplay Ability System</a> is a built-in plugin for building data driven abilities. Users are expected to derived and modify <code>GameplayAbility</code> and <code>GameplayEffect</code> blueprint for custom logic. </p>
<p>Given a JSON like this:</p>
<pre><code class="language-c++">// DataConfig/Tests/Fixture_AbilityAlpha.json
{
    /// Tags
    &quot;AbilityTags&quot; : [
        &quot;DataConfig.Foo.Bar&quot;,
        &quot;DataConfig.Foo.Bar.Baz&quot;,
    ],
    &quot;CancelAbilitiesWithTag&quot; : [
        &quot;DataConfig.Foo.Bar.Baz&quot;,
        &quot;DataConfig.Tar.Taz&quot;,
    ],
    /// Costs
    &quot;CostGameplayEffectClass&quot; : &quot;/DataConfig/DcFixture/DcTestGameplayEffectAlpha&quot;,
    /// Advanced
    &quot;ReplicationPolicy&quot; : &quot;ReplicateYes&quot;,
    &quot;InstancingPolicy&quot; : &quot;NonInstanced&quot;,
}
</code></pre>
<p>Right click on a <code>GameplayAbility</code> blueprint asset and select <code>Load From JSON</code> then select this file and confirm. It would correctly populate the fields with the values in JSON, as seen in the pic below:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-LoadJsonIntoAbility.png" alt="DataConfigEditorExtra-LoadJsonIntoAbility" /></p>
<p>Most of the logic is in <code>DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayAbility.cpp</code>:</p>
<ul>
<li>The context menu is added from <code>GameplayAbilityEffectExtender</code>. There's another handy item named <code>Dump To Log</code> which dumps any blueprint CDO into the log.</li>
<li>DataConfig deserializer is setup in <code>LazyInitializeDeserializer()</code>. We added custom logic for deserializing <code>FGameplayAttribute</code> from a string like <code>DcTestAttributeSet.Mana</code>.</li>
<li>We also reused many methods from previous examples to support <code>FGameplayTag</code> deserialization and Blueprint class look up by path.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instancedstruct"><a class="header" href="#instancedstruct">InstancedStruct</a></h1>
<p><strong>This example only works with UE5.0+</strong></p>
<p>Starting with UE 5.0 there's a new plugin <a href="https://docs.unrealengine.com/5.0/en-US/API/Plugins/StructUtils/">StructUtils</a> featuring a struct type called <a href="https://docs.unrealengine.com/5.0/en-US/API/Plugins/StructUtils/FInstancedStruct/">FInstancedStruct</a>. It's shares the same idea to previous <a href="Extra/./AnyStruct.html">AnyStruct</a> example, while it has proper asset serialization logic and editor support.</p>
<p>Given a struct hierarchy like this:</p>
<pre><code class="language-c++">// DataConfigExtra/Public/DataConfig/Extra/Types/DcExtraTestFixtures.h
USTRUCT(BlueprintType)
struct FDcStructShapeBase
{
    GENERATED_BODY()
    
    UPROPERTY(EditAnywhere) FName ShapeName;
};

USTRUCT(BlueprintType)
struct FDcStructShapeRectangle : public FDcStructShapeBase
{
    GENERATED_BODY()
    
    UPROPERTY(EditAnywhere) float Height;
    UPROPERTY(EditAnywhere) float Width;
};

USTRUCT(BlueprintType)
struct FDcStructShapeCircle : public FDcStructShapeBase
{
    GENERATED_BODY()
    
    UPROPERTY(EditAnywhere) float Radius;
};
</code></pre>
<p>You can use <code>FInstancedStruct</code> specified with a <code>BaseStruct</code> meta to reference to a polymorphism instance:</p>
<pre><code class="language-c++">// DataConfigEditorExtra5/Public/DataConfig/EditorExtra/SerDe/DcSerDeInstancedStruct.h
UPROPERTY(EditAnywhere, meta = (BaseStruct = &quot;/Script/DataConfigExtra.DcStructShapeBase&quot;))
FInstancedStruct InstancedStruct1;

UPROPERTY(EditAnywhere, meta = (BaseStruct = &quot;DcStructShapeBase&quot;))
FInstancedStruct InstancedStruct2;
</code></pre>
<p>The best part is that the editor is also working as intended:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-InstancedStructEditor.png" alt="DataConfigEditorExtra-InstancedStructEditor" /></p>
<p>Prior to this you'll need to setup <a href="Extra/../Formats/JSON.html#sub-objects">Sub Objects</a> for similar behavior, which costs unnecessary overhead.</p>
<p><code>FInstancedStruct</code> can also be serialized to and from JSON with DataConfig:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra5/Public/DataConfig/EditorExtra/SerDe/DcSerDeInstancedStruct.h">DcSerDeInstancedStruct.h</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigEditorExtra5/Private/EditorExtra/SerDe/DcSerDeInstancedStruct.cpp">DcSerDeInstancedStruct.cpp</a></li>
</ul>
<pre><code class="language-c++">// DataConfigExtra5/Public/DataConfig/EditorExtra/SerDe/DcSerDeInstancedStruct.h
USTRUCT()
struct FDcEditorExtra5InstancedStruct1
{
    GENERATED_BODY()

    UPROPERTY() FInstancedStruct InstancedStruct1;
    UPROPERTY() FInstancedStruct InstancedStruct2;
    UPROPERTY() FInstancedStruct InstancedStruct3;
};

// DataConfigExtra5/Private/DataConfig/EditorExtra/SerDe/DcSerDeInstancedStruct.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;InstancedStruct1&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestSimpleStruct1&quot;,
            &quot;NameField&quot; : &quot;Foo&quot;
        },
        &quot;InstancedStruct2&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestStructWithColor1&quot;,
            &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
            &quot;ColorField2&quot; : &quot;#FF0000FF&quot;
        },
        &quot;InstancedStruct3&quot; : null
    }
)&quot;);
</code></pre>
<p>Note how the custom <code>FColor &lt;-&gt; &quot;#RRGGBBAA&quot;</code> conversion recursively works within <code>FInstancedStruct</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<p>This section contains documentation for advanced topics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p>We've integrated two benchmarks fixtures from <a href="https://json.nlohmann.me" title="JSON for Modern C++">JSON for modern C++</a> project. In the benchmark we deserialize JSON into C++ structs, then serialize them back to JSON. Then we convert JSON to MsgPack and do identical process.</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Tests/LargeFixtures/canada.json">canada.json</a></li>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Tests/LargeFixtures/corpus.ndjson">corpus.ndjson</a></li>
</ul>
<p>See <a href="Advanced/./Automation.html#running-the-benchmarks">here for instructions</a> to build and run the benchmark.</p>
<p>Here're the results:</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Benchmark/DcBenchmarkFixture1.cpp">DcBenchmarkFixture1.cpp</a></li>
</ul>
<p>On a Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz:</p>
<pre><code>Corpus Json Deserialize: [Shipping] Bandwidth: 77.816(MB/s), Mean: 70.891(ms), Median:70.662(ms), Deviation:0.861
Corpus Json Serialize: [Shipping] Bandwidth: 97.532(MB/s), Mean: 56.560(ms), Median:55.786(ms), Deviation:1.930
Corpus MsgPack Deserialize: [Shipping] Bandwidth: 89.347(MB/s), Mean: 58.498(ms), Median:58.339(ms), Deviation:0.573
Corpus MsgPack Serialize: [Shipping] Bandwidth: 79.530(MB/s), Mean: 65.719(ms), Median:65.457(ms), Deviation:0.867

Canada Json Deserialize: [Shipping] Bandwidth: 59.257(MB/s), Mean: 36.228(ms), Median:36.029(ms), Deviation:0.490
Canada Json Serialize: [Shipping] Bandwidth: 47.083(MB/s), Mean: 45.596(ms), Median:44.961(ms), Deviation:1.563
Canada MsgPack Serialize: [Shipping] Bandwidth: 101.112(MB/s), Mean: 5.778(ms), Median:5.764(ms), Deviation:0.060
Canada MsgPack Deserialize: [Shipping] Bandwidth: 89.467(MB/s), Mean: 6.530(ms), Median:6.513(ms), Deviation:0.094
</code></pre>
<p>On a AMD Ryzen 9 5950X 16-Core Processor 3.40 GHz:</p>
<pre><code>Corpus Json Deserialize: [Shipping] Bandwidth: 98.890(MB/s), Mean: 55.784(ms), Median:55.486(ms), Deviation:0.856
Corpus Json Serialize: [Shipping] Bandwidth: 107.389(MB/s), Mean: 51.369(ms), Median:51.046(ms), Deviation:1.531
Corpus MsgPack Deserialize: [Shipping] Bandwidth: 112.146(MB/s), Mean: 46.606(ms), Median:46.521(ms), Deviation:0.213
Corpus MsgPack Serialize: [Shipping] Bandwidth: 98.295(MB/s), Mean: 53.173(ms), Median:52.951(ms), Deviation:1.065

Canada Json Deserialize: [Shipping] Bandwidth: 72.858(MB/s), Mean: 29.465(ms), Median:29.238(ms), Deviation:0.802
Canada Json Serialize: [Shipping] Bandwidth: 57.586(MB/s), Mean: 37.279(ms), Median:37.363(ms), Deviation:0.640
Canada MsgPack Serialize: [Shipping] Bandwidth: 126.463(MB/s), Mean: 4.620(ms), Median:4.548(ms), Deviation:0.233
Canada MsgPack Deserialize: [Shipping] Bandwidth: 103.348(MB/s), Mean: 5.653(ms), Median:5.649(ms), Deviation:0.020
</code></pre>
<p>Some insights on the results:</p>
<ul>
<li>
<p>Benchmark in <code>Shipping</code> build configuration, otherwise it doesn't make much sense.</p>
</li>
<li>
<p>Recall that <a href="Advanced/../Design.html#manifesto">runtime performance isn't our top priority</a>. We opted for a classic inheritance based API for <code>FDcReader/FDcWriter</code> 
which means that each read/write step result in a virtual dispatch. This by design would result in mediocre performance metrics.
The bandwidth should be in the range of <code>10~100(MB/s)</code> on common PC setup, no matter how simple the format is.</p>
</li>
<li>
<p>MsgPack and JSON has similar bandwidth numbers in the benchmark. However MsgPack has far more tight layout when dealing with 
numeric data. Note in the <code>Canada</code> fixture MsgPack only takes around 10ms, as this fixture is mostly float number coordinates.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips-for-writing-handlers"><a class="header" href="#tips-for-writing-handlers">Tips for writing handlers</a></h1>
<p>There're some recurring patterns when writing handlers in DataConfig.</p>
<h2 id="recursive-deserialize"><a class="header" href="#recursive-deserialize">Recursive Deserialize</a></h2>
<p>When deserializing a container like <code>USTRUCT</code> root or <code>TArray</code> you'll need to recursively deserialize children properties. This is wrapped in a single function call:</p>
<pre><code class="language-c++">// DataConfigCore/Private/DataConfig/Deserialize/Handlers/Json/DcJsonStructDeserializers.cpp
DC_TRY(DcDeserializeUtils::RecursiveDeserialize(Ctx));
</code></pre>
<p>Internally it would push writer's next property into <code>FDcDeserializeContext::Properties</code> to satisfiy the invariant that <code>FDcDeserializeContext::TopProperty()</code> always points to the current writing property. It would also clear up the top property on return.</p>
<p>Another example is how we pipe deserialize a <code>TMap&lt;&gt;</code>. When at key and value position we simply call this method 2 times:</p>
<pre><code class="language-C++">// DataConfigCore/Private/DataConfig/Deserialize/Handlers/Property/DcPropertyPipeDeserializers.cpp
DC_TRY(Ctx.Reader-&gt;ReadMapRoot());
DC_TRY(Ctx.Writer-&gt;WriteMapRoot());

EDcDataEntry CurPeek;
while (true)
{
    DC_TRY(Ctx.Reader-&gt;PeekRead(&amp;CurPeek));
    if (CurPeek == EDcDataEntry::MapEnd)
        break;

    DC_TRY(DcDeserializeUtils::RecursiveDeserialize(Ctx));
    DC_TRY(DcDeserializeUtils::RecursiveDeserialize(Ctx));
}

DC_TRY(Ctx.Reader-&gt;ReadMapEnd());
DC_TRY(Ctx.Writer-&gt;WriteMapEnd());
</code></pre>
<h2 id="provide-topobject"><a class="header" href="#provide-topobject">Provide <code>TopObject()</code></a></h2>
<p>Sometimes deserialization will create new <code>UObject</code> along the way. In this case you'll need to fill in <code>FDcDeserializeContext::Objects</code> so the top one is used for <code>NewObject()</code> calls. For transient objecst you can use <code>GetTransientPackage()</code>:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestDeserialize.cpp
Ctx.Objects.Push(GetTransientPackage());
</code></pre>
<h2 id="peek-by-value"><a class="header" href="#peek-by-value">Peek By Value</a></h2>
<p>Sometimes you want to peek the content of the next entry. For example in <code>DcExtra::HandlerBPDcAnyStructDeserialize()</code> we're dealing with a JSON like this:</p>
<pre><code class="language-json">// DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeBPClass.cpp
{
    &quot;AnyStructField1&quot; : {
        &quot;$type&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintStructWithColor&quot;,
        &quot;NameField&quot; : &quot;Foo&quot;,
        //...
    }
}
</code></pre>
<p>We want to consume the <code>$type</code> key and its value, and then delegate the logic back to the deserializer. The solution here is first to consume the pair. Then we put back a <code>{</code>  then replace the reader:</p>
<pre><code class="language-c++">// DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeBPClass.cpp
FDcPutbackReader PutbackReader(Ctx.Reader);
PutbackReader.Putback(EDcDataEntry::MapRoot);
TDcStoreThenReset&lt;FDcReader*&gt; RestoreReader(Ctx.Reader, &amp;PutbackReader);

FDcScopedProperty ScopedValueProperty(Ctx);
DC_TRY(ScopedValueProperty.PushProperty());
DC_TRY(Ctx.Deserializer-&gt;Deserialize(Ctx));
</code></pre>
<p>Beware that <code>Putback</code> only support a limited subset of data types.</p>
<h2 id="coercion"><a class="header" href="#coercion">Coercion</a></h2>
<p>Readers implements <code>FDcReader::Coercion()</code> which can be used to query if the next value can be coerced into other types.</p>
<p>Here's an example of reading a JSON number as string:</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb2.cpp
FDcJsonReader Reader(TEXT(R&quot;(
    1.234567
)&quot;));

//  check coercion
//  note this is a query and doesn't affect reading at all
bool bCanCoerceToStr;
DC_TRY(Reader.Coercion(EDcDataEntry::String, &amp;bCanCoerceToStr));
check(bCanCoerceToStr);

//  read number token as stjring
//  note here we skipped parsing the number to float
FString NumStr;
DC_TRY(Reader.ReadString(&amp;NumStr));

check(NumStr == TEXT(&quot;1.234567&quot;));
return DcOk();
</code></pre>
<p>What's cool here is that <code>FDcJsonReader</code> does parsing at the <code>ReadFloat()</code> callsite. So when doing coercion above it actually skipped string to float parsing.</p>
<p>Here's a table of all existing coercion rules:</p>
<table><thead><tr><th>Reader</th><th>From Type</th><th>To Type</th></tr></thead><tbody>
<tr><td><code>FDcPropertyReader</code></td><td>Array</td><td>Blob</td></tr>
<tr><td></td><td>StructRoot</td><td>Blob</td></tr>
<tr><td><code>FDcJsonReader</code></td><td>Double</td><td>String</td></tr>
<tr><td></td><td>Double</td><td>Int8/Int16/Int32/Int64<br />UInt8/Uint16/UInt32/Uint64<br />Float</td></tr>
<tr><td></td><td>String</td><td>Name/Text</td></tr>
<tr><td><code>FDcMsgPackReader</code></td><td>String</td><td>Name/Text</td></tr>
</tbody></table>
<p>Some caveats regarding coercion:</p>
<ul>
<li>When reading from JSON/MsgPack string can be read as Name/Text for convenient.</li>
<li>When reading from Property, Array/Struct can be read as a <code>FDcBlobViewData</code> which directly points to the memory span.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-classstruct-root"><a class="header" href="#non-classstruct-root">Non Class/Struct Root</a></h1>
<p>Sometimes you just want to deserialize something into an <code>TArray/TMap/TSet</code>. Then you'll realize that you don't have something corresponding to <code>StaticClass()/StaticStruct()</code> as root to pass to DataConfig.</p>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb2.cpp
FString Fixture = TEXT(&quot;[1,2,3,4,5]&quot;);
TArray&lt;int&gt; Arr;
</code></pre>
<p>Turns out you can create adhoc <code>FProperty</code> without <code>USTRUCT/UCLASS</code> parents and use them just fine. In DataConfig we've provided <code>DcPropertyUtils::FDcPropertyBuilder</code> to ease this use case.</p>
<ul>
<li><a href="https://github.com/slowburn-dev/DataConfig/tree/release/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyUtils.h">DcPropertyUtils.h</a></li>
</ul>
<pre><code class="language-c++">// DataConfigTests/Private/DcTestBlurb2.cpp
//  create int array property
using namespace DcPropertyUtils;
auto ArrProp = FDcPropertyBuilder::Array(
    FDcPropertyBuilder::Int()
    ).LinkOnScope();

FDcJsonReader Reader{Fixture};
DC_TRY(DcAutomationUtils::DeserializeFrom(&amp;Reader, FDcPropertyDatum(ArrProp.Get(), &amp;Arr)));

//  validate results
check(Arr.Num() == 5);
check(Arr[4] == 5);
</code></pre>
<p>Note that <code>FDcPropertyBuilder</code> would create a heap allocated <code>FProperty</code> and <code>LinkOnScope()</code> returns a <code>TUniquePtr</code>. You might want to cache the properties if used repeatedly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automation"><a class="header" href="#automation">Automation</a></h1>
<p>One thing we find that's really important when maintaining DataConfig across multiple UE versions, is that proper automation is a must. On this page we document how to run the bundled automation tests.</p>
<p>Note that all instructions shown here are using Windows with a Cmd shell. You'll need to adapt to your system setup.</p>
<h2 id="dataconfigheadless"><a class="header" href="#dataconfigheadless">DataConfigHeadless</a></h2>
<p>We provide a standalone, command target that runs tests on core, non editor DataConfig features. <strong>This requires a <a href="https://docs.unrealengine.com/5.0/en-US/building-unreal-engine-from-source/">source build</a> to work</strong>, that means downloaded dists from Epic Launcher can not build this target.</p>
<ol>
<li>
<p>Get a copy of Unreal Engine source code. Also checkout <a href="Advanced/../Integration.html">DataConfig supported UE versions</a>.</p>
</li>
<li>
<p>Run <code>./GenerateProjectFiles.bat</code> under Unreal Engine root. Note that you <em>don't</em> need to build the editor. This step would build <code>UnrealBuildTool</code> which is enough for the headless target to work.</p>
</li>
<li>
<p>Get a copy of <a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig">DataConfig repository</a>. At the folder where <code>DataConfig.uplugin</code> and <code>DataConfig4.uplugin</code> resides:</p>
<pre><code class="language-shell"># UE5
&lt;PathToUE5SourceBuild&gt;/Engine/Binaries/DotNET/UnrealBuildTool/UnrealBuildTool.exe -project=&quot;%CD%/DataConfig.uplugin&quot; DataConfigHeadless Win64 Debug

# UE4
&lt;PathToUE4SourceBuild&gt;/Engine/Binaries/DotNET/UnrealBuildTool.exe -project=&quot;%CD%/DataConfig4.uplugin&quot; DataConfigHeadless Win64 Debug
</code></pre>
<p>Note how UE4/5 uses <code>DataConfig4.uplugin/DataConfig.uplugin</code> respectively.</p>
</li>
<li>
<p>Run the headless target binary:</p>
<pre><code class="language-shell">%CD%/Binaries/Win64/DataConfigHeadless-Win64-Debug.exe
</code></pre>
<p>A success run looks like this:</p>
<pre><code class="language-shell">LogDataConfigCore: Display: UE Version: 5.1.0, DataConfigCore Version: 1.4.0, 10400
LogDataConfigCore: Display: Filters: DataConfig.
-   OK | DataConfig.Core.Property.StackScalarRoots
-   OK | DataConfig.Extra.SerDe.Base64
.......
-   OK | DataConfig.Extra.InlineStructUsage
-   OK | DataConfig.Core.Property.Primitive1
Run:  122, Success:  122, Fail:    0
</code></pre>
</li>
</ol>
<h3 id="running-the-benchmarks"><a class="header" href="#running-the-benchmarks">Running the benchmarks</a></h3>
<p><code>DataConfigHeadless</code> accepts command line arguments as filters. The benchmarks runs slower are skipped by default.
You can build and run the benchmarks with the commands below:</p>
<pre><code class="language-shell"># remember to build in Shipping
&lt;PathToUE5SourceBuild&gt;/Engine/Binaries/DotNET/UnrealBuildTool/UnrealBuildTool.exe -project=&quot;%CD%/DataConfig.uplugin&quot; DataConfigHeadless Win64 Shipping
%CD%/Binaries/Win64/DataConfigHeadless-Win64-Shipping.exe DataConfigBenchmark
</code></pre>
<h3 id="build-and-run-linux-target-with-wsl2"><a class="header" href="#build-and-run-linux-target-with-wsl2">Build and run Linux target with WSL2</a></h3>
<p>UE officially support cross compiling for linux and distribute toolchains on its website. Here we demonstrate how to build the headless
target for Linux and run it under WSL2.</p>
<ol>
<li>
<p>Setup WSL2 <a href="https://docs.microsoft.com/en-us/windows/wsl/install">following this guide</a>. You should get the latest LTS Ubuntu. Run <code>wsl lsb_release -ir</code> to validate it's working.</p>
<pre><code class="language-shell">&gt; wsl lsb_release -ir
Distributor ID: Ubuntu
Release:        22.04
</code></pre>
</li>
<li>
<p>Install UE cross compile toolchain. Grab the installer and install on your machine.</p>
<ul>
<li><a href="https://docs.unrealengine.com/4.27/en-US/SharingAndReleasing/Linux/GettingStarted/#gettingthetoolchain">Cross-compile toolchain for UE4</a></li>
<li><a href="https://docs.unrealengine.com/5.0/en-US/linux-development-requirements-for-unreal-engine/#gettingthetoolchain">Cross-compile toolchain for UE5</a></li>
</ul>
<p>Note that each UE version matches a different toolchain. You can download and install multiple toolchains and select which to use at build time 
through environment variable.</p>
</li>
<li>
<p>Build the headless target for Linux.</p>
<pre><code class="language-shell"># UE5.1
set LINUX_MULTIARCH_ROOT=&lt;PathToToolchains&gt;/v20_clang-13.0.1-centos7
&lt;PathToUE5SourceBuild&gt;/Engine/Binaries/DotNET/UnrealBuildTool/UnrealBuildTool.exe -project=&quot;%CD%/DataConfig.uplugin&quot; DataConfigHeadless Linux Debug

# UE4
set LINUX_MULTIARCH_ROOT=&lt;PathToToolchains&gt;/v19_clang-11.0.1-centos7
&lt;PathToUE4SourceBuild&gt;/Engine/Binaries/DotNET/UnrealBuildTool.exe -project=&quot;%CD%/DataConfig4.uplugin&quot; DataConfigHeadless Linux Debug
</code></pre>
</li>
<li>
<p>Run the headless target through WSL.</p>
<pre><code class="language-shell">wsl ./Binaries/Linux/DataConfigHeadless-Linux-Debug 
</code></pre>
<p>A success run looks like this:</p>
<pre><code class="language-shell">Using Mimalloc.
LogInit: Build: ++UE5+Release-5.1-CL-0
LogInit: Engine Version: 5.1.0-0+++UE5+Release-5.1
LogInit: Compatible Engine Version: 5.1.0-0+++UE5+Release-5.1
LogInit: OS: Ubuntu 22.04.1 LTS (5.10.102.1-microsoft-standard-WSL2)
.......
LogDataConfigCore: Display: UE Version: 5.1.0, DataConfigCore Version: 1.4.0, 10400
LogDataConfigCore: Display: Filters: DataConfig.
-   OK | DataConfig.Core.MsgPack.TestSuite
-   OK | DataConfig.Core.Property.Blob2
.......
-   OK | DataConfig.Core.Serialize.ObjectRef
-   OK | DataConfig.Core.MsgPack.Extension
Run:  122, Success:  122, Fail:    0
LogCore: Engine exit requested (reason: DataConfigHeadless Main Exit)
LogExit: Preparing to exit.
LogExit: Object subsystem successfully closed.
LogExit: Exiting.
</code></pre>
</li>
</ol>
<h2 id="dccoretestscommandlet"><a class="header" href="#dccoretestscommandlet">DcCoreTestsCommandlet</a></h2>
<p><code>DataConfigHeadless</code> is a Program target that does <em>not</em> depend on <code>Engine</code> and <code>UnrealEd</code> module. It get faster compile and iteration time, but losing functionality to touch any gameplay and editor code.</p>
<p>With the editor target we have a <code>DcCoreTestsCommandlet</code> that can be run through the commandline editor target. On top of that this works with pre-built editor downloaded from Epic Launcher.</p>
<ol>
<li>
<p><a href="Advanced/../Integration.html">Integrate DataConfig plugin</a> into your project.
You can also find a clean project bundled at <a href="https://github.com/slowburn-dev/DataConfig/tree/release/Misc/Project"><code>Misc/Project</code></a>.</p>
</li>
<li>
<p>Build the editor target.
You can do it in Visual Studio or with commands below:</p>
<pre><code class="language-shell"># UE5
# build
&lt;PathToUE5&gt;/Engine/Binaries/DotNET/UnrealBuildTool/UnrealBuildTool.exe DcProjectEditor Win64 Development %CD%/DcProject5.uproject -NoHotReload -NoEngineChanges
# run commandlet
&lt;PathToUE5&gt;/Engine/Binaries/Win64/UnrealEditor-Cmd.exe %CD%/DcProject5.uproject DataConfigEditorExtra.DcCoreTestsCommandlet

# UE4
# build
&lt;PathToUE4&gt;/Engine/Binaries/DotNET/UnrealBuildTool.exe DcProjectEditor Win64 Development %CD%/DcProject4.uproject -NoHotReload -NoEngineChanges
# run commandlet
&lt;PathToUE4&gt;/Engine/Binaries/Win64/UE4Editor-Cmd.exe %CD%/DcProject4.uproject DataConfigEditorExtra.DcCoreTestsCommandlet
</code></pre>
<p>A success run looks like this:</p>
<pre><code class="language-shell"> [2022.10.25-14.33.52:893][  0]LogTextureFormatETC2: Display: ETC2 Texture loading DLL: TextureConverter.dll
 [2022.10.25-14.33.52:903][  0]LogTargetPlatformManager: Display: Loaded TargetPlatform 'Android'
 [2022.10.25-14.33.52:903][  0]LogTargetPlatformManager: Display: Loaded TargetPlatform 'Android_ASTC'
 [2022.10.25-14.33.52:903][  0]LogTargetPlatformManager: Display: Loaded TargetPlatform 'Android_DXT'
 .......
 [2022.10.25-14.39.30:999][  0]LogDataConfigCore: Display: Filters: DataConfig.
 -   OK | DataConfig.Core.RoundTrip.MsgPack_Persistent_StringSoftLazy
 -   OK | DataConfig.EditorExtra.GameplayEffect
 .......
 -   OK | DataConfig.Core.Property.PropertyBuilder3
 -   OK | DataConfig.EditorExtra.BPObjectInstance
 Run:  129, Success:  129, Fail:    0
</code></pre>
</li>
</ol>
<h2 id="running-automation-in-the-editor"><a class="header" href="#running-automation-in-the-editor">Running automation in the editor</a></h2>
<p>Lastly you can <a href="Advanced/../Integration.html#validate-integration">run and debug automation tests from the editor</a>. </p>
<p>It's the most conventional way to run automation and is well supported in DataConfig.</p>
<p><img src="Advanced/../Images/Integration-DataConfigAutomations.png" alt="Integration-DataConfigAutomations" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unreal-engine-upgrades"><a class="header" href="#unreal-engine-upgrades">Unreal Engine Upgrades</a></h1>
<p>DataConfig is committed to support multiple UE versions with no deprecations and warnings. On this page we'll document important upgrade and migration info.</p>
<h1 id="ue4"><a class="header" href="#ue4">UE4</a></h1>
<ul>
<li>The oldest version DataConfig supports is UE 4.25, in which it <a href="https://docs.unrealengine.com/4.27/en-US/WhatsNew/Builds/ReleaseNotes/4_25/#new:uobjectpropertyoptimizations">introduces a major refactor</a> that changes <code>UProperty</code> to <code>FProperty</code>. We intended to support UE4 in the foreseeable future, especially when we now have separated <code>uplugin</code> for UE4 and UE5.</li>
</ul>
<h1 id="ue50"><a class="header" href="#ue50">UE5.0</a></h1>
<ul>
<li>
<p>New <a href="https://docs.unrealengine.com/5.0/en-US/unreal-engine-5-migration-guide/#c++objectpointerproperties"><code>TObjectPtr</code></a> to replace raw UObject pointers. Turns out this is mostly handled within the engine and is transparent to DataConfig.</p>
</li>
<li>
<p>New property types <code>FObjectPtrProperty</code> and <code>FClassPtrProperty</code> are added. They're handled the same as <code>FObjectProperty</code> and <code>FClassProperty</code> respectively.</p>
</li>
<li>
<p><code>FVector</code> now is 3 <code>double</code>s, and <code>Real</code> data type in Blueprint now is also double. This is also mostly transparent to DataConfig.</p>
</li>
<li>
<p><code>FScriptArrayHelperAccess</code> size changes with a added <code>uint32 ElementAlignment</code>.</p>
</li>
<li>
<p><code>TStringBuilderWithBuffer</code> API changes. At call sites we now do <code>Sb &lt;&lt; TCHAR('\n')</code> instead of <code>Sb.Append(TCHAR('\n'))</code> .</p>
</li>
</ul>
<h1 id="ue51"><a class="header" href="#ue51">UE5.1</a></h1>
<ul>
<li>UE5.1 deprecates <code>ANY_PACKAGE</code> in favor of a new method <code>FindFirstObject</code>. In DataConfig we provided <code>DcSerdeUtils::FindFirstObject</code> which calls <code>FindObject(ANY_PACKAGE)</code> pre 5.1 and calls <code>FindFirstObject()</code> for 5.1 and onwards. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changes"><a class="header" href="#changes">Changes</a></h1>
<p>All notable changes to this project will be documented in this file.</p>
<h2 id="140---2022-11-17"><a class="header" href="#140---2022-11-17">1.4.0 - 2022-11-17</a></h2>
<p>Checkout blog post <a href="/blog/dataconfig-1-4/">&quot;DataConfig 1.4 Released with UE 5.1 Support&quot;</a>.</p>
<ul>
<li><strong>NEW</strong> Support for UE 5.1.
<ul>
<li>See <a href="Advanced/UEUpgrades.html">UE version upgrade</a>.</li>
</ul>
</li>
<li><strong>NEW</strong> Extra samples and docs.
<ul>
<li><a href="Advanced/Automation.html">Advanced - Automation</a></li>
<li><a href="Extra/InstancedStruct.html">Extra - InstancedStruct</a></li>
<li><a href="Formats/Property.html#configuring-with-fdcpropertyconfig">Configuring with <code>FPropertyConfig</code></a></li>
<li><a href="Advanced/WritingHandlers.html#coercion">Writing Handlers - Coercion</a></li>
</ul>
</li>
<li><strong>CHANGE</strong> Use separated <code>uplugin</code> for UE4 and UE5.
<ul>
<li>See <a href="Integration.html#integrate-dataconfig-plugin">Integration</a></li>
</ul>
</li>
<li><strong>FIX</strong> Core changes and fixes:
<ul>
<li>Fail when <code>FPropertyWriter::WriteObjectReference()</code> takes nullptr.
See test: <code>DataConfig.Core.Property.DiagNullObject</code></li>
<li>Additional check for class mismatch for default object deserialize handlers.
See test: <code>DataConfig.Core.Deserialize.DiagObjectClassMismatch</code></li>
</ul>
</li>
</ul>
<h2 id="130---2022-6-20"><a class="header" href="#130---2022-6-20">1.3.0 - 2022-6-20</a></h2>
<p>Checkout blog post <a href="/blog/dataconfig-dcjsonasset-1-3/">&quot;DataConfig Core and JSON Asset 1.3 Release&quot;</a>.</p>
<ul>
<li><strong>CHANGE</strong> Property reader/writer improvement and fixes 
<ul>
<li>Allow reading <code>Array/Set/Map</code> and  native array like <code>int arr[5]</code> as root.<br>
See: <a href="Advanced/NonClassStructRoot.html">Non Class/Struct Root</a></li>
<li>Expand property with <code>ArrayDim &gt; 1</code> as array.<br>
See: <a href="Formats/Property.html">Property</a></li>
<li>Performance improvement by caching <code>FScript/Array/SetHelper</code></li>
</ul>
</li>
<li><strong>NEW</strong> Extra samples:
<ul>
<li><a href="Extra/DumpAssetToLog.html">Dump Asset To Log</a></li>
<li><a href="Extra/SQLite.html">Deserialize From SQLite Query</a></li>
<li><a href="Extra/InlineStruct.html">Inline Struct</a></li>
</ul>
</li>
<li><strong>FIX</strong> Core changes and fixes:
<ul>
<li>Fix stale enum property fields serialization crash.</li>
<li>Fix <code>TSet/TMap</code> serialization crashes.</li>
<li>Fix soft object/class reference serialize to nil when it's not loaded.</li>
<li>Fix pipe property class/object handlers.</li>
<li>Fix <code>TObjectPtr&lt;&gt;</code> serialialzation and deserialization.</li>
<li>Fix <code>PeekReadDataPtr</code> on class property.</li>
<li>Removed <code>FScopedStackedReader/FScopedStackedWriter</code> usage.</li>
<li>Fix <code>HeuristicVerifyPointer</code> diagnostic.</li>
<li>Fix <code>DC_TRY</code> shadowing variable <code>Ret</code>.</li>
<li>JSON now support non string keyed <code>TMap&lt;&gt;</code> as <code>[{ &quot;$key&quot;: &lt;foo&gt;, &quot;$value&quot;: &lt;bar&gt; }]</code>.<br>
See: <a href="Formats/JSON.html#map">JSON- Map</a></li>
<li>Fix <code>DcPropertyUtils::DcIsSubObjectProperty()</code><br>
Now it only checks for <code>CPF_InstancedReference</code>.</li>
<li>Update screenshots to UE5.<br> Note that DataConfig <a href="Integration.html">still supports from 4.25 and onwards</a>.</li>
<li>Update <a href="Formats/Property.html">Property</a> docs.</li>
</ul>
</li>
</ul>
<h2 id="122---2022-4-5"><a class="header" href="#122---2022-4-5">1.2.2 - 2022-4-5</a></h2>
<ul>
<li>Support for <a href="https://docs.unrealengine.com/5.0/en-US/unreal-engine-5-0-release-notes/">UE 5.0.0</a></li>
<li>Add <code>DebugGetRealPropertyValue</code> for double BP fields. </li>
</ul>
<h2 id="121---2022-2-23"><a class="header" href="#121---2022-2-23">1.2.1 - 2022-2-23</a></h2>
<ul>
<li>Support for <a href="https://www.unrealengine.com/en-US/blog/unreal-engine-5-is-now-available-in-preview">UE5 Preview 1</a>.</li>
<li><strong>FIX</strong> Compile fixes for examples on UE 4.25.</li>
<li><strong>FIX</strong> UE 4.25/4.26 editor extra BP serde automation test fixes.</li>
<li><strong>FIX</strong> <code>FDcAnsiJsonWriter</code> writes non ascii char to <code>?</code> when string contains escaping characters.
<ul>
<li><code>FDcJsonWriter</code> was unaffected. This only happens to the ansi char writer and only when input has escapes like <code>\t</code>.</li>
</ul>
</li>
</ul>
<h2 id="120---2022-1-26"><a class="header" href="#120---2022-1-26">1.2.0 - 2022-1-26</a></h2>
<p>Checkout blog post <a href="/blog/dataconfig-1-2/">&quot;Introducing DataConfig 1.2&quot;</a>.</p>
<ul>
<li><strong>NEW</strong> Serializer. Previously we only have deserializers. 
<ul>
<li>Serializer API mirrors deserializers.</li>
<li>Builtin serialization and deserialization handlers are all roundtrip-able.</li>
<li><code>DcDiagnosticDeserialize -&gt; DcDiagnosticSerDe</code> for sharing diagnostics.</li>
<li><code>DcDeserializeUtils -&gt; DcSerDeUtils</code> for sharing code.</li>
</ul>
</li>
<li><strong>NEW</strong> MsgPack reader and writer.
<ul>
<li>Full spec implemented, minus the &quot;Timestamp extension type&quot;.</li>
<li>Integrate and passes <a href="https://github.com/kawanet/msgpack-test-suite">kawanet/msgpack-test-suite</a>.</li>
</ul>
</li>
<li><strong>NEW</strong> JSON writer.
<ul>
<li>With <code>WIDECHAR/ANSICHAR</code> specialization as JSON Reader.</li>
<li>Accept config to output pretty or condensed output.</li>
</ul>
</li>
<li><strong>NEW</strong> Builtin metas.
<ul>
<li><code>DcSkip</code>  - skip marked fields</li>
<li><code>DcMsgPackBlob</code>  - marked TArray&lt;&gt;/Struct would be read as blob by MsgPack SerDe</li>
</ul>
</li>
<li><strong>CHANGE</strong> Core type changes.
<ul>
<li><code>FDcReader/FDcWriter</code> changes.
<ul>
<li><code>FDcStruct/ClassStat</code> renamed to <code>FDcStruct/ClassAccess</code>.</li>
<li><code>ReadStruct/ClassRoot()</code> renamed to <code>ReadStruct/ClassRootAccess</code>.</li>
<li>Add<code>ReadStruct/ClassRoot()</code> that takes no argument for common use cases.</li>
<li><code>FDcReader::Coercion()</code> now returns a <code>FDcResult</code></li>
<li><code>[Read/Write]Soft[Object/Class]Reference</code> takes <code>FSoftObjectPtr</code>.</li>
<li>RTTI with <code>GetId()</code> and <code>CastById()</code></li>
</ul>
</li>
<li><code>FDcSerializer/FDcDeserializer</code> changes.
<ul>
<li><code>DcDiagnosticDeserialize</code> -&gt; <code>DcDiagnosticSerDe</code> for sharing diagnostics.</li>
<li><code>DcDeserializeUtils</code> -&gt; <code>DcSerDeUtils</code> for sharing code.</li>
<li>Add handlers to read/write <code>Soft/Lazy</code> references as is, without loading the object.</li>
<li>Implicit call <code>Properties.Push()</code> before context <code>Prepare()</code>.</li>
<li>Removed <code>FDcScopedProperty</code> in favor of <code>DcDeserializeUtils::RecursiveDeserialize()</code> it's more concise. </li>
</ul>
</li>
<li><code>FDcPropertyReader/FDcPropertyWriter</code> changes.
<ul>
<li>When reading class object keys any one with <code>$</code> will be ignored.
<ul>
<li>previously only allow <code>$type</code>, <code>$path</code>.</li>
<li>note that struct by default don't check for these. It's trivia to add the logic if you want to.</li>
</ul>
</li>
<li>Add <code>FDcPropertyReader::PeekReadDataPtr</code> matches with <code>PeekProperty</code></li>
</ul>
</li>
<li><code>FDcJsonReader</code> changes.
<ul>
<li>Remove object key length limit, which was 2048 and it's incorrect.
<ul>
<li>Though <code>FName</code> is capped at 1024, which is a Unreal Engine limit.</li>
</ul>
</li>
<li>Fix <code>ReadName()</code> which previously would fail.</li>
<li>Fix quoted string parsing/escaping  in <code>ParseQuotedString</code></li>
</ul>
</li>
<li>Add <code>EDcDataEntry::Extension</code>.</li>
<li>Add <code>FDcPropertyDatum</code> template constructor to directly construct one from a <code>FSturct*</code>.</li>
<li><code>FPrettyPrintWriter</code> now print blobs with hash, previously it's pointer value.</li>
<li><code>DcAutomationUtils::SerializeIntoJson/DeserializeIntoJson</code> -&gt; <code>SerializeInto/DeserializeFrom</code> as we're supporting other formats.</li>
<li>Add <code>HeuristicVerifyPointer</code> to check common magic invalid pointers.</li>
</ul>
</li>
<li>Misc fixes and QOL improvements.
<ul>
<li>Fixed linux build. Now the headless program target cross compiles and runs under wsl.</li>
<li>Serializer/Deserializer now also report diagnostics.</li>
<li>Better Json reader diagnostic formatting. Now it clamps long lines properly.</li>
<li>Add <code>DataConfigEditorExtra.DcCoreTestsCommandlet</code> as tests runner.</li>
<li>Add performance benchmark.</li>
<li>Restructured DataConfig book for topics on serializer and MsgPack.</li>
</ul>
</li>
</ul>
<h2 id="111---2021-10-6"><a class="header" href="#111---2021-10-6">1.1.1 - 2021-10-6</a></h2>
<ul>
<li>Support for UE 4.27.</li>
<li>Support for UE 5.</li>
</ul>
<h2 id="110---2021-4-24"><a class="header" href="#110---2021-4-24">1.1.0 - 2021-4-24</a></h2>
<ul>
<li>Integrate <a href="https://github.com/nst/JSONTestSuite">nst/JSONTestSuite</a>. Now <code>DcJSONParser</code> pass most of them. Skipped tests are also documented.</li>
<li><code>FDcAnsiJsonReader</code> now detect and convert non ASCII UTF8 characters. Previously these characters are dropped.</li>
<li>Headless test runner pass along parameters to tests, for example
<code>DataConfigHeadless-Win64-Debug.exe Parsing -- n_array_just_minus</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license-1"><a class="header" href="#license-1">License</a></h1>
<p>DataConfig is released under <a href="https://choosealicense.com/licenses/mit/" title="MIT License">MIT License</a>.</p>
<pre><code>MIT License

Copyright (c) 2021-2022 Chen Tao 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>If you find DataConfig useful in your project, consider credit us in your project with the full license above or the shorter snippets below. </p>
<pre><code>DataConfig &lt;https//slowburn.dev/dataconfig&gt;
MIT License, Copyright (c) 2021-2022 Chen Tao
</code></pre>
<p>There's also <a href="https://www.unrealengine.com/marketplace/en-US/product/dataconfig-json-asset" title="DataConfig JSON Asset">DataConfig JSON Asset</a> on UE Marketplace. It's a premium plugin for importing JSON to UE data assets.</p>
<p>You can reach us by email to <a href="mailto:hislowburn@gmail.com">hislowburn@gmail.com</a> or on twitter <a href="https://twitter.com/slowburndev">@slowburndev</a>. </p>
<p>We'll setup a section showcasing projects using DataConfig in the future.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
