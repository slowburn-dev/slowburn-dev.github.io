<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DataConfig Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Serialization framework for Unreal Engine Property System that just works!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="Examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Examples/Custom.html"><strong aria-hidden="true">2.1.</strong> Custom</a></li><li class="chapter-item expanded "><a href="Examples/DebugDump.html"><strong aria-hidden="true">2.2.</strong> Debug Dump</a></li></ol></li><li class="chapter-item expanded "><a href="Integration.html"><strong aria-hidden="true">3.</strong> Integration</a></li><li class="chapter-item expanded "><a href="Design.html"><strong aria-hidden="true">4.</strong> Design</a></li><li class="chapter-item expanded "><a href="Programming/index.html"><strong aria-hidden="true">5.</strong> Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Programming/DataModel.html"><strong aria-hidden="true">5.1.</strong> Data Model</a></li><li class="chapter-item expanded "><a href="Programming/ErrorHandling.html"><strong aria-hidden="true">5.2.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="Programming/Env.html"><strong aria-hidden="true">5.3.</strong> Env</a></li><li class="chapter-item expanded "><a href="Programming/ReaderWriter.html"><strong aria-hidden="true">5.4.</strong> Reader Writer</a></li><li class="chapter-item expanded "><a href="Programming/SerializerDeserializer.html"><strong aria-hidden="true">5.5.</strong> Serializer Deserializer</a></li></ol></li><li class="chapter-item expanded "><a href="Formats/index.html"><strong aria-hidden="true">6.</strong> Formats</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Formats/JSON.html"><strong aria-hidden="true">6.1.</strong> JSON</a></li><li class="chapter-item expanded "><a href="Formats/MsgPack.html"><strong aria-hidden="true">6.2.</strong> MsgPack</a></li><li class="chapter-item expanded "><a href="Formats/PipeProperty.html"><strong aria-hidden="true">6.3.</strong> Pipe Property</a></li></ol></li><li class="chapter-item expanded "><a href="Extra/index.html"><strong aria-hidden="true">7.</strong> Extra</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Extra/FColor.html"><strong aria-hidden="true">7.1.</strong> FColor</a></li><li class="chapter-item expanded "><a href="Extra/Base64.html"><strong aria-hidden="true">7.2.</strong> Base64 Blob</a></li><li class="chapter-item expanded "><a href="Extra/WriterAPI.html"><strong aria-hidden="true">7.3.</strong> WriterAPI</a></li><li class="chapter-item expanded "><a href="Extra/JsonConverter.html"><strong aria-hidden="true">7.4.</strong> JsonConverter</a></li><li class="chapter-item expanded "><a href="Extra/AnyStruct.html"><strong aria-hidden="true">7.5.</strong> AnyStruct</a></li><li class="chapter-item expanded "><a href="Extra/FieldRenamer.html"><strong aria-hidden="true">7.6.</strong> Field Renamer</a></li><li class="chapter-item expanded "><a href="Extra/PropertyPath.html"><strong aria-hidden="true">7.7.</strong> Property Path</a></li><li class="chapter-item expanded "><a href="Extra/ModuleSetup.html"><strong aria-hidden="true">7.8.</strong> Module Setup</a></li><li class="chapter-item expanded "><a href="Extra/Blueprint.html"><strong aria-hidden="true">7.9.</strong> Blueprint</a></li><li class="chapter-item expanded "><a href="Extra/GameplayTag.html"><strong aria-hidden="true">7.10.</strong> Gameplay Tag</a></li><li class="chapter-item expanded "><a href="Extra/GameplayAbility.html"><strong aria-hidden="true">7.11.</strong> Gameplay Ability</a></li></ol></li><li class="chapter-item expanded "><a href="Advanced/index.html"><strong aria-hidden="true">8.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Advanced/Benchmark.html"><strong aria-hidden="true">8.1.</strong> Benchmark</a></li><li class="chapter-item expanded "><a href="Advanced/WritingHandlers.html"><strong aria-hidden="true">8.2.</strong> Writing Handlers</a></li></ol></li><li class="chapter-item expanded "><a href="Changes.html"><strong aria-hidden="true">9.</strong> Changes</a></li><li class="chapter-item expanded "><a href="License.html"><strong aria-hidden="true">10.</strong> License</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DataConfig Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/slowburn-dev/DataConfig" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dataconfig-book"><a class="header" href="#dataconfig-book">DataConfig Book</a></h1>
<p><strong>Serialization framework for Unreal Engine Property System that just works!</strong></p>
<p><a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig"><strong>DataConfig</strong></a> is a serialization framework built on top of Unreal Engine's Property System. It aims to be friendly and robust while offering good performance. Notably features:</p>
<ul>
<li>Out of the box JSON/MsgPack read write.</li>
<li>Full support for <code>UPROPERTY()/UCLASS()/USTRUCT()/UENUM()</code>.</li>
<li>Pull/Push style API for verbatim data access and lossless type information.</li>
<li>Designed as a collection of tools that can be easily extended to support other formats.</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ul>
<li>Get the code on <a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig">github</a>.</li>
<li>See <a href="Examples/index.html">Examples</a> for code examples.</li>
<li>See <a href="Integration.html">Integration</a> for quick integration guide.</li>
<li>See <a href="Design.html">Design</a> for more context about the project.</li>
<li>See <a href="Extra/index.html">Extra</a> for more advanced usages.</li>
<li>See <a href="Changes.html">Changes</a> for versioning history.</li>
</ul>
<p>There's also <a href="https://www.unrealengine.com/marketplace/en-US/product/dataconfig-json-asset" title="DataConfig JSON Asset">DataConfig JSON Asset</a> on UE Marketplace. It's a premium plugin for importing JSON to UE data assets.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p><strong>DataConfig</strong> is released under a free and permissive license. But we really appreciate you to credit us if you find it useful. See <a href="License.html">License</a> for details</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Here're some short and quick examples showcasing DataConfig API usage and features. All code shown here can be found in the <a href="https://github.com/slowburn-dev/DataConfig/blob/release/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp" title="DcTestBlurb.cpp">repo</a>.</p>
<h2 id="json-deserialization"><a class="header" href="#json-deserialization">JSON Deserialization</a></h2>
<p>Given the struct<code>FDcTestExampleStruct</code>:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.h
UENUM()
enum class EDcTestExampleEnum
{
    Foo, Bar, Baz
};

USTRUCT()
struct FDcTestExampleStruct
{
    GENERATED_BODY()
    UPROPERTY() FString StrField;
    UPROPERTY() EDcTestExampleEnum EnumField;
    UPROPERTY() TArray&lt;FColor&gt; Colors;
};
</code></pre>
<p>We can deserialize an instance from JSON with the snippet below:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
        &quot;EnumField&quot; : &quot;Bar&quot;,
        &quot;Colors&quot; : [
            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
        ]
    }
)&quot;);

FDcTestExampleStruct Dest;

//  create and setup a deserializer
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);
Deserializer.AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(DcExtra::PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(DcExtra::HandlerColorDeserialize)
);

//  prepare context for this run
FDcPropertyDatum Datum(&amp;Dest);
FDcJsonReader Reader(Str);
FDcPropertyWriter Writer(Datum);

FDcDeserializeContext Ctx;
Ctx.Reader = &amp;Reader;
Ctx.Writer = &amp;Writer;
Ctx.Deserializer = &amp;Deserializer;
DC_TRY(Ctx.Prepare());

//  kick off deserialization
DC_TRY(Deserializer.Deserialize(Ctx));

//  validate results
check(Dest.StrField == TEXT(&quot;Lorem ipsum dolor sit amet&quot;));
check(Dest.EnumField == EDcTestExampleEnum::Bar);
check(Dest.Colors[0] == FColor::Red);
check(Dest.Colors[1] == FColor::Green);
check(Dest.Colors[2] == FColor::Blue);
</code></pre>
<p>Note that <code>EDcTestExampleEnum</code> is deserialized by its name and <code>FColor</code> is deserialized from a html color string like <code>#RRGGBBAA</code>.</p>
<p>Say if we accidentally mistyped the <code>EnumField</code> value:</p>
<pre><code class="language-json">{
    &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
    &quot;EnumField&quot; : &quot;Far&quot;,
}
</code></pre>
<p>It would fail gracefully with diagnostics:</p>
<pre><code># DataConfig Error: Enum name not found in enum type: EDcTestExampleEnum, Actual: 'Far'
- [JsonReader] --&gt; &lt;in-memory&gt;4:25
   2 |    {
   3 |        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
   4 |        &quot;EnumField&quot; : &quot;Far&quot;,
     |                           ^
   5 |        &quot;Colors&quot; : [
   6 |            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
- [PropertyWriter] Writing property: (FDcTestExampleStruct)$root.(EEDcTestExampleEnum)EnumField
</code></pre>
<p>As bonus we serialize the struct into MsgPack: </p>
<pre><code class="language-c++">FDcSerializer Serializer;
DcSetupMsgPackSerializeHandlers(Serializer);

FDcPropertyDatum Datum(&amp;Dest);
FDcPropertyReader Reader(Datum);
FDcMsgPackWriter Writer;

//  prepare serialize context
FDcSerializeContext Ctx;
Ctx.Reader = &amp;Reader;
Ctx.Writer = &amp;Writer;
Ctx.Serializer = &amp;Serializer;
DC_TRY(Ctx.Prepare());

//  kick off serialization
DC_TRY(Serializer.Serialize(Ctx));

auto&amp; Buffer = Writer.GetMainBuffer();
//  starts withMsgPack FIXMAP(3) header
check(Buffer[0] == 0x83);   
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-serialization-and-deserialization"><a class="header" href="#custom-serialization-and-deserialization">Custom Serialization And Deserialization</a></h1>
<p>DataConfig support custom serialization and deserialization logic by implementing <code>FDcSerializeDelegate/FDcDeserializeDelegate</code>.</p>
<p>In this example, we'd like to convert <code>FColor</code> into <code>#RRGGBBAA</code> and vice versa: </p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Deserialize/DcSerDeColor.h
USTRUCT()
struct FDcExtraTestStructWithColor1
{
    GENERATED_BODY()

    UPROPERTY() FColor ColorField1;
    UPROPERTY() FColor ColorField2;
};

// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeColor.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
        &quot;ColorField2&quot; : &quot;#FF0000FF&quot;,
    }
)&quot;);
</code></pre>
<p>First you'll need to implement a <code>FDcDeserializePredicate</code> delegate to pick out <code>FColor</code> properties:</p>
<pre><code class="language-c++">//  DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
EDcDeserializePredicateResult PredicateIsColorStruct(FDcDeserializeContext&amp; Ctx)
{
    return DcDeserializeUtils::PredicateIsUStruct&lt;FColor&gt;(Ctx);
}
</code></pre>
<p>Then we'll need to implement a <code>FDcDeserializeDelegate</code> to deserialize a <code>FColor</code>. Here we'll do it by writing through <code>R/G/B/A</code> fields by name with the <code>FDcWriter</code> API.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeColor.cpp
FDcResult HandlerColorDeserialize(FDcDeserializeContext&amp; Ctx)
{
    FDcPropertyDatum Datum;
    DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

    FString ColorStr;
    DC_TRY(Ctx.Reader-&gt;ReadString(&amp;ColorStr));
    FColor Color = FColor::FromHex(ColorStr);

    FColor* ColorPtr = (FColor*)Datum.DataPtr;
    *ColorPtr = Color;

    return DcOk();
}
</code></pre>
<p>Note how we retrieve the hex string, then parse it with <code>FColor::FromHex</code>.</p>
<p>Upon deserializing we'll need to register these pair of delegates to the <code>FDcDeserializer</code>.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);
Deserializer.AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(DcExtra::PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(DcExtra::HandlerColorDeserialize)
);
</code></pre>
<p>And then it's done! It would work recursively on <code>FColor</code> everywhere, like in <code>UCLASS/USTRUCT</code> members, in <code>TArray/TSet</code> and in <code>TMap</code> as key or values.</p>
<p>Note that DataConfig completely separate serialization and deserialization logic. To serialize <code>FColor</code> into <code>#RRGGBBAA</code> string one needs to implement a similar set of methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-dump"><a class="header" href="#debug-dump">Debug Dump</a></h1>
<p><code>DcAutomationUtils::DumpToLog()</code> can dump a <code>FDcPropertyDatum</code> to a string representation, in which <code>FDcPropertyDatum</code> is simply a <code>(FProperty</code>, <code>void*</code>) fat pointer tuple that can represent anything in the property system:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FVector Vec(1.0f, 2.0f, 3.0f);
FDcPropertyDatum VecDatum(TBaseStructure&lt;FVector&gt;::Get(), &amp;Vec);

DcAutomationUtils::DumpToLog(VecDatum);
</code></pre>
<p>Output would be:</p>
<pre><code>-----------------------------------------
# Datum: 'ScriptStruct', 'Vector'
&lt;StructRoot&gt; 'Vector'
|---&lt;Name&gt; 'X'
|---&lt;Float&gt; '1.000000'
|---&lt;Name&gt; 'Y'
|---&lt;Float&gt; '2.000000'
|---&lt;Name&gt; 'Z'
|---&lt;Float&gt; '3.000000'
&lt;StructEnd&gt; 'Vector'
-----------------------------------------
</code></pre>
<p>Additionally we wrapped this into <code>gDcDebug</code> that can be invoked in MSVC immediate window. Calling it during debug would dump into MSVC <strong>Output</strong> window:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Automation/DcAutomationUtils.h
struct DATACONFIGCORE_API FDcDebug
{
    FORCENOINLINE void DumpStruct(char* StructNameChars, void* Ptr);
    FORCENOINLINE void DumpObject(UObject* Obj);
    FORCENOINLINE void DumpDatum(void* DatumPtr);
};

/// Access `gDcDebugg` in MSVC immediate window:
///
/// - in monolith builds:
/// gDcDebug.DumpObject(Obj)
///
/// - in DLL builds prefix with dll name:
/// ({,,UE4Editor-DataConfigCore}gDcDebug).DumpObject(ObjPtr)

extern FDcDebug gDcDebug;
</code></pre>
<p>Here's an animated demo showing dumping the vector above <em>during debug break</em> in MSVC:</p>
<p><img src="Examples/Images/Examples-DebugDumpVecDatum.png" alt="Examples-DebugDumpVecDatum" /></p>
<p>The full expression to evaluate is:</p>
<pre><code>({,,UE4Editor-DataConfigCore}gDcDebug).DumpDatum(&amp;VecDatum)
</code></pre>
<p>We need DLL name to locate <code>gDcDebug</code> in a non monolith build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration"><a class="header" href="#integration">Integration</a></h1>
<p>At the moment it supports these the engine versions below:</p>
<ul>
<li>UE 4.25</li>
<li>UE 4.26</li>
<li>UE 4.27</li>
<li>UE 5 (tested on commit <code>e0fb0cfce32d</code> on <code>ue5-main</code> branch)</li>
</ul>
<h2 id="integrate-dataconfig-plugin"><a class="header" href="#integrate-dataconfig-plugin">Integrate <code>DataConfig</code> Plugin</a></h2>
<p>The easiest way to try out DataConfig is to add it as a plugin into your C++ project.  In this section we'll walk through the steps of integrating DataConfig plugin into a empty UE C++ Project.</p>
<ol>
<li>
<p>Get a copy of <a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig">the repository</a>. Then copy  <code>./DataConfig</code> (where <code>DataConfig.uplugin</code> is located) into your project's <code>Plugins</code> directory.</p>
</li>
<li>
<p><strong>Delete <code>DataConfig\Source\DataConfigHeadless</code></strong> folder. It has a <code>DataConfigHeadless.Target.cs</code> file which is a hack to build a headless binary during development. <strong>This step is crucial or you your project won't build</strong>.</p>
</li>
<li>
<p>Restart your project. There should be a prompt to compile plugin sources. Confirm and wait until your project launches. Then open <code>Settings -&gt; Plugins</code> you should see <strong>Data Config</strong> listed under Project Editor category.</p>
<p><img src="Images/Integration-DataConfigPlugin.png" alt="Integration-DataConfigPlugin" /></p>
</li>
<li>
<p>The plugin comes with a set of tests. Open menu <code>Window -&gt; Developer Tools  -&gt; Session Frontend</code>. Find and run the <code>DataConfig</code> tests and it should all pass.</p>
<p><img src="Images/Integration-DataConfigAutomations.png" alt="Integration-DataConfigAutomations" /></p>
</li>
</ol>
<h2 id="integrate-dataconfigcore-module"><a class="header" href="#integrate-dataconfigcore-module">Integrate <code>DataConfigCore</code> Module</a></h2>
<p>DataConfig is packed into a plugin to bundle automation tests with a few assets. You're encouraged to integrate only the <code>DataConfigCore</code> module. It contains all core features with minimal dependencies. </p>
<p>Most projects should has a editor module already setup. In this section we'll go through the steps of integrating <code>DataConfigCore</code> and build it with the project's <code>FooProjectEditor</code> module.</p>
<ol>
<li>
<p>Get a copy of this repository. Then copy <code>DataConfig/Source/DataConfigCore</code> into your project's <code>Source</code> directory.</p>
</li>
<li>
<p>Edit <code>FooProjectEditor.Build.cs</code> add add <code>DataConfigCore</code> as an extra module:</p>
<pre><code class="language-c++">using UnrealBuildTool;

public class FooProjectEditor : ModuleRules
{
    public FooProjectEditor(ReadOnlyTargetRules Target) : base(Target)
    {
        PublicDependencyModuleNames.AddRange(new string[] { 
			//...
            &quot;DataConfigCore&quot;,	// &lt;- add this
            });
    }
}
</code></pre>
</li>
<li>
<p>DataConfig needs to be explicitly initialized before use. Find <code>FooProjectEditor</code> module's start up and shut down methods and setup DataConfig accordingly.</p>
<pre><code class="language-c++">#include &quot;DataConfig/DcEnv.h&quot;
#include &quot;DataConfig/Automation/DcAutomationUtils.h&quot;

void FFooProjectEditorModule::StartupModule()
{
    // ...
    DcStartUp(EDcInitializeAction::SetAsConsole);
    // dump a FVector to try it out
    FVector Vec(1.0f, 2.0f, 3.0f);
    FDcPropertyDatum VecDatum(TBaseStructure&lt;FVector&gt;::Get(), &amp;Vec);

    DcAutomationUtils::DumpToLog(VecDatum);
}

void FFooProjectEditorModule::ShutdownModule()
{
    // ...
	DcShutDown();
}
</code></pre>
</li>
<li>
<p>Rebuild the project and restart the editor. Open <code>Output Log</code> and use <code>LogDataConfigCore</code> filter and find the dump output. </p>
<p><img src="Images/Integration-DataConfigCoreOutput.png" alt="Integration-DataConfigCoreOutput" /></p>
</li>
</ol>
<p>You can refer to <code>DataConfigEditorExtra</code> module for more detailed integration options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>This page documents the overall design, goals and reasoning around DataConfig.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>At the time we started this project we were looking for a JSON parser that:</p>
<ul>
<li>Supports a relaxed JSON spec, i.e. comment and trailing comma.</li>
<li>Supports custom deserialization logic, i.e. deserializes <code>FColor</code> from <code>#RRGGBBAA</code>.</li>
<li>Supports UE4 instanced sub objects and polymorphism.</li>
</ul>
<p>Ultimately we implemented all these in DataConfig. We also tried not to limit this to be a JSON parser but to provide a set of tools for reading-from and writing-to the property system. </p>
<p>If you are an Unreal Engine C++ developers that:</p>
<ul>
<li>Looking for alternative JSON reader/writer.</li>
<li>Looking for MsgPack serializer.</li>
<li>Looking for a textual configuration format.</li>
<li>Thinking of implementing custom textual/binary format.</li>
<li>Write code that deals with <code>FProperty</code> on a daily bases.</li>
</ul>
<p>You should try DataConfig and it's highly likely DataConfig will fit into your solution.</p>
<h2 id="manifesto"><a class="header" href="#manifesto">Manifesto</a></h2>
<ul>
<li>
<p>Deliver as a quality C++ source library.</p>
<p>DataConfig should ship with no UI nor tooling code. Users are expected to integrate only <code>DataConfigCore</code> as a source module. We intentionally limit the scope of DataConfig to a &quot;C++ Library&quot;. Our users should be proficient UE4 C++ programmers.</p>
<ul>
<li>DataConfig should ship with good testing and documentation coverage.</li>
<li>DataConfig follows idiomatic UE4 C++ conventions and has no external dependencies.</li>
<li><code>DataConfigCore</code> depends only on <code>Core</code> and <code>CoreUObject</code> and can be used in standalone <code>Program</code> targets.</li>
<li>DataConfig API are <code>UObject</code> free and stack friendly.</li>
<li>Built-in features serve as examples and sensible defaults. Users are expected to write on their own <code>Reader/Writer/Handlers</code>.</li>
</ul>
</li>
<li>
<p>Runtime performance is <em>not</em> our top priority.</p>
<p>We expect users to use DataConfig in an offline, editor only scenario. In this use case we favor some other aspects over runtime performance:</p>
<ul>
<li>Idiomatic. We follow <a href="https://docs.unrealengine.com/en-US/ProductionPipelines/DevelopmentSetup/CodingStandard/index.html" title="UE4 Coding Standard">UE4 c++ coding conventions</a> and keep core dependency to only <code>Core</code> and <code>CoreUObject</code>.</li>
<li>Friendly. When processing invalid data and invalid API usage DataConfig should not crash. It should fail explicitly with detailed context and diagnostics.</li>
<li>Small code size / fast compile time. DataConfig tries not to expose template API. <code>TDcJsonReader</code> is explicit instantiated with its definition in private files.</li>
<li>Light memory footprint. Our JSON parser does stream parsing and would <em>not</em> construct the loaded JSON document in memory at all.</li>
</ul>
</li>
<li>
<p>Works with whatever property system supports.</p>
<p>The idea is that DataConfig supports everything that can be tagged with <code>UCLASS/USTRUCT/UPROPERTY/UENUM</code> macros, which covers the full data model of the property system.</p>
<p>Fields such as weak object reference and delegates doesn't make much sense to be serialized into textual format. However it turns out supporting the full data model makes it suitable to some other tasks like debug dump and in-memory data wrangling.</p>
<p>This also means that DataConfig focuses only on reading from and writing into C++ data structures. For example we do not have a DOM or object like API for JSON at all. The only use case DataConfig supports is to deserialize from JSON into native C++ objects.</p>
</li>
</ul>
<h2 id="acknowledgement"><a class="header" href="#acknowledgement">Acknowledgement</a></h2>
<ul>
<li>References <a href="https://serde.rs/" title="SerDe">serde.rs</a> on API and the <code>SerDe</code> acronym.</li>
<li>References <a href="https://github.com/jacobdufault/fullserializer" title="jacobdufault/fullserializer">FullSerializer</a> and <a href="https://github.com/TeamSirenix/odin-serializer" title="TeamSirenix/odin-serializer">OdinSerializer</a> on API.</li>
<li>JSON parser/writer implementation and test cases references <a href="https://json.nlohmann.me" title="JSON for Modern C++">JSON for Modern C++ </a> and <a href="https://rapidjson.org/" title="RapidJSON">RapidJson</a>.</li>
<li>Integrated <a href="https://github.com/nst/JSONTestSuite" title="JSON Parsing Test Suite">nst/JSONTestSuite</a>.</li>
<li>Integrated <a href="https://github.com/kawanet/msgpack-test-suite" title="a dataset for testing msgpack library">kawanet/msgpack-test-suite</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-guides"><a class="header" href="#programming-guides">Programming Guides</a></h1>
<p>This section contains doc for programming DataConfig APIs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dataconfig-data-model"><a class="header" href="#dataconfig-data-model">DataConfig Data Model</a></h1>
<p>Conceptually the DataConfig data model is defined by 3 C++ types:</p>
<ol>
<li><code>EDcDataEntry</code> - enum covers every possible data type.</li>
<li><code>FDcReader</code> - methods to read from the data model.</li>
<li><code>FDcWriter</code> - methods to write into the data model.</li>
</ol>
<p>And that's it. The obvious missing thing is a DOM like object that you can random access and serialize into -  we choose to not implement that and it's crucial to understand this to get to know how DataConfig works.</p>
<h2 id="edcdataentry"><a class="header" href="#edcdataentry"><code>EDcDataEntry</code></a></h2>
<p>The enum covers all possible types:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/DcTypes.h
UENUM()
enum class EDcDataEntry : uint16
{
	Nil,

	Bool,
	Name,
	String,
	Text,
	Enum,

	Float,
	Double,

	Int8,
	Int16,
	Int32,
	Int64,

	UInt8,
	UInt16,
	UInt32,
	UInt64,

	//	Struct
	StructRoot,
	StructEnd,

	//	Class
	ClassRoot,
	ClassEnd,

	//	Map
	MapRoot,
	MapEnd,

	//	Array
	ArrayRoot,
	ArrayEnd,

	//	Set,
	SetRoot,
	SetEnd,

	//	Reference
	ObjectReference,
	ClassReference,

	WeakObjectReference,
	LazyObjectReference,
	SoftObjectReference,
	SoftClassReference,
	InterfaceReference,

	//	Delegates
	Delegate,
	MulticastInlineDelegate,
	MulticastSparseDelegate,

	//	Field
	FieldPath,

	//	Extra
	Blob,

	//	Extension
	Extension,

	//	End
	Ended,
};
</code></pre>
<p>Most enumerators directly maps to a <code>FProperty</code> type:</p>
<ul>
<li><code>EDcDataEntry::Bool</code>  - <code>FBoolProperty</code></li>
<li><code>EDcDataEntry::Name</code> - <code>FNameProperty</code></li>
<li><code>EDcDataEntry::String</code> - <code>FStrProperty</code></li>
<li><code>EDcDataEntry::ArrayRoot/ArrayEnd</code>- <code>FArrayProperty</code></li>
</ul>
<p>It should've covered all possible <code>FProperty</code> types. There're some additions that has no direct <code>FProperty</code> mapping:</p>
<ul>
<li><code>EDcDataEntry::Nil</code> -  It's maps <code>null</code> in JSON, and it's also used to explicitly represent null object reference.</li>
<li><code>EDcDataEntry::Ended</code> - It's a phony type that is returned when there's no more data or reader/writer is in a invalid state.</li>
<li><code>EDcDataEntry::Blob</code> - It's an extension to allow direct memory read/write from given fields. </li>
<li><code>EDcDataEntry::Extension</code> - It's an extension that allows additional data formats. MsgPack reader/writer uses this to support its <code>extension</code> data types.</li>
</ul>
<h2 id="fdcreader"><a class="header" href="#fdcreader"><code>FDcReader</code></a></h2>
<p><code>FDcReader</code> is the one and only way to read from DataConfig data model. For every enumerator in <code>EDcDataEntry</code> there's a member method on <code>FDcReader</code> to from it.</p>
<p>Here we set up a simple struct trying out the reader methods:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.h
USTRUCT()
struct FDcTestExampleSimple
{
	GENERATED_BODY()

	UPROPERTY() FString StrField;
	UPROPERTY() int IntField;
};

// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcTestExampleSimple SimpleStruct;
SimpleStruct.StrField = TEXT(&quot;Foo Str&quot;);
SimpleStruct.IntField = 253;
</code></pre>
<p>Since we know exactly how the <code>FDcTestExampleSimple</code> looks like we can manually arrange the read calls:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcPropertyReader Reader{FDcPropertyDatum(&amp;SimpleStruct)};

DC_TRY(Reader.ReadStructRoot(&amp;Struct));   // `FDcTestExampleSimple` Struct Root

    DC_TRY(Reader.ReadName(&amp;FieldName));  // 'StrField' as FName
    DC_TRY(Reader.ReadString(&amp;StrValue)); // &quot;Foo STr&quot;

    DC_TRY(Reader.ReadName(&amp;FieldName));  // 'IntField' as FName
    DC_TRY(Reader.ReadInt32(&amp;IntValue));  // 253

DC_TRY(Reader.ReadStructEnd(&amp;Struct));    // `FDcTestExampleSimple` Struct Root
</code></pre>
<p>In the example above <code>FDcReader</code> behave like a iterator as each <code>ReadXXX()</code> call emits value and move the internal cursor into the next slot. In case we're reading a unknown structure, we can use <code>FReader::PeekRead()</code> to peek what's coming next.</p>
<h2 id="fdcwriter"><a class="header" href="#fdcwriter"><code>FDcWriter</code></a></h2>
<p><code>FDcWriter</code> is the counter part of writing into the data config model. To write into the example instance above:</p>
<pre><code class="language-c++">DC_TRY(Writer.WriteStructRoot(FDcStructStat{})); // `FDcTestExampleSimple` Struct Root

    DC_TRY(Writer.WriteName(TEXT(&quot;StrField&quot;)));      // 'StrField' as FName
    DC_TRY(Writer.WriteString(TEXT(&quot;Alt Str&quot;)));     // &quot;Foo STr&quot;

    DC_TRY(Writer.WriteName(TEXT(&quot;IntField&quot;)));      // 'IntField' as FName
    DC_TRY(Writer.WriteInt32(233));                  // 233

DC_TRY(Writer.WriteStructEnd(FDcStructStat{}));  // `FDcTestExampleSimple` Struct Root
</code></pre>
<p>There's also <code>FDcWriter::PeekRead()</code> to query whether it's possible to write given data type.</p>
<h2 id="sum-up"><a class="header" href="#sum-up">Sum Up</a></h2>
<p>DataConfig provide <code>FDcReader</code> and <code>FDcWriter</code> to access the property system. It can be considered as a friendly alternative to the property system API. This is also how we support <a href="Programming/../Formats/JSON.html" title="JSON">JSON</a> and <a href="Programming/../Formats/MsgPack.html" title="MsgPack">MsgPack</a> in an uniform API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Proper error handling is crucial to implement robust serialization as it needs to deal with unknown user input. DataConfig also provide diagnostic to help users quickly pin down common errors such as typos or missing colons in JSON. Here's an example:</p>
<pre><code># DataConfig Error: Enum name not found in enum type: EDcTestExampleEnum, Actual: 'Far'
- [JsonReader] --&gt; &lt;in-memory&gt;4:25
   2 |    {
   3 |        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
   4 |        &quot;EnumField&quot; : &quot;Far&quot;,
     |                           ^
   5 |        &quot;Colors&quot; : [
   6 |            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
- [PropertyWriter] Writing property: (FDcTestExampleStruct)$root.(EEDcTestExampleEnum)EnumField
</code></pre>
<p>Internally DataConfig applies a consistent error handling strategy across all API. User code is expected to follow along.</p>
<h2 id="returning-fdcresult"><a class="header" href="#returning-fdcresult">Returning <code>FDcResult</code></a></h2>
<p>The gist is that <strong>if a method can fail, it should return a <code>FDcResult</code></strong>. It's a simple struct:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/DcTypes.h
struct DATACONFIGCORE_API DC_NODISCARD FDcResult
{
    enum class EStatus : uint8
    {
        Ok,
        Error
    };

    EStatus Status;

    FORCEINLINE bool Ok() const
    {
        return Status == EStatus::Ok;
    }
};

//  See FDcReader's methods as example
// DataConfig/Source/DataConfigCore/Public/DataConfig/Reader/DcReader.h
struct DATACONFIGCORE_API FDcReader
{
    //...
    virtual FDcResult ReadBool(bool* OutPtr);
    virtual FDcResult ReadName(FName* OutPtr);
    virtual FDcResult ReadString(FString* OutPtr);
    virtual FDcResult ReadText(FText* OutPtr);
    virtual FDcResult ReadEnum(FDcEnumData* OutPtr);
    //...
};
</code></pre>
<p>Then use <code>DC_TRY</code> to call these kinds of functions. The macro itself does early return when result is not <code>Ok</code>:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/DcTypes.h
#define DC_TRY(expr)                        \
    do {                                    \
        ::FDcResult Ret = (expr);           \
        if (!Ret.Ok()) {                    \
            return Ret;                     \
        }                                   \
    } while (0)

//  Example of calling methods returning `FDcResult`
// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriterAPI&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    DC_TRY(Ctx.Writer-&gt;WriteStructRoot(FDcStructStat{ TEXT(&quot;Color&quot;), FDcStructStat::WriteCheckName }));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;B&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.B));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;G&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.G));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;R&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.R));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;A&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.A));

    DC_TRY(Ctx.Writer-&gt;WriteStructEnd(FDcStructStat{ TEXT(&quot;Color&quot;), FDcStructStat::WriteCheckName }));

    return DcOk();
}
</code></pre>
<p>This pattern is similar to <a href="https://ned14.github.io/outcome/">Outcome</a> and <a href="https://wg21.link/p0323">std::expected</a> except we give up using the return value. Return values should be passed through reference or pointers in function arguments.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p>When implementing a method that returns <code>FDcResult</code> you have 2 options:</p>
<ul>
<li>Return <code>DcOk()</code> on succeed.</li>
<li>Return <code>DC_FAIL(&lt;Catetory&gt;, &lt;ErrId&gt;)</code> on error.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcResult Succeed() {
    // succeed
    return DcOk();
}

FDcResult Fail() {
    // fail !
    return DC_FAIL(DcDCommon, Unexpected1) &lt;&lt; &quot;My Custom Message&quot;;
}
</code></pre>
<p>In the examples above <code>DcDCommon</code> and <code>Unexpected1</code> are called <strong>error category</strong> and <strong>error id</strong> respectively. <code>DcDCommon</code> is a built-in error category:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Diagnostic/DcDiagnosticCommon.h
namespace DcDCommon
{
static const uint16 Category = 0x1;

enum Type : uint16
{
    //...
    Unexpected1,
};

} // namespace DcDCommon

// DataConfig/Source/DataConfigCore/Private/DataConfig/Diagnostic/DcDiagnosticCommon.cpp
namespace DcDCommon
{
static FDcDiagnosticDetail _CommonDetails[] = {
    // ...
    { Unexpected1, TEXT(&quot;Unexpected: '{0}'&quot;) },
};
</code></pre>
<p>Note that we can pipe argument into the diagnostic. The diagnostic reported by invoking <code>Fail()</code> would be like:</p>
<pre><code>* # DataConfig Error: Unexpected: 'My Custom Message'
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>DataConfig uses <code>FDcResult</code>, <code>DC_TRY</code>, <code>DC_FAIL</code> for error handling. It's lightweight and relatively easy to grasp. There's still some limitations though:</p>
<ul>
<li><code>FDcResult</code> occupied the return position making passing value to parent a bit cumbersome.</li>
<li>For now we always stop as the first error. There's no plan to support error recovery.</li>
</ul>
<p>Some closing notes:</p>
<ul>
<li>Reported diagnostics get queued. You'll need to call <code>FDcEnv::FlushDiags()</code> to flush them to consumers.</li>
<li>See <code>DcDiagnosticExtra.h/cpp</code> for how to register user category.</li>
<li>See <code>DcEditorExtraModule.cpp - FDcMessageLogDiagnosticConsumer</code> for custom diagnostic handler and formatting.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="env"><a class="header" href="#env">Env</a></h1>
<p>DataConfig put most global state into a stack of <code>FDcEnv</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/DcEnv.h
struct DATACONFIGCORE_API FDcEnv
{
    TArray&lt;FDcDiagnostic&gt; Diagnostics;

    TSharedPtr&lt;IDcDiagnosticConsumer&gt; DiagConsumer;

    TArray&lt;FDcReader*&gt; ReaderStack;
    TArray&lt;FDcWriter*&gt; WriterStack;

    bool bExpectFail = false;   // mute debug break

    FDcDiagnostic&amp; Diag(FDcErrorCode InErr);

    void FlushDiags();

    FORCEINLINE FDcDiagnostic&amp; GetLastDiag() 
    {
        checkf(Diagnostics.Num(), TEXT(&quot;&lt;empty diagnostics&gt;&quot;));
        return Diagnostics.Last();
    }

    ~FDcEnv();
};
</code></pre>
<p>DataConfig needs explicit initializatioon before use. This is done through manually <code>DcStartUp()</code>. There's also a paired <code>DcShutdown()</code> that should be called when DataConfig isn't used anymore. Here's an example:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DcEditorExtraModule.cpp
void FDcEditorExtraModule::StartupModule()
{
    UE_LOG(LogDataConfigCore, Log, TEXT(&quot;DcEditorExtraModule module starting up&quot;));
    DcRegisterDiagnosticGroup(&amp;DcDExtra::Details);
    DcRegisterDiagnosticGroup(&amp;DcDEditorExtra::Details);

    DcStartUp(EDcInitializeAction::Minimal);
    //...
}

void FDcEditorExtraModule::ShutdownModule()
{
    DcShutDown();
    //...
}
</code></pre>
<p>The active <code>FDcEnv</code> is accessed by calling global function <code>DcEnv()</code>. Inside the Env:</p>
<ul>
<li><code>Diagnostics</code>: all diagnostics are flushed into env.</li>
<li><code>DiagConsumer</code>: diagnostic handler, format and print diagnostic to log or <code>MessageLog</code> or even on screen.</li>
<li><code>ReaderStack/WriterStack</code>: used to pass along reader/writer down the callstack. See <code>FScopedStackedReader</code> uses for example.</li>
<li>... and everything else.</li>
</ul>
<p>You can use <code>DcPushEnv()</code> to create new env then destroy it calling <code>DcPopEnv()</code>. At this moment it's mostly used to handle reentrant during serialization. See <code>FDcScopedEnv</code> uses for examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="readerwriter"><a class="header" href="#readerwriter">Reader/Writer</a></h1>
<p>FDcReader/FDcWriter defines the set of API for accessing DataConfig data model. Here's a check list for implementing a reader/writer:</p>
<ol>
<li>Implement <code>GetID()/ClassID()</code> for RTTI.</li>
<li>Implement <code>PeekRead()/PeekWriter()</code> and selected set of <code>ReadXXX()/WriteXXX()</code>.</li>
<li>Implement <code>FormatDiagnostic()</code> for error reporting.</li>
</ol>
<p>You should look at builtin implementation for references. Here's some general rules and caveats:</p>
<ul>
<li>
<p><code>PeekRead()/PeekWrite()</code> should act like it's side-effect free.</p>
<p>This means that it's OK to call <code>PeekRead()/PeekWrite()</code> multiple times. In comparison access methods like <code>ReadBool()/WriteBool()</code> consume the data and alternate internal state. Note that under the hood it might do anything. Both returns <code>FDcResult</code> so the peek can fail. The reason behind this is that calling <code>PeekRead()/PeekWrite()</code> is totally optional. In <code>FDcJsonReader::PeekRead()</code> we do parsing and cache the parsed result to follow this convention.</p>
</li>
<li>
<p><code>CastByID()</code> does not respect inheritance hierarchy.</p>
<p>We have this very minimal RTTI implemetantion that only allow casting to the exact type.</p>
</li>
<li>
<p>Implement a subset of the data model.</p>
<p>The API is designed in a way that it covers the whole Property System. It's also a super set that can express common formats like JSON/MsgPack. For example JSON don't have struct, class or set. It's actually the job of Serializer/Deserializer to convert between these subsets to the property system.</p>
</li>
</ul>
<h2 id="builtin-readerwriter"><a class="header" href="#builtin-readerwriter">Builtin Reader/Writer</a></h2>
<p>We have 3 major pairs of reader/writers:</p>
<ul>
<li><code>FDcPropertyReader/FDcPropertyWriter</code> - Accesing Unreal Engin property system.</li>
<li><code>FDcJsonReader/FDcJsonWriter</code> - JSON support.</li>
<li><code>FDcMsgPackReader/FDcMsgPackWriter</code> - MsgPack support.</li>
</ul>
<p>These are all talked about in details in the <a href="Programming/../Formats/index.html" title="Formats">formats section</a>. We'll go through other builtin Reader/Writers below.</p>
<h2 id="fdcpipevisitor-and-fdcprettyprintwriter"><a class="header" href="#fdcpipevisitor-and-fdcprettyprintwriter"><code>FDcPipeVisitor</code> and <code>FDcPrettyPrintWriter</code></a></h2>
<p><code>FDcPipeVisitor</code> takes a <code>FDcReader</code> and a <code>FDcWriter</code> then start peek-read-write loop until it peeks <code>EDcDataEntry::Ended</code> from reader or an error happens </p>
<p>Then there's <code>FDcPrettyPrintWriter</code> that dumps everything that got write to it as string.</p>
<p>Combining these two we get a way to dump arbitrary <code>FDcReader</code> into a string!. This is how built-in debug dump features are implemented:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Private/DataConfig/Automation/DcAutomationUtils.cpp
void DumpToOutputDevice(...)
{
    //...
    FDcPropertyReader PropReader(Datum);
    FDcPrettyPrintWriter PrettyWriter(Output);
    FDcPipeVisitor PrettyPrintVisit(&amp;PropReader, &amp;PrettyWriter);

    if (!PrettyPrintVisit.PipeVisit().Ok())
        ScopedEnv.Get().FlushDiags();
    //...
}
</code></pre>
<p><code>FDcPipeVisitor</code> is a handy utility that we use it extensively through the code base for various cases. Try <code>FDcPipeVisitor</code> when you got a reader/writer pair.</p>
<p>There's also <code>FNoopWriter</code> takes every write and do nothing with it.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Reader/Writers can also be composited and nested:</p>
<ul>
<li><code>FDcWeakCompositeWriter</code> is a writer that multiplex into a list of writers. You can combine an arbitrary writer with a <code>FPrettyPrintWriter</code> then get a tracing writer.</li>
<li><code>FDcPutbackReader/FPutbackWriter</code>: Reader/writers don't support lookahead. It can only peek next item's type but not value. This class is used to support limited lookahead by <em>putting back</em> read value. We'll see it being used in implementing custom deserializer handlers.</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Implement new <code>FDcReader/FDcWriter</code> when you want to support a new file format. You can also write utility reader/writer that composite existing ones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serializerdeserializer"><a class="header" href="#serializerdeserializer">Serializer/Deserializer</a></h1>
<p>Serializer/Deserializer are built on top of the data model to convert between external format and Unreal Engine property system.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>A company class to the deserializer is <code>FDcDeserializeContext</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Deserialize/DcDeserializeTypes.h
struct DATACONFIGCORE_API FDcDeserializeContext
{
    //...
    FDcDeserializer* Deserializer;
    FDcReader* Reader;
    FDcPropertyWriter* Writer;
    //...
};
</code></pre>
<p>Note how it takes an <code>FDcReader</code> and a <code>FPropertyWriter</code> - we're deserializing arbitrary format into the property system.</p>
<p>The mirrored version for serializer is <code>FDcSerializeContext</code>.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Serialize/DcSerializeTypes.h
struct DATACONFIGCORE_API FDcSerializeContext
{
    //...
    FDcSerializer* Serializer = nullptr;
    FDcPropertyReader* Reader = nullptr;
    FDcWriter* Writer = nullptr;
    //...
};
</code></pre>
<p>Note how it takes an <code>FDcWriter</code> and a <code>FDcPropertyReader</code> - we're serializing data from the property system to arbitrary format.</p>
<p>Since serializer and deserializer have extremely similar APIs, we're showing examples using deserializer below from here. </p>
<h2 id="handlers"><a class="header" href="#handlers">Handlers</a></h2>
<p>Say that we're deserializing a JSON object into a <code>USTRUCT</code> instance. The <code>FDcJsonReader</code> implements <code>ReadMapRoot()/ReadMapEnd()</code> but doesn't have <code>ReadStructRoot()/ReadStructEnd()</code>. To make the conversion we basically want to map <code>ReadMap()</code> and calls into <code>WriteStruct()</code> calls. This is where <strong>handlers</strong> come into play:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/SerDe/DcDeserializeCommon.inl
FDcResult DcHandlerDeserializeMapToStruct(FDcDeserializeContext&amp; Ctx)
{
    FDcStructAccess Access;
    DC_TRY(Ctx.Reader-&gt;ReadMapRoot());
    DC_TRY(Ctx.Writer-&gt;WriteStructRootAccess(Access));

    EDcDataEntry CurPeek;
    while (true)
    {
        DC_TRY(Ctx.Reader-&gt;PeekRead(&amp;CurPeek));
        if (CurPeek == EDcDataEntry::MapEnd)
            break;

        FName FieldName;
        DC_TRY(Ctx.Reader-&gt;ReadName(&amp;FieldName));
        DC_TRY(Ctx.Writer-&gt;WriteName(FieldName));

        DC_TRY(DcDeserializeUtils::RecursiveDeserialize(Ctx));
    }

    DC_TRY(Ctx.Reader-&gt;ReadMapEnd());
    DC_TRY(Ctx.Writer-&gt;WriteStructEnd());

    return DcOk();
}

// DataConfig/Source/DataConfigCore/Private/DataConfig/Deserialize/Handlers/Json/DcJsonCommonDeserializers.cpp
FDcResult HandlerStructRootDeserialize(FDcDeserializeContext&amp; Ctx)
{
    return DcHandlerDeserializeMapToStruct(Ctx);
}
</code></pre>
<p>Note that <code>Ctx.Reader</code> is a <code>FDcReader</code> that can be any derived class, while <code>Ctx.Writer</code> is always a <code>FDcPropertyWriter</code>. Deserialize handlers have an uniform signature:</p>
<pre><code class="language-c++">using FDcDeserializeDelegateSignature = FDcResult(*)(FDcDeserializeContext&amp; Ctx);
</code></pre>
<h2 id="deserializer-setup"><a class="header" href="#deserializer-setup">Deserializer Setup</a></h2>
<p>Note how deserialize handler above doesn't specify when it should be invoked. 
These info are described in <code>FDcDeserializer</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Deserialize/DcDeserializer.h
struct DATACONFIGCORE_API FDcDeserializer : public FNoncopyable
{
    //...
    FDcResult Deserialize(FDcDeserializeContext&amp; Ctx);

    void AddDirectHandler(FFieldClass* PropertyClass, FDcDeserializeDelegate&amp;&amp; Delegate);
    void AddDirectHandler(UClass* PropertyClass, FDcDeserializeDelegate&amp;&amp; Delegate);
    void AddPredicatedHandler(FDcDeserializePredicate&amp;&amp; Predicate, FDcDeserializeDelegate&amp;&amp; Delegate);
    //...
};
</code></pre>
<p>Comparing to <code>FDcDeserializeContext</code>, which describes data needed for a single run, 
<code>FDcDeserializer</code> contains info on what handlers to execute. Deserializer can also be reused across multiple
runs.</p>
<p>We use &quot;direct handlers&quot; to cover common cases:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Private/DataConfig/Deserialize/DcDeserializerSetup.cpp
Deserializer.AddDirectHandler(FArrayProperty::StaticClass(), FDcDeserializeDelegate::CreateStatic(HandlerArrayDeserialize));
Deserializer.AddDirectHandler(FSetProperty::StaticClass(), FDcDeserializeDelegate::CreateStatic(HandlerSetDeserialize));
Deserializer.AddDirectHandler(FMapProperty::StaticClass(), FDcDeserializeDelegate::CreateStatic(HandlerMapDeserialize));
</code></pre>
<p>These basically says that &quot;when running into array, set, map properties, use these provided handlers&quot;. </p>
<p>Then we have &quot;predicated handler&quot; that get tested very early. This is how we allow custom conversion logic
setup for very specific class:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeColor.cpp
EDcDeserializePredicateResult PredicateIsColorStruct(FDcDeserializeContext&amp; Ctx)
{
    UScriptStruct* Struct = DcPropertyUtils::TryGetStructClass(Ctx.TopProperty());
    return Struct &amp;&amp; Struct == TBaseStructure&lt;FColor&gt;::Get()
        ? EDcDeserializePredicateResult::Process
        : EDcDeserializePredicateResult::Pass;
}

// ...
Ctx.Deserializer-&gt;AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(HandlerColorDeserialize)
);
</code></pre>
<p>By convention the current deserializing property can be retrieved with <code>Ctx.TopProperty()</code>. 
Here we simply test if it's a <code>UScriptStruct</code> that's equal to <code>FColor::StaticClass()</code>.
If that's the case execute the provided handler.</p>
<h2 id="sum-up-1"><a class="header" href="#sum-up-1">Sum Up</a></h2>
<p>Serializer/Deserializer are built on top of Reader/Writer, to convert between Unreal Engine 
property system and external data formats.</p>
<ul>
<li><code>FDcSerializeContext/FDcDeserializeContext</code> contains data.</li>
<li><code>FDcSerializer/FDcDeserializer</code> contains setup.</li>
<li>Implement <code>FDcDeserializeDelegate/FDcSerializeDelegate</code> and <code>FDcDeserializePredicate/FDcSerializePredicate</code>
pair for custom conversion logic.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formats"><a class="header" href="#formats">Formats</a></h1>
<p>This section contains documentation for supported formats.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">JSON</a></h1>
<p><a href="https://www.json.org/json-en.html" title="Introducing JSON">JSON</a> is likely the most popular data interchange format. Unreal Engine already supports it with <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/JsonUtilities/" title="JsonUtilities"><code>JsonUtilities</code></a> and some related modules. We provide an alternative implementation along with DataConfig.</p>
<h2 id="json-reader"><a class="header" href="#json-reader">JSON Reader</a></h2>
<p><code>FDcJsonReader</code> is the DataConfig JSON reader:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;Str&quot;:    &quot;Fooo&quot;,
        &quot;Number&quot;: 1.875,
        &quot;Bool&quot;:   true
    } 
)&quot;);

FDcJsonReader Reader(Str);

//  calling read methods
FString KeyStr;
FString GotStr;
double GotNumber;
bool GotBool;

DC_TRY(Reader.ReadMapRoot());

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadString(&amp;GotStr));

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadDouble(&amp;GotNumber));

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadBool(&amp;GotBool));

DC_TRY(Reader.ReadMapEnd());

//  validate results
check(GotStr == TEXT(&quot;Fooo&quot;));
check(GotNumber == 1.875);
check(GotBool == true);
</code></pre>
<p>In the example above we deserialized a <code>JSON</code> object from string. The first and last calls are <code>ReadMapRoot</code> and <code>ReadMapEnd</code>, which are also used to read Unreal's <code>TMap</code> properties. The difference is that UE's <code>TMap</code> is strictly typed while JSON object values can have arbitrary type. This means that if you use <code>FDcPipeVisitor</code> to pipe a <code>FDcJsonReader</code> into a <code>FDcPropertyWriter</code> it won't work.</p>
<p>Remember that DataConfig data model is designed to support conversion between subsets within the data model. As long as you can use <code>FDcReader/FDcWriter</code> API to describe the format you want to serialize you're good to go. Mapping and conversion between these different shapes of reader/writers are handled by <a href="Formats/../Programming/SerializerDeserializer.html">deserializers</a>.</p>
<p>Some additional caveats:</p>
<ul>
<li>Similar to stock <code>TJsonReader</code>, we provide <code>TDcJsonReader</code> with 2 specializations:
<ul>
<li>Usually you just use <code>FDcJsonReader</code> that reads from <code>FString, TCHAR*</code>.</li>
<li>Under the hood there're <code>FDcAnsiJsonReader</code> that reads ANSICHAR string
and <code>FDcWideJsonReader</code> that reads WIDECHAR string.</li>
</ul>
</li>
<li>We support a relaxed superset of JSON:
<ul>
<li>Allow C Style comments, i.e <code>/* block */</code> and <code>// line</code> .</li>
<li>Allow trailing comma, i.e <code>[1,2,3,],</code> .</li>
<li>Allow non object root. You can put a list as the root, or even string, numbers.</li>
</ul>
</li>
<li>Number parsing are delegated to Unreal's built-ins to reduce dependencies. We might change this in the future.
<ul>
<li>Parse numbers: <code>TCString::Atof/Strtoi/Strtoi64</code></li>
</ul>
</li>
</ul>
<h2 id="json-writer"><a class="header" href="#json-writer">JSON Writer</a></h2>
<p><code>FDcJsonWriter</code> is the DataConfig JSON writer:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcJsonWriter Writer;

DC_TRY(Writer.WriteMapRoot());

    DC_TRY(Writer.WriteString(TEXT(&quot;Str&quot;)));
    DC_TRY(Writer.WriteString(TEXT(&quot;Fooo&quot;)));

    DC_TRY(Writer.WriteString(TEXT(&quot;Number&quot;)));
    DC_TRY(Writer.WriteFloat(1.875f));

    DC_TRY(Writer.WriteString(TEXT(&quot;Bool&quot;)));
    DC_TRY(Writer.WriteBool(true));

DC_TRY(Writer.WriteMapEnd());
Writer.Sb.Append(TCHAR('\n'));

FString Str = TEXT(R&quot;(
    {
        &quot;Str&quot; : &quot;Fooo&quot;,
        &quot;Number&quot; : 1.875,
        &quot;Bool&quot; : true
    }
)&quot;);

//  validate results
check(DcReindentStringLiteral(Str) == Writer.Sb.ToString());
return DcOk();
</code></pre>
<ul>
<li>Similar to stock <code>TJsonWriter</code>, we provide <code>TDcJsonWriter</code> with 2 specializations:
<ul>
<li>Usually you just use <code>FDcJsonWriter</code> that writes <code>FString, TCHAR*</code>.</li>
<li>Under the hood there're <code>FDcAnsiJsonWriter</code> that writes ANSICHAR string
and <code>FDcWideJsonWriter</code> that writes WIDECHAR string.</li>
</ul>
</li>
<li>It takes a <code>Config</code> object that specify formatting settings like indentation size and new lines.
<ul>
<li><code>FDcPrettyJsonWriter</code> is a type alias that formats indented JSON.</li>
<li><code>FDcCondensedJsonWriter</code> is a type alias that format single line, condensed output. </li>
</ul>
</li>
<li><code>FDcJsonWriter</code> owns the output string buffer, in <code>FDcJsonWriter::Sb</code>.
<ul>
<li>By writing to a single writer and appending a new line after each serialization, we can output <a href="http://ndjson.org/" title="ndjson">NDJSON</a>. </li>
<li>Our JSON reader is also flexible enough to directly load NDJSON. See <a href="Formats/../Advanced/Benchmark.html">corpus benchmark</a>. </li>
</ul>
</li>
</ul>
<h2 id="json-serializedeserialize"><a class="header" href="#json-serializedeserialize">JSON Serialize/Deserialize</a></h2>
<p>DataConfig bundles a set of JSON serialize and deserialize handlers, which are all roundtrip-able:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
#include &quot;DataConfig/Deserialize/DcDeserializerSetup.h&quot;

// ...
//  create and setup a deserializer
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);

//  create and setup a serializer
FDcSerializer Serializer;
DcSetupJsonSerializeHandlers(Serializer);
</code></pre>
<h3 id="schema"><a class="header" href="#schema">Schema</a></h3>
<p>JSON types get mapped into DataConfig data model in a very unsurprising way.</p>
<table><thead><tr><th style="text-align: left">JSON Type</th><th>DcDataEntry</th></tr></thead><tbody>
<tr><td style="text-align: left">Boolean</td><td>Bool</td></tr>
<tr><td style="text-align: left">Null</td><td>Nil</td></tr>
<tr><td style="text-align: left">String</td><td>String, Name, Text, Enum</td></tr>
<tr><td style="text-align: left">Number</td><td>(All numerics)</td></tr>
<tr><td style="text-align: left">Array</td><td>Array, Set</td></tr>
<tr><td style="text-align: left">Object</td><td>Class, Struct, Map</td></tr>
</tbody></table>
<p>Here's an example:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;BoolField&quot; : true,
        &quot;NameField&quot; : &quot;AName&quot;,
        &quot;StringField&quot; : &quot;AStr&quot;,
        &quot;TextField&quot; : &quot;AText&quot;,
        &quot;EnumField&quot; : &quot;Tard&quot;,

        &quot;FloatField&quot; : 17.5,
        &quot;DoubleField&quot; : 19.375,

        &quot;Int8Field&quot; : -43,
        &quot;Int16Field&quot; : -2243,
        &quot;Int32Field&quot; : -23415,
        &quot;Int64Field&quot; : -1524523,

        &quot;UInt8Field&quot; : 213,
        &quot;UInt16Field&quot; : 2243,
        &quot;UInt32Field&quot; : 23415,
        &quot;UInt64Field&quot; : 1524523,
    }
)&quot;);

//  deserialized equivelent

FDcTestStruct1 Expect;
Expect.BoolField = true;
Expect.NameField = TEXT(&quot;AName&quot;);
Expect.StringField = TEXT(&quot;AStr&quot;);
Expect.TextField = FText::FromString(TEXT(&quot;AText&quot;));
Expect.EnumField = EDcTestEnum1::Tard;

Expect.FloatField = 17.5f;
Expect.DoubleField = 19.375;

Expect.Int8Field = -43;
Expect.Int16Field = -2243;
Expect.Int32Field = -23415;
Expect.Int64Field = -1524523;

Expect.UInt8Field = 213;
Expect.UInt16Field = 2243,
Expect.UInt32Field = 23415;
Expect.UInt64Field = 1524523;
</code></pre>
<h3 id="enum-flags"><a class="header" href="#enum-flags">Enum Flags</a></h3>
<p><code>UENUM</code> that get marked with <code>Bitflags</code> meta are deserialized from a list of strings:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Public/DcTestDeserialize.h
UENUM(meta = (Bitflags))
enum class EDcTestEnumFlag :uint32
{
    None    = 0,
    One     = (1 &lt;&lt; 0),
    Two     = (1 &lt;&lt; 1),
    //...
};
ENUM_CLASS_FLAGS(EDcTestEnumFlag);

// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;EnumFlagField1&quot; : [],
        &quot;EnumFlagField2&quot; : [&quot;One&quot;, &quot;Three&quot;, &quot;Five&quot;],
    }
)&quot;);

//  deserialized equivelent
FDcTestStructEnumFlag1 Expect;
Expect.EnumFlagField1 = EDcTestEnumFlag::None;
Expect.EnumFlagField2 = EDcTestEnumFlag::One | EDcTestEnumFlag::Three | EDcTestEnumFlag::Five;
</code></pre>
<h3 id="sub-objects"><a class="header" href="#sub-objects">Sub Objects</a></h3>
<p>By default we treat <code>UOBJECT</code> marked with <code>DefaultToInstanced, EditInlineNew</code> and <code>UPROPERTY</code> marked with <code>Instanced</code> as sub object. In this case we'll actually instantiate new object during deserialization, using <code>Ctx.TopObject()</code> as parent:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Public/DcTestProperty.h
UCLASS(BlueprintType, EditInlineNew, DefaultToInstanced)
class UDcBaseShape : public UObject
{
    //...
    UPROPERTY() FName ShapeName;
};

UCLASS()
class UDcShapeBox : public UDcBaseShape
{
    //...
    UPROPERTY() float Height;
    UPROPERTY() float Width;
};

UCLASS()
class UDcShapeSquare : public UDcBaseShape
{
    //...
    UPROPERTY() float Radius;
};

// DataConfig/Source/DataConfigTests/Public/DcTestDeserialize.h
USTRUCT()
struct FDcTestStructShapeContainer1
{
    GENERATED_BODY()

    UPROPERTY() UDcBaseShape* ShapeField1;
    UPROPERTY() UDcBaseShape* ShapeField2;
    UPROPERTY() UDcBaseShape* ShapeField3;
}USTRUCT()
struct FDcEditorExtraTestObjectRefs1
{
    GENERATED_BODY()

    UPROPERTY() UObject* ObjField1;
    UPROPERTY() UObject* ObjField2;
    UPROPERTY() UObject* ObjField3;
    UPROPERTY() UObject* ObjField4;
};

// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ShapeField1&quot; :  {
            &quot;$type&quot; : &quot;DcShapeBox&quot;,
            &quot;ShapeName&quot; : &quot;Box1&quot;,
            &quot;Height&quot; : 17.5,
            &quot;Width&quot; : 1.9375
        },
        &quot;ShapeField2&quot; : {
            &quot;$type&quot; : &quot;DcShapeSquare&quot;,
            &quot;ShapeName&quot; : &quot;Square1&quot;,
            &quot;Radius&quot; : 1.75,
        },
        &quot;ShapeField3&quot; : null
    }
)&quot;);

//  deserialized equivelent
UDcShapeBox* Shape1 = NewObject&lt;UDcShapeBox&gt;();
Shape1-&gt;ShapeName = TEXT(&quot;Box1&quot;);
Shape1-&gt;Height = 17.5;
Shape1-&gt;Width = 1.9375;
Expect.ShapeField1 = Shape1;

UDcShapeSquare* Shape2 = NewObject&lt;UDcShapeSquare&gt;();
Shape2-&gt;ShapeName = TEXT(&quot;Square1&quot;);
Shape2-&gt;Radius = 1.75;
Expect.ShapeField2 = Shape2;

Expect.ShapeField3 = nullptr;
</code></pre>
<p>Note that criteria for sub object selection can be easily overridden with a new deserialize predicate or alternative <code>FDcPropertyConfig</code> when constructing the reader.</p>
<h3 id="object-and-class-reference"><a class="header" href="#object-and-class-reference">Object and Class Reference</a></h3>
<p>We support multiple ways of referencing a <code>UObject</code> in memory or serialized on disk:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Tests/DcTestDeserializeEditor.h
USTRUCT()
struct FDcEditorExtraTestObjectRefs1
{
    GENERATED_BODY()

    UPROPERTY() UObject* ObjField1;
    UPROPERTY() UObject* ObjField2;
    UPROPERTY() UObject* ObjField3;
    UPROPERTY() UObject* ObjField4;
};

// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Tests/DcTestDeserializeEditor.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ObjField1&quot; : &quot;DcEditorExtraNativeDataAsset'/DataConfig/DcFixture/DcTestNativeDataAssetAlpha.DcTestNativeDataAssetAlpha'&quot;,
        &quot;ObjField2&quot; : &quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;,
        &quot;ObjField3&quot; : 
        {
            &quot;$type&quot; : &quot;DcEditorExtraNativeDataAsset&quot;,
            &quot;$path&quot; : &quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;
        },
        &quot;ObjField4&quot; : null,
    }
)&quot;);

//  deserialized equivelent
UDcEditorExtraNativeDataAsset* DataAsset = Cast&lt;UDcEditorExtraNativeDataAsset&gt;(StaticLoadObject(
    UDcEditorExtraNativeDataAsset::StaticClass(),
    nullptr,
    TEXT(&quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;),
    nullptr
));

Expect.ObjField1 = DataAsset;
Expect.ObjField2 = DataAsset;
Expect.ObjField3 = DataAsset;
Expect.ObjField4 = nullptr;
</code></pre>
<p>In the example above, <code>ObjField1</code> uses the reference string that can be retrieved in editor context menu:</p>
<p><img src="Formats/Images/Deserialize-CopyReference.png" alt="Deserialize-CopyReference" /></p>
<p>For <code>ObjField2/ObjField3</code>  relative path to the <code>uasset</code> is used, but without file name suffix.</p>
<p>We also support class reference fields of <code>TSubclassOf&lt;&gt;</code>s:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.h
USTRUCT()
struct FDcTestStructSubClass1
{
    GENERATED_BODY()

    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField1;
    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField2;
    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField3;
};

// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StructSubClassField1&quot; : null,
        &quot;StructSubClassField2&quot; : &quot;ScriptStruct&quot;,
        &quot;StructSubClassField3&quot; : &quot;DynamicClass&quot;,
    }
)&quot;);

//  deserialized equivelent
FDcTestStructSubClass1 Expect;
Expect.StructSubClassField1 = nullptr;
Expect.StructSubClassField2 = UScriptStruct::StaticClass();
Expect.StructSubClassField3 = UDynamicClass::StaticClass();
</code></pre>
<p>Note that these do not support Blueprint classes. The direct reason is that Blueprint depends on <code>Engine</code> module and we'd like not to take dependency on in <code>DataConfigCore</code>. </p>
<p>We do have an example that supports Blueprint classes, see <code>DataConfigEditorExtra -  DcDeserializeBPClass.h/cpp</code></p>
<h2 id="soft-lazy-as-string"><a class="header" href="#soft-lazy-as-string">Soft Lazy as String</a></h2>
<p><code>DcSetupJsonSerializeHandlers()/DcSetupJsonDeserializeHandlers()</code> accepts an enum to setup alternative handlers. For now <code>StringSoftLazy</code> branch would setup special <code>FSoftObjectProperty/FLazyObjectProperty</code> handlers that directly serialize these into string. Comparing to this the default setup would always resolve the indirect reference into memory, which maybe isn't always desirable. </p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcTestStructRefs1 Source{};
UObject* TestsObject = StaticFindObject(UObject::StaticClass(), nullptr, TEXT(&quot;/Script/DataConfigTests&quot;));

Source.SoftField1 = TestsObject;
Source.LazyField1 = TestsObject;

FDcJsonWriter Writer;
DC_TRY(DcAutomationUtils::SerializeInto(&amp;Writer, FDcPropertyDatum(&amp;Source),
[](FDcSerializeContext&amp; Ctx) {
    DcSetupJsonSerializeHandlers(*Ctx.Serializer, EDcJsonSerializeType::StringSoftLazy);
}, DcAutomationUtils::EDefaultSetupType::SetupNothing));

//  serialized result
{
    // ...
    &quot;SoftField1&quot; : &quot;/Script/DataConfigTests&quot;,
    &quot;SoftField2&quot; : &quot;&quot;,
    &quot;LazyField1&quot; : &quot;C851179E-45A51045-0006AE91-F9B16EC0&quot;,
    &quot;LazyField2&quot; : &quot;00000000-00000000-00000000-00000000&quot;
}
</code></pre>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p>Here're some closing notes:</p>
<ul>
<li>
<p>For meta fields like <code>$type</code> it must be the first member, meaning object fields are order dependent. This means that the JSON we're supporting is a super set of standard JSON spec (again).</p>
</li>
<li>
<p>Bundled serializers and deserializers are designed to be roundtrip-able. For example in test <code>DataConfig.Core.RoundTrip.JsonRoundtrip1_Default</code>:</p>
<ol>
<li>Serialize <code>UDcTestRoundtrip1</code> instance <code>Source</code> into JSON.</li>
<li>Then deserialize JSON above into instance <code>Dest</code>.</li>
<li>Deep-compare <code>Source</code> and <code>Dest</code>. If they're equal them we say it's a roundtrip.</li>
</ol>
<p>Note that we carefully picked float and doubles in the test case, as it's tricky to support floating point roundtrip. We might consider supporting this with alternative float parse and format routines.</p>
</li>
<li>
<p>There're many data types that can not be deserialized from JSON, for example <code>Delegate/WeakObjectReference</code>. Remember that you always have the option to override or selectively enable handlers to support additional properties that make sense in your context. See <code>DcSetupJsonDeserializeHandlers()</code> body on how handlers are registered. You can skip this method and select the ones you want and provide additional handlers.</p>
</li>
<li>
<p>The JSON handlers are designed to <em>NOT</em> read anything during the deserialization. This is crucial since <code>USTRUCT</code> can contain uninitialized fields. For example:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        // pass
    } 
)&quot;);
FDcJsonReader Reader(Str);

FDcTestExampleSimple Dest;
FDcPropertyDatum DestDatum(&amp;Dest);

DC_TRY(DcAutomationUtils::DeserializeJsonInto(&amp;Reader, DestDatum));

check(Dest.StrField.IsEmpty());
//  but Dest.IntField contains uninitialized value
DcAutomationUtils::DumpToLog(DestDatum);

// dump results
&lt;StructRoot&gt; 'DcTestExampleSimple'
|---&lt;Name&gt; 'StrField'
|---&lt;String&gt; ''
|---&lt;Name&gt; 'IntField'
|---&lt;Int32&gt; '1689777552' // &lt;- arbitrary value
&lt;StructEnd&gt; 'DcTestExampleSimple'
</code></pre>
<p>This would cause trouble when you try read a pointer field during deserialization. Remember that primitive fields might be uninitialized during deserialization when implementing your own handlers.</p>
</li>
<li>
<p>One interesting trait of the pull/push styled API is that <code>FDcJsonReader</code> does <strong>not</strong> preemptively parse number into double and convert it to <code>int/float</code> later on. When reading a number token it would do the number parsing at call site. If <code>ReadIntX()</code> is called then the number is parsed as integer. If <code>ReadFloat()/ReadDouble()</code> is called the token will be parsed as floating point.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msgpack"><a class="header" href="#msgpack">MsgPack</a></h1>
<p><a href="https://msgpack.org/index.html" title="MsgPack">MsgPack</a> is an popular binary serialization format. It can be considered as a binary superset of JSON. Unreal Engine already supports <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Cbor" title="Cbor"><code>Cbor</code></a> module which is a format which is very similar to MsgPack.</p>
<p>We choose to implement MsgPack as we're more familiar with it and also providing an alternative.</p>
<h2 id="msgpack-readerwriter"><a class="header" href="#msgpack-readerwriter">MsgPack Reader/Writer</a></h2>
<p>For the most part MsgPack reader/writer works just like their <a href="Formats/./Json.html">JSON counterpart</a>. There're just a few additional data types that belongs to this:</p>
<h3 id="binary"><a class="header" href="#binary">Binary</a></h3>
<p>MsgPack directly supports <code>bin format family</code> which directly maps to <code>EDcDataEntry::Blob</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
DC_TRY(Writer.WriteBlob({Bytes, 0}));
TArray&lt;uint8&gt; Arr = {1,2,3,4,5};

FDcMsgPackWriter Writer;
DC_TRY(Writer.WriteBlob(FDcBlobViewData::From(Arr)));
auto&amp; Buf = Writer.GetMainBuffer();

FDcMsgPackReader Reader(FDcBlobViewData::From(Buf));
FDcBlobViewData Blob;
DC_TRY(Reader.ReadBlob(&amp;Blob));

check(Blob.Num == 5);
check(FPlatformMemory::Memcmp(Arr.GetData(), Blob.DataPtr, Blob.Num) == 0);
</code></pre>
<h3 id="extension"><a class="header" href="#extension">Extension</a></h3>
<p>MsgPack also supports <code>ext format family</code> which is basically fixed size binary data with a header:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcMsgPackWriter Writer;
DC_TRY(Writer.WriteFixExt2(1, {2, 3}));
auto&amp; Buf = Writer.GetMainBuffer();

FDcMsgPackReader Reader(FDcBlobViewData::From(Buf));
uint8 Type;
FDcBytes2 Bytes;
DC_TRY(Reader.ReadFixExt2(&amp;Type, &amp;Bytes));

check(Type == 1);
check(Bytes.Data[0] == 2);
check(Bytes.Data[1] == 3);
</code></pre>
<h2 id="msgpack-serializedeserialize"><a class="header" href="#msgpack-serializedeserialize">MsgPack Serialize/Deserialize</a></h2>
<p>MsgPack handlers also support multiple setup types:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Serialize/DcSerializerSetup.h
enum class EDcMsgPackSerializeType
{
    Default,
    StringSoftLazy, // Serialize Soft/Lazy references as string
    InMemory,       // Serialize pointer/enum/FName etc as underlying integer values
};
</code></pre>
<h3 id="persistent-handlers"><a class="header" href="#persistent-handlers">Persistent handlers</a></h3>
<p>The <code>Default</code> and <code>StringSoftLazy</code> options would setup a set of handlers that behaves
like their JSON counterparts. </p>
<p>We have a &quot;Property -&gt; Json -&gt; MsgPack -&gt; Json -&gt; Property&quot; roundtrip test setup in <code>DataConfig.Core.RoundTrip.Property_Json_MsgPack_Json_Property</code> test.</p>
<h3 id="in-memory-handlers"><a class="header" href="#in-memory-handlers">In Memory handlers</a></h3>
<p>This is a special set of handlers that only makes sense for binary formats. For example pointers are serialized as memory addresses.</p>
<table><thead><tr><th>EDcDataEntry</th><th>Serialized</th></tr></thead><tbody>
<tr><td>Name</td><td><code>[uint32, uint32, int32]</code></td></tr>
<tr><td>Text</td><td><code>[void*, void*, uint32]</code></td></tr>
<tr><td>ObjectReference, ClassReference</td><td><code>void*</code></td></tr>
<tr><td>SoftObjectReference, SoftClassReference</td><td><code>FString or void*</code></td></tr>
<tr><td>WeakObjectReference</td><td><code>[int32, int32]</code></td></tr>
<tr><td>LazyObjectReference</td><td><code>&lt;uuid as FIXEXT16&gt;</code></td></tr>
<tr><td>InterfaceReference</td><td><code>[void*, void*]</code></td></tr>
<tr><td>Delegate</td><td><code>[int32, int32, (FName)[uint32, uint32, int32]]</code></td></tr>
<tr><td>MulticastInlineDelegate, MulticastSparseDelegate</td><td><code>[(list of &lt;Delegate&gt;)]</code></td></tr>
<tr><td>FieldPath</td><td><code>void*</code></td></tr>
<tr><td>Enum</td><td><code>uint64</code></td></tr>
</tbody></table>
<p>With these handlers all data types can be serialized. Note that serializing stuff as memory address isn't always what you want. These are provided as soft of a reference on how to access various data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipe-property"><a class="header" href="#pipe-property">Pipe Property</a></h1>
<p>There's a set of deserialize handlers in <code>DcPropertyPipeHandlers</code> namespace. It's used to roundtripping property system objects.</p>
<p>Simply speaking it's equivalent to doing a <code>FDcPipeVisitor</code>  pipe visit.</p>
<pre><code class="language-c++">//  DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
//  these two blocks are equivalent
{
    FDcPropertyReader Reader(FromDatum);
    FDcPropertyWriter Writer(ToDatum);
    FDcPipeVisitor RoundtripVisit(&amp;Reader, &amp;Writer);

    DC_TRY(RoundtripVisit.PipeVisit());
}

{
    FDcDeserializer Deserializer;
    DcSetupPropertyPipeDeserializeHandlers(Deserializer);

    FDcPropertyReader Reader(FromDatum);
    FDcPropertyWriter Writer(ToDatum);

    FDcDeserializeContext Ctx;
    Ctx.Reader = &amp;Reader;
    Ctx.Writer = &amp;Writer;
    Ctx.Deserializer = &amp;Deserializer;
    DC_TRY(Ctx.Prepare());

    DC_TRY(Deserializer.Deserialize(Ctx));
}
</code></pre>
<p>These are provided as a set of basis to for building custom property wrangling utils. See <code>DataConfigExtra - DcDeserializeRenameStructFieldNames.h/cpp</code> for example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extra"><a class="header" href="#extra">Extra</a></h1>
<p>Alongside <code>DataConfigCore</code> we have two other modules <code>DataConfigExtra</code> and <code>DataConfigEditorExtra</code>. It have self contained samples built on top of DataConfig framework.</p>
<p>Note that these are not intended to be integrated directly. You can take these as references when implementing custom features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fcolor-serializationdeserialization"><a class="header" href="#fcolor-serializationdeserialization">FColor Serialization/Deserialization</a></h1>
<p>This example has been shown in <a href="Extra/../Examples/Custom.html" title="Custom">previous chapter</a>. It's also a benchmark use case for our custom deserialization logic:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Deserialize/DcSerDeColor.h
USTRUCT()
struct FDcExtraTestStructWithColor1
{
    GENERATED_BODY()

    UPROPERTY() FColor ColorField1;
    UPROPERTY() FColor ColorField2;
};

// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeColor.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
        &quot;ColorField2&quot; : &quot;#FF0000FF&quot;,
    }
)&quot;);
</code></pre>
<p><code>FColor</code> is converted into a <code>#RRGGBBAA</code> hex string. The corresponding handlers looks pretty mirrored.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeColor.cpp
FDcResult HandlerColorDeserialize(FDcDeserializeContext&amp; Ctx)
{
	FDcPropertyDatum Datum;
	DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

	FString ColorStr;
	DC_TRY(Ctx.Reader-&gt;ReadString(&amp;ColorStr));
	FColor Color = FColor::FromHex(ColorStr);

	FColor* ColorPtr = (FColor*)Datum.DataPtr;
	*ColorPtr = Color;

	return DcOk();
}

FDcResult HandlerColorSerialize(FDcSerializeContext&amp; Ctx)
{
	FDcPropertyDatum Datum;
	DC_TRY(Ctx.Reader-&gt;ReadDataEntry(FStructProperty::StaticClass(), Datum));

	FColor* ColorPtr = (FColor*)Datum.DataPtr;
	DC_TRY(Ctx.Writer-&gt;WriteString(TEXT(&quot;#&quot;) + ColorPtr-&gt;ToHex()));

	return DcOk();
}
</code></pre>
<p>Note how <code>FDcPropertyReader::ReadDataEntry</code> and <code>FDcPropertyWriter::WriteDataEntry</code> retrieves the next property as a <code>FDcPropertyDatum</code>, which allows us to directly manipulate a <code>FColor</code> pointer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base64-blob-serializationdeserialization"><a class="header" href="#base64-blob-serializationdeserialization">Base64 Blob Serialization/Deserialization</a></h1>
<p>This demonstrates conversion between<code>TArray&lt;uint8&gt;</code> and Base64 encoded strings in JSON:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Deserialize/DcSerDeBase64.h
USTRUCT()
struct FDcExtraTestStructWithBase64
{
    GENERATED_BODY()

    UPROPERTY(meta = (DcExtraBase64)) TArray&lt;uint8&gt; BlobField1;
    UPROPERTY(meta = (DcExtraBase64)) TArray&lt;uint8&gt; BlobField2;
};

// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeBase64.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;BlobField1&quot; : &quot;dGhlc2UgYXJlIG15IHR3aXN0ZWQgd29yZHM=&quot;,
        &quot;BlobField2&quot; : &quot;&quot;,
    }
)&quot;);
</code></pre>
<p>Note that we're tagging the <code>BlobField</code> with <code>(meta = (DcExtraBase64))</code> to explicitly show that we' want this member to be converted into Base64.</p>
<p>UE support <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/GameplayArchitecture/Metadata/" title="Metadata Specifiers">arbitrary meta data in the <code>meta = ()</code> segment</a>. But beware that the meta data is only available when <code>WITH_EDITORDATA</code> flag is defined. In predicate we check for this <code>DcExtraBase64</code> like this:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcSerDeBase64.cpp
EDcDeserializePredicateResult PredicateIsBase64Blob(FDcDeserializeContext&amp; Ctx)
{
	FArrayProperty* ArrayProperty = DcPropertyUtils::CastFieldVariant&lt;FArrayProperty&gt;(Ctx.TopProperty());

	//	check for only TArray&lt;uint8&gt;
	if (ArrayProperty == nullptr)
		return EDcDeserializePredicateResult::Pass;
	if (!ArrayProperty-&gt;Inner-&gt;IsA&lt;FByteProperty&gt;())
		return EDcDeserializePredicateResult::Pass;

	return ArrayProperty-&gt;HasMetaData(TEXT(&quot;DcExtraBase64&quot;))
		? EDcDeserializePredicateResult::Process
		: EDcDeserializePredicateResult::Pass;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writer-api-alternatives"><a class="header" href="#writer-api-alternatives">Writer API Alternatives</a></h1>
<p>Previously we're deserializing <code>FColor</code> by writing into its member fields separately, which is a bit cumbersome. In this case DataConfig do support better alternatives.</p>
<p>Since we know that <code>FColor</code> is POD type we can construct one by filling in correct bit pattern. In this case <code>FDcPropertyWriter</code> allow struct property to be coerced from a blob:</p>
<pre><code class="language-c++">//  DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriteBlob&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    return Ctx.Writer-&gt;WriteBlob({
        (uint8*)&amp;Color, // treat `Color` as opaque blob data
        sizeof(FColor)
    });
}
</code></pre>
<p>Alternatively we can get <code>FProperty</code> and data pointer in place and setting the value through Unreal's <code>FProperty</code> API:</p>
<pre><code class="language-c++">//  DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriteDataEntry&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    FDcPropertyDatum Datum;
    DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

    Datum.CastFieldChecked&lt;FStructProperty&gt;()-&gt;CopySingleValue(Datum.DataPtr, &amp;Color);
    return DcOk();
}
</code></pre>
<p>Note that we already know that <code>Datum.DataPtr</code> points to a allocated <code>FColor</code> instance. Thus we can simply cast it into a <code>FColor*</code> and directly manipulate the pointer.</p>
<pre><code class="language-c++">//  DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WritePointer&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    FDcPropertyDatum Datum;
    DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

    FColor* ColorPtr = (FColor*)Datum.DataPtr;
    *ColorPtr = Color;  // deserialize by assignment

    return DcOk();
}
</code></pre>
<p>Note that these techniques also applies on serialization:</p>
<pre><code class="language-c++">//  DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeColor.cpp
FDcResult HandlerColorSerialize(FDcSerializeContext&amp; Ctx)
{
    FDcPropertyDatum Datum;
    DC_TRY(Ctx.Reader-&gt;ReadDataEntry(FStructProperty::StaticClass(), Datum));

    FColor* ColorPtr = (FColor*)Datum.DataPtr;
    DC_TRY(Ctx.Writer-&gt;WriteString(TEXT(&quot;#&quot;) + ColorPtr-&gt;ToHex()));

    return DcOk();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsonconverter-in-dataconfig"><a class="header" href="#jsonconverter-in-dataconfig">JsonConverter in DataConfig</a></h1>
<p>UE comes with a handy module <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/JsonUtilities/"><code>JsonUtilities</code></a> that handles conversion between <code>USTRUCT</code>s and JSON. In this example we've implemented similar functionalities that behaves almost identical to stock <code>FJsonConverter</code>.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcJsonConverter.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;strField&quot; : &quot;Foo&quot;,
        &quot;nestField&quot; : {
            &quot;strArrayField&quot; : [
                &quot;One&quot;,
                &quot;Two&quot;,
                &quot;Three&quot;
            ],
            &quot;strIntMapField&quot; : {
                &quot;One&quot;: 1,
                &quot;Two&quot;: 2,
                &quot;Three&quot;: 3
            }
        },
        &quot;intField&quot; : 253,
        &quot;boolField&quot; : true
    }
)&quot;);

{
	FDcTestJsonConverter1 Lhs;
	bool LhsOk = DcExtra::JsonObjectStringToUStruct(Str, &amp;Lhs);

    FDcTestJsonConverter1 Rhs;
	bool RhsOk = FJsonObjectConverter::JsonObjectStringToUStruct(Str, &amp;Rhs);
}    
{
	FString Lhs;
	bool LhsOk = DcExtra::UStructToJsonObjectString(Data, Lhs);

	FString Rhs;
	bool RhsOk = FJsonObjectConverter::UStructToJsonObjectString(Data, Rhs);
}
</code></pre>
<p><code>DcExtra::JsonObjectStringToUStruct()</code> body is trivia as it delegates most of the work to <code>DcDeserializer</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcJsonConverter.cpp
bool JsonObjectReaderToUStruct(FDcReader* Reader, FDcPropertyDatum Datum)
{
	FDcResult Ret = [&amp;]() -&gt; FDcResult {
		using namespace JsonConverterDetails;
		LazyInitializeDeserializer();

		FDcPropertyWriter Writer(Datum);

		FDcDeserializeContext Ctx;
		Ctx.Reader = Reader;
		Ctx.Writer = &amp;Writer;
		Ctx.Deserializer = &amp;Deserializer.GetValue();
		DC_TRY(Ctx.Prepare());

		DC_TRY(Deserializer-&gt;Deserialize(Ctx));
		return DcOk();
	}();

	if (!Ret.Ok())
	{
		DcEnv().FlushDiags();
		return false;
	}
	else
	{
		return true;
	}
}
</code></pre>
<p>The serializing function <code>DcExtra::UStructToJsonObjectString()</code> needs some customization as default <code>DcJsonWriter</code> and <code>DcSerializer</code> handlers behaves a bit different against stock <code>FDcJsonConverter</code>:</p>
<ul>
<li>It serialize field names as <code>camelCase</code>.</li>
<li>It uses platform dependent line endings, that is <code>\r\n</code> on Windows.</li>
<li>It have subtle new line breaking rules on nested array and object, and on spacing around <code>:</code> token.</li>
</ul>
<p>The good news is that one can customize these behaviors with DataConfig to match it:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/Types/DcJsonConverter.h
template&lt;typename InStructType&gt;
static bool UStructToJsonObjectString(const InStructType&amp; InStruct, FString&amp; OutJsonString)
{
    static FDcJsonWriter::ConfigType _JSON_CONVERTER_CONFIG = []
	{
		FDcJsonWriter::ConfigType Config = FDcJsonWriter::DefaultConfig;
		Config.IndentLiteral = TEXT(&quot;\t&quot;);
		Config.LineEndLiteral = LINE_TERMINATOR;
		Config.LeftSpacingLiteral = TEXT(&quot;&quot;);
		Config.bNestedArrayStartsOnNewLine = false;
		Config.bNestedObjectStartsOnNewLine = true;
		return Config;
	}();

	FDcJsonWriter Writer(_JSON_CONVERTER_CONFIG);
    ...
}

// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcJsonConverter.cpp
static FDcResult HandlerStructRootSerializeCamelCase(FDcSerializeContext&amp; Ctx)
{
    ...
	else if (CurPeek == EDcDataEntry::Name)
	{
		FName Value;
		DC_TRY(Ctx.Reader-&gt;ReadName(&amp;Value));
		DC_TRY(Ctx.Writer-&gt;WriteString(FJsonObjectConverter::StandardizeCase(Value.ToString())));
    }
}
</code></pre>
<p>We aim to support flexible serialization and formatting behaviors without modifying <code>DataConfigCore</code> code:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anystruct"><a class="header" href="#anystruct">AnyStruct</a></h1>
<p>This is an intermediate example that takes advantage of the flexibility provided by the property system. <code>FDcAnyStruct</code> is a struct that stores a heap allocated <code>USTRUCT</code> of any type while maintaining value semantic on itself. If you're familiar with the concept of variant type, just think of it as a variant type that supports all <code>USTRUCT</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeAnyStruct.cpp
//  instantiate from heap allocated structs
FDcAnyStruct Any1 = new FDcExtraTestSimpleStruct1();
Any1.GetChecked&lt;FDcExtraTestSimpleStruct1&gt;()-&gt;NameField = TEXT(&quot;Foo&quot;);

//  supports moving
FDcAnyStruct Any2 = MoveTemp(Any1);
check(!Any1.IsValid());
check(Any2.GetChecked&lt;FDcExtraTestSimpleStruct1&gt;()-&gt;NameField == TEXT(&quot;Foo&quot;));
Any2.Reset();

//  supports shared referencing
Any2 = new FDcExtraTestSimpleStruct2();
Any2.GetChecked&lt;FDcExtraTestSimpleStruct2&gt;()-&gt;StrField = TEXT(&quot;Bar&quot;);

Any1 = Any2;

check(Any1.DataPtr == Any2.DataPtr);
check(Any1.StructClass == Any2.StructClass);
</code></pre>
<p>We then implemented conversion logic between <code>FDcAnyStruct</code> and JSON:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Public/DataConfig/Extra/SerDe/DcSerDeAnyStruct.h
USTRUCT()
struct FDcExtraTestWithAnyStruct1
{
    GENERATED_BODY()

    UPROPERTY() FDcAnyStruct AnyStructField1;
    UPROPERTY() FDcAnyStruct AnyStructField2;
    UPROPERTY() FDcAnyStruct AnyStructField3;
};

// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/SerDe/DcSerDeAnyStruct.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;AnyStructField1&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestSimpleStruct1&quot;,
            &quot;NameField&quot; : &quot;Foo&quot;
        },
        &quot;AnyStructField2&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestStructWithColor1&quot;,
            &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
            &quot;ColorField2&quot; : &quot;#FF0000FF&quot;
        },
        &quot;AnyStructField3&quot; : null
    }
)&quot;);
</code></pre>
<p>Note how the custom <code>FColor &lt;-&gt; &quot;#RRGGBBAA&quot;</code> conversion recursively works within <code>FDcAnyStruct</code>. This should be a good starting point for you to implement your own nested variant types and containers. For more details refer to the implementation of <code>HandlerDcAnyStruct[Serialize/Deserialize]</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-renamer"><a class="header" href="#field-renamer">Field Renamer</a></h1>
<p>DataConfig can also be used to author one-off utility. In this example we implemented <code>DcExtra::DeserializeStructRenaming()</code> that copies data between structural identical data structures, while renaming field names by a user function.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeRenameStructFieldNames.cpp
//  struct equivelent to this:
FString Str = TEXT(R&quot;(
    {
        &quot;FromName1&quot; : &quot;Foo&quot;,
        &quot;FromStructSet1&quot; : 
        [
            {
                &quot;FromStr1&quot; : &quot;One&quot;,
                &quot;FromInt1&quot; : 1,
            },
            {
                &quot;FromStr1&quot; : &quot;Two&quot;,
                &quot;FromInt1&quot; : 2,
            }
        ]
    }
)&quot;);

// ... deserialize with a functor renaming `FromXXX` to `ToXXX`:
UTEST_OK(&quot;...&quot;, DcExtra::DeserializeStructRenaming(
    FromDatum, ToDatum, FDcExtraRenamer::CreateLambda([](const FName&amp; FromName){
    FString FromStr = FromName.ToString();
    if (FromStr.StartsWith(TEXT(&quot;From&quot;)))
        return FName(TEXT(&quot;To&quot;) + FromStr.Mid(4));
    else
        return FromName;
})));

// ... results into a struct equivelent to this: 
FString Str = TEXT(R&quot;(
    {
        &quot;ToName1&quot; : &quot;Foo&quot;,
        &quot;ToStructSet1&quot; : 
        [
            {
                &quot;ToStr1&quot; : &quot;One&quot;,
                &quot;ToInt1&quot; : 1,
            },
            {
                &quot;ToStr1&quot; : &quot;Two&quot;,
                &quot;ToInt1&quot; : 2,
            }
        ]
    }
)&quot;);
</code></pre>
<p>This takes advantage of the <code>DcPropertyPipeHandlers</code> that simply do verbatim data piping. </p>
<p>The gist is that you should consider DataConfig an option when working with batch data processing within Unreal Engine. We are trying to provide tools to support these use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-property-by-path"><a class="header" href="#access-property-by-path">Access property by path</a></h1>
<p>This example demonstrates that <code>FReader/FWriter</code> can be used standalone, without <code>FDcSerializer/FDcDeserializer</code>.</p>
<p>UE built-in module <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/PropertyPath" title="PropertyPath"><code>PropertyPath</code></a> allow accessing nested object properties by a path like <code>Foo.Bar.Baz</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcPropertyPathAccess.cpp
FString Str;
UTEST_TRUE(&quot;...&quot;, PropertyPathHelpers::GetPropertyValue(Outer, TEXT(&quot;StructRoot.Middle.InnerMost.StrField&quot;), Str));
UTEST_TRUE(&quot;...&quot;, Str == TEXT(&quot;Foo&quot;));

UTEST_TRUE(&quot;...&quot;, PropertyPathHelpers::SetPropertyValue(Outer, TEXT(&quot;StructRoot.Middle.InnerMost.StrField&quot;), FString(TEXT(&quot;Bar&quot;))));
UTEST_TRUE(&quot;...&quot;, Outer-&gt;StructRoot.Middle.InnerMost.StrField == TEXT(&quot;Bar&quot;));
</code></pre>
<p>We implemented a pair of methods <code>DcExtra::GetDatumPropertyByPath/SetDatumPropertyByPath</code> with <code>FDcPropertyReader</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcPropertyPathAccess.cpp
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Middle.InnerMost.StrField&quot;), TEXT(&quot;Foo&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.0.StrField&quot;), TEXT(&quot;Bar0&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.1.StrField&quot;), TEXT(&quot;Bar1&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.NameMap.FooKey.StrField&quot;), TEXT(&quot;FooValue&quot;)));

UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Middle.InnerMost.StrField&quot;, TEXT(&quot;AltFoo&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.0.StrField&quot;, TEXT(&quot;AltBar0&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.1.StrField&quot;, TEXT(&quot;AltBar1&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.NameMap.FooKey.StrField&quot;, TEXT(&quot;AltFooValue&quot;)));
</code></pre>
<p>Comparing to <code>PropertyPathHelpers</code> these new ones support <code>Array</code> and <code>Map</code>, and support <code>USTRUCT</code> roots. We're missing some features like expanding weak/lazy object references but it should be easy to implement.</p>
<p>Remember that we have bundled JSON/MsgPack reader/writers that can also be used standalone.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extra-module-setups"><a class="header" href="#extra-module-setups">Extra Module Setups</a></h1>
<p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Modules/" title="								Unreal Engine Modules 						">Unreal Engine Modules</a> is how the engine handles its C++ code physical design. You'll need to be pretty familiar with the system to scale up your C++ project.</p>
<p>We split extra samples in two modules. The first is <code>DataConfigExtra</code> which does <strong>not</strong> depend on <code>Engine/UnrealEd</code> module. It can be built along program target. <code>DataConfigExtra</code> is basically a set of C++ source files bundled and there's no special setup for it. The key setup is to set <code>ModuleRules.bRequiresImplementModule</code> to be <code>false</code>:</p>
<pre><code class="language-c#">// DataConfig/Source/DataConfigExtra/DataConfigExtra.Build.cs
public class DataConfigExtra : ModuleRules
{
	public DataConfigExtra(ReadOnlyTargetRules Target) : base(Target)
	{
	    bRequiresImplementModule = false;
	    Type = ModuleType.CPlusPlus;
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
		PublicDependencyModuleNames.AddRange(
			new string[] {
			&quot;DataConfigCore&quot;,
			&quot;Core&quot;,
			&quot;CoreUObject&quot;,
             // ...
			});
	}
}
</code></pre>
<p>The other module is <code>DcEditorExtraModule</code>, a more conventional editor only module. It's also the recommended setup for integrating DataConfig as an editor only dependency into your project. We also put samples that depends on <code>Engine</code> and other gameplay system in here.</p>
<p>Most of integration code is in <code>IModuleInterface::StartUpModule/ShutdownModule()</code>. </p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DcEditorExtraModule.cpp
void FDcEditorExtraModule::StartupModule()
{
    // ...
	DcRegisterDiagnosticGroup(&amp;DcDExtra::Details);
	DcRegisterDiagnosticGroup(&amp;DcDEditorExtra::Details);

	DcStartUp(EDcInitializeAction::Minimal);
	DcEnv().DiagConsumer = MakeShareable(new FDcMessageLogDiagnosticConsumer());
	// ...
}

void FDcEditorExtraModule::ShutdownModule()
{
	DcShutDown();
    // ...
}

</code></pre>
<p>Here's a checklist for integration:</p>
<ul>
<li>Register additional diagnostics early. </li>
<li>Call <code>DcStartUp()/DcShutDonw()</code> pair.</li>
<li>Register custom diagnostic consumer.</li>
</ul>
<p><code>FDcMessageLogDiagnosticConsumer</code> is an example of redirecting diagnostics to the UE Message Log window with its own category.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprint-serializationdeserialization"><a class="header" href="#blueprint-serializationdeserialization">Blueprint Serialization/Deserialization</a></h1>
<p>The Property System is so powerful that you can create new Blueprint Class/Struct, which is equivalent to C++ <code>UCLASS/USTRUCT</code> to some extents. In this example we'll show how to handle these in DataConfig. </p>
<p>The whole blueprint stuff depends on <code>Engine</code> module. This is also why we put related code into <code>DataConfigEditorExtra</code> module.</p>
<h2 id="blueprint-class-and-object-references"><a class="header" href="#blueprint-class-and-object-references">Blueprint Class and Object references</a></h2>
<p>Blueprint class are stored within <code>UBlueprint</code> typed assets. Note that we automatically unwrap the container in handlers.</p>
<pre><code class="language-c++">//DataConfig/Source/DataConfigEditorExtra/Public/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.h
USTRUCT()
struct DATACONFIGEDITOREXTRA_API FDcEditorExtraTestStructWithBPClass
{
    GENERATED_BODY()

    UPROPERTY() TSubclassOf&lt;UDcTestBPClassBase&gt; ClassField1;
    UPROPERTY() TSubclassOf&lt;UDcTestBPClassBase&gt; ClassField2;
    UPROPERTY() TSubclassOf&lt;UDcTestBPClassBase&gt; ClassField3;
};

USTRUCT()
struct DATACONFIGEDITOREXTRA_API FDcEditorExtraTestStructWithBPInstance
{
    GENERATED_BODY()

    UPROPERTY() UDcTestBPClassBase* InstanceField1;
    UPROPERTY() UDcTestBPClassBase* InstanceField2;
    UPROPERTY() UDcTestBPClassBase* InstanceField3;
};

//DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ClassField1&quot; : null,
        &quot;ClassField2&quot; : &quot;DcTestNativeDerived1&quot;,
        &quot;ClassField3&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintClassBeta&quot;
    }
)&quot;);

FString Str = TEXT(R&quot;(
    {
        &quot;InstanceField1&quot; : null,
        &quot;InstanceField2&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintInstanceAlpha&quot;,
        &quot;InstanceField3&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintInstanceBeta&quot;
    }
)&quot;);
</code></pre>
<h2 id="blueprint-class-instance"><a class="header" href="#blueprint-class-instance">Blueprint Class Instance</a></h2>
<p>In this example we roundtrip a Blueprint class instance from JSON:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-BlueprintClass.png" alt="Blueprint Class" /></p>
<pre><code class="language-c++">//DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StrField&quot; : &quot;Foo&quot;,
        &quot;BPEnumField&quot; : &quot;Baz&quot;,
        &quot;IntField&quot; : 345
    }
)&quot;);
</code></pre>
<p>You can also reference on how to handle Blueprint enum in this example. It need some special care to convert between int value and the descriptive text set within the editor.</p>
<h2 id="blueprint-struct-instance"><a class="header" href="#blueprint-struct-instance">Blueprint Struct Instance</a></h2>
<p>Finally we're combined <code>FColor</code>, <code>FDcAnyStruct</code> and Blueprint struct into one single example:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-BlueprintStruct.png" alt="DataConfigEditorExtra-BlueprintStruct" /></p>
<pre><code class="language-c++">//DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeBlueprint.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;AnyStructField1&quot; : {
            &quot;$type&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintStructWithColor&quot;,
            &quot;NameField&quot; : &quot;Foo&quot;,
            &quot;StrField&quot; : &quot;Bar&quot;,
            &quot;IntField&quot; : 123,
            &quot;ColorField&quot; : &quot;#FF0000FF&quot;
        }
    }
)&quot;);
</code></pre>
<p>Under the hood Blueprint struct mangles its field names. The struct above dumps to something like this:</p>
<pre><code>-----------------------------------------
# Datum: 'UserDefinedStruct', 'DcTestBlueprintStructWithColor'
&lt;StructRoot&gt; 'DcTestBlueprintStructWithColor'
|---&lt;Name&gt; 'NameField_5_97BFF114405C1934C2F33E8668BF1652'
|---&lt;Name&gt; 'Foo'
|---&lt;Name&gt; 'StrField_9_FAA71EFE4896F4E6B1478B9C13B2CE52'
|---&lt;String&gt; 'Bar'
|---&lt;Name&gt; 'IntField_11_3BC7CB0F42439CE2196F7AA82A1AC374'
|---&lt;Int32&gt; '123'
|---&lt;Name&gt; 'ColorField_14_F676BCF245B2977B678B65A8216E94EB'
|---&lt;StructRoot&gt; 'Color'
|   |---&lt;Name&gt; 'B'
|   |---&lt;UInt8&gt; '0'
|   |---&lt;Name&gt; 'G'
|   |---&lt;UInt8&gt; '0'
|   |---&lt;Name&gt; 'R'
|   |---&lt;UInt8&gt; '255'
|   |---&lt;Name&gt; 'A'
|   |---&lt;UInt8&gt; '255'
|---&lt;StructEnd&gt; 'Color'
&lt;StructEnd&gt; 'DcTestBlueprintStructWithColor'
-----------------------------------------
</code></pre>
<p>The good news is that DataConfig already got this covered. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gameplay-tag-serializationdeserialization"><a class="header" href="#gameplay-tag-serializationdeserialization">Gameplay Tag Serialization/Deserialization</a></h1>
<p><a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Tags/index.html" title="Gameplay Tags">GameplayTags</a> is a built-in runtime module that implements hierarchical tags. </p>
<p>In this example we have roundtrip handlers for <code>FGameplayTag</code> and <code>FGameplayTagContainer</code>.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Public/DataConfig/EditorExtra/SerDe/DcSerDeGameplayTags.h
USTRUCT()
struct FDcEditorExtraTestStructWithGameplayTag1
{
    GENERATED_BODY()

    UPROPERTY() FGameplayTag TagField1;
    UPROPERTY() FGameplayTag TagField2;
};

// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/SerDe/DcSerDeGameplayTags.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;TagField1&quot; : null,
        &quot;TagField2&quot; : &quot;DataConfig.Foo.Bar&quot;
    }
)&quot;);
</code></pre>
<p><code>FGameplayTagContainer</code> converts to a list of strings:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Public/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.h
USTRUCT()
struct FDcEditorExtraTestStructWithGameplayTag2
{
    GENERATED_BODY()

    UPROPERTY() FGameplayTagContainer TagContainerField1;
    UPROPERTY() FGameplayTagContainer TagContainerField2;
};

// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;TagContainerField1&quot; : [],
        &quot;TagContainerField2&quot; : [
            &quot;DataConfig.Foo.Bar&quot;,
            &quot;DataConfig.Foo.Bar.Baz&quot;,
            &quot;DataConfig.Tar.Taz&quot;,
        ]
    }
)&quot;);
</code></pre>
<p>Note that gameplay tag parsing has error reporting built-in. In this case we can pipe it into our diagnostic:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.cpp
static FDcResult _StringToGameplayTag(FDcDeserializeContext&amp; Ctx, const FString&amp; Str, FGameplayTag* OutTagPtr)
{
    FString FixedString;
    FText Err;
    if (!FGameplayTag::IsValidGameplayTagString(Str, &amp;Err, &amp;FixedString))
    {
        return DC_FAIL(DcDEditorExtra, InvalidGameplayTagStringFixErr)
            &lt;&lt; Str &lt;&lt; FixedString &lt;&lt; Err;
    }
    //...
}
</code></pre>
<p>In case of a invalid tag it would report the reason and fixed string:</p>
<pre><code># DataConfig Error: Invalid Gameplay Tag String, Actual: 'DataConfig.Invalid.Tag.', Fixed: 'DataConfig.Invalid.Tag', Error: 'Tag ends with .'
- [JsonReader] --&gt; &lt;in-memory&gt;5:4
   3 |        { 
   4 |            &quot;TagField1&quot; : null, 
   5 |            &quot;TagField2&quot; : &quot;DataConfig.Invalid.Tag.&quot; 
     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^
   6 |        } 
   7 |    
- [PropertyWriter] Writing property: (FDcEditorExtraTestStructWithGameplayTag1)$root.(FGameplayTag)TagField2
 [C:\DevUE\UnrealEngine\Engine\Source\Developer\MessageLog\Private\Model\MessageLogListingModel.cpp(73)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deserialize-gameplay-abilities"><a class="header" href="#deserialize-gameplay-abilities">Deserialize Gameplay Abilities</a></h1>
<p>We'll conclude with a concrete user story: populating <code>GameplayAbility</code> and <code>GameplayEffect</code> blueprint from JSON file.</p>
<p><a href="https://docs.unrealengine.com/en-US/InteractiveExperiences/GameplayAbilitySystem/index.html" title="Gameplay Ability System">Gameplay Ability System</a> is a built-in plugin for building data driven abilities. Users are expected to derived and modify <code>GameplayAbility</code> and <code>GameplayEffect</code> blueprint for custom logic. </p>
<p>Given a JSON like this:</p>
<pre><code class="language-c++">// DataConfig/Tests/Fixture_AbilityAlpha.json
{
    /// Tags
    &quot;AbilityTags&quot; : [
        &quot;DataConfig.Foo.Bar&quot;,
        &quot;DataConfig.Foo.Bar.Baz&quot;,
    ],
    &quot;CancelAbilitiesWithTag&quot; : [
        &quot;DataConfig.Foo.Bar.Baz&quot;,
        &quot;DataConfig.Tar.Taz&quot;,
    ],
    /// Costs
    &quot;CostGameplayEffectClass&quot; : &quot;/DataConfig/DcFixture/DcTestGameplayEffectAlpha&quot;,
    /// Advanced
    &quot;ReplicationPolicy&quot; : &quot;ReplicateYes&quot;,
    &quot;InstancingPolicy&quot; : &quot;NonInstanced&quot;,
}
</code></pre>
<p>Right click on a <code>GameplayAbility</code> blueprint asset and select <code>Load From JSON</code>， then select this file and confirm. It would correctly populate the fields with the values in JSON, as seen in the pic below:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-LoadJsonIntoAbility.png" alt="DataConfigEditorExtra-LoadJsonIntoAbility" /></p>
<p>Most of the logic is in <code>DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayAbility.cpp</code>:</p>
<ul>
<li>The context menu is added from <code>GameplayAbilityEffectExtender</code>. There's another handy item named <code>Dump To Log</code> which dumps any blueprint CDO into the log.</li>
<li>DataConfig deserializer is setup in <code>LazyInitializeDeserializer()</code>. We added custom logic for deserializing <code>FGameplayAttribute</code> from a string like <code>DcTestAttributeSet.Mana</code>.</li>
<li>We also reused many methods from previous examples to support <code>FGameplayTag</code> deserialization and Blueprint class look up by path.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<p>This section contains documentation for advanced topics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p>We've integrated two benchmarks fixtures from <a href="https://json.nlohmann.me" title="JSON for Modern C++">JSON for modern C++</a> project. In the benchmark we deserialize JSON into C++ structs, then serialize them back to JSON. Then we convert JSON to MsgPack and do identical process.</p>
<p>Here're the results:</p>
<pre><code>Corpus Json Deserialize: [Shipping] Bandwidth: 64.109(MB/s), Mean: 86.047(ms), Median:85.737(ms), Deviation:1.103
Corpus Json Serialize: [Shipping] Bandwidth: 74.531(MB/s), Mean: 74.015(ms), Median:73.505(ms), Deviation:2.318
Corpus MsgPack Deserialize: [Shipping] Bandwidth: 75.873(MB/s), Mean: 68.887(ms), Median:68.755(ms), Deviation:0.457
Corpus MsgPack Serialize: [Shipping] Bandwidth: 62.885(MB/s), Mean: 83.115(ms), Median:83.020(ms), Deviation:0.434

Canada Json Deserialize: [Shipping] Bandwidth: 56.027(MB/s), Mean: 38.317(ms), Median:38.175(ms), Deviation:0.513
Canada Json Serialize: [Shipping] Bandwidth: 43.415(MB/s), Mean: 49.448(ms), Median:49.129(ms), Deviation:1.414
Canada MsgPack Serialize: [Shipping] Bandwidth: 67.366(MB/s), Mean: 8.672(ms), Median:8.669(ms), Deviation:0.021
Canada MsgPack Deserialize: [Shipping] Bandwidth: 52.600(MB/s), Mean: 11.107(ms), Median:11.064(ms), Deviation:0.173
</code></pre>
<p>Some insights on the results:</p>
<ul>
<li>
<p>Benchmark in <code>Shipping</code> build configuration, otherwise it doesn't make much sense.</p>
</li>
<li>
<p>Recall that <a href="Advanced/../Design.html#manifesto">runtime performance isn't our top priority</a>. We opted for a classic inheritance based API for <code>FDcReader/FDcWriter</code> 
which means that each read/write step result in a virtual dispatch. This by design would result in mediocre performance metrics.
The bandwidth should be in the range of <code>10~100(MB/s)</code> on common PC setup, no matter how simple the format is.</p>
</li>
<li>
<p>MsgPack and JSON has similar bandwidth numbers in the benchmark. However MsgPack has far more tight layout when dealing with 
numeric data. Note in the <code>Canada</code> fixture MsgPack only takes around 10ms, as this fixture is mostly float number coordinates.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips-for-writing-handlers"><a class="header" href="#tips-for-writing-handlers">Tips for writing handlers</a></h1>
<p>There're some recurring patterns when writing handlers in DataConfig.</p>
<h2 id="recursive-deserialize"><a class="header" href="#recursive-deserialize">Recursive Deserialize</a></h2>
<p>When deserializing a container like <code>USTRUCT</code> root or <code>TArray</code> you'll need to recursively deserialize children properties. This is wrapped in a single function call:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Private/DataConfig/Deserialize/Handlers/Json/DcJsonStructDeserializers.cpp
DC_TRY(DcDeserializeUtils::RecursiveDeserialize(Ctx));
</code></pre>
<p>Internally it would push writer's next property into <code>FDcDeserializeContext::Properties</code> to satisfiy the invariant that <code>FDcDeserializeContext::TopProperty()</code> always points to the current writing property. It would also clear up the top property on return.</p>
<p>Another example is how we pipe deserialize a <code>TMap&lt;&gt;</code>. When at key and value position we simply call this method 2 times:</p>
<pre><code class="language-C++">// DataConfig/Source/DataConfigCore/Private/DataConfig/Deserialize/Handlers/Property/DcPropertyPipeDeserializers.cpp
DC_TRY(Ctx.Reader-&gt;ReadMapRoot());
DC_TRY(Ctx.Writer-&gt;WriteMapRoot());

EDcDataEntry CurPeek;
while (true)
{
    DC_TRY(Ctx.Reader-&gt;PeekRead(&amp;CurPeek));
    if (CurPeek == EDcDataEntry::MapEnd)
        break;

    DC_TRY(DcDeserializeUtils::RecursiveDeserialize(Ctx));
    DC_TRY(DcDeserializeUtils::RecursiveDeserialize(Ctx));
}

DC_TRY(Ctx.Reader-&gt;ReadMapEnd());
DC_TRY(Ctx.Writer-&gt;WriteMapEnd());
</code></pre>
<h2 id="provide-topobject"><a class="header" href="#provide-topobject">Provide <code>TopObject()</code></a></h2>
<p>Sometimes deserialization will create new <code>UObject</code> along the way. In this case you'll need to fill in <code>FDcDeserializeContext::Objects</code> so the top one is used for <code>NewObject()</code> calls. For transient objecst you can use <code>GetTransientPackage()</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
Ctx.Objects.Push(GetTransientPackage());
</code></pre>
<h2 id="peek-by-value"><a class="header" href="#peek-by-value">Peek By Value</a></h2>
<p>Sometimes you want to peek the content of the next entry. For example in <code>DcExtra::HandlerBPDcAnyStructDeserialize()</code> we're dealing with a JSON like this:</p>
<pre><code class="language-json">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeBPClass.cpp
{
    &quot;AnyStructField1&quot; : {
        &quot;$type&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintStructWithColor&quot;,
        &quot;NameField&quot; : &quot;Foo&quot;,
        //...
    }
}
</code></pre>
<p>We want to consume the <code>$type</code> key and its value, and then delegate the logic back to the deserializer. The solution here is first to consume the pair. Then we put back a <code>{</code>  then replace the reader:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeBPClass.cpp
FDcPutbackReader PutbackReader(Ctx.Reader);
PutbackReader.Putback(EDcDataEntry::MapRoot);
TDcStoreThenReset&lt;FDcReader*&gt; RestoreReader(Ctx.Reader, &amp;PutbackReader);

FDcScopedProperty ScopedValueProperty(Ctx);
DC_TRY(ScopedValueProperty.PushProperty());
DC_TRY(Ctx.Deserializer-&gt;Deserialize(Ctx));
</code></pre>
<p>Beware that <code>Putback</code> only support a limited subset of data types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changes"><a class="header" href="#changes">Changes</a></h1>
<p>All notable changes to this project will be documented in this file.</p>
<h2 id="120---2022-1-26"><a class="header" href="#120---2022-1-26">1.2.0 - 2022-1-26</a></h2>
<p>Checkout blog post [&quot;Introducing DataConfig 1.2&quot;][/blog/dataconfig-1-2/].</p>
<ul>
<li><strong>New</strong> Serializer. Previously we only have deserializers. 
<ul>
<li>Serializer API mirrors deserializers.</li>
<li>Builtin serialization and deserialization handlers are all roundtrip-able.</li>
<li><code>DcDiagnosticDeserialize -&gt; DcDiagnosticSerDe</code> for sharing diagnostics.</li>
<li><code>DcDeserializeUtils -&gt; DcSerDeUtils</code> for sharing code.</li>
</ul>
</li>
<li><strong>New</strong> MsgPack reader and writer.
<ul>
<li>Full spec implemented, minus the &quot;Timestamp extension type&quot;.</li>
<li>Integrate and passes <a href="https://github.com/kawanet/msgpack-test-suite">kawanet/msgpack-test-suite</a>.</li>
</ul>
</li>
<li><strong>New</strong> JSON writer.
<ul>
<li>With <code>WIDECHAR/ANSICHAR</code> specialization as JSON Reader.</li>
<li>Accept config to output pretty or condensed output.</li>
</ul>
</li>
<li><strong>New</strong> Builtin metas.
<ul>
<li><code>DcSkip</code>  - skip marked fields</li>
<li><code>DcMsgPackBlob</code>  - marked TArray&lt;&gt;/Struct would be read as blob by MsgPack SerDe</li>
</ul>
</li>
<li><strong>CHANGE</strong> Core type changes.
<ul>
<li><code>FDcReader/FDcWriter</code> changes.
<ul>
<li><code>FDcStruct/ClassStat</code> renamed to <code>FDcStruct/ClassAccess</code>.</li>
<li><code>ReadStruct/ClassRoot()</code> renamed to <code>ReadStruct/ClassRootAccess</code>.</li>
<li>Add<code>ReadStruct/ClassRoot()</code> that takes no argument for common use cases.</li>
<li><code>FDcReader::Coercion()</code> now returns a <code>FDcResult</code></li>
<li><code>[Read/Write]Soft[Object/Class]Reference</code> takes <code>FSoftObjectPtr</code>.</li>
<li>RTTI with <code>GetId()</code> and <code>CastById()</code></li>
</ul>
</li>
<li><code>FDcSerializer/FDcDeserializer</code> changes.
<ul>
<li><code>DcDiagnosticDeserialize</code> -&gt; <code>DcDiagnosticSerDe</code> for sharing diagnostics.</li>
<li><code>DcDeserializeUtils</code> -&gt; <code>DcSerDeUtils</code> for sharing code.</li>
<li>Add handlers to read/write <code>Soft/Lazy</code> references as is, without loading the object.</li>
<li>Implicit call <code>Properties.Push()</code> before context <code>Prepare()</code>.</li>
<li>Removed <code>FDcScopedProperty</code> in favor of <code>DcDeserializeUtils::RecursiveDeserialize()</code> it's more concise. </li>
</ul>
</li>
<li><code>FDcPropertyReader/FDcPropertyWriter</code> changes.
<ul>
<li>When reading class object keys any one with <code>$</code> will be ignored.
<ul>
<li>previously only allow <code>$type</code>, <code>$path</code>.</li>
<li>note that struct by default don't check for these. It's trivia to add the logic if you want to.</li>
</ul>
</li>
<li>Add <code>FDcPropertyReader::PeekReadDataPtr</code> matches with <code>PeekProperty</code></li>
</ul>
</li>
<li><code>FDcJsonReader</code> changes.
<ul>
<li>Remove object key length limit, which was 2048 and it's incorrect.
<ul>
<li>Though <code>FName</code> is capped at 1024, which is a Unreal Engine limit.</li>
</ul>
</li>
<li>Fix <code>ReadName()</code> which previously would fail.</li>
<li>Fix quoted string parsing/escaping  in <code>ParseQuotedString</code></li>
</ul>
</li>
<li>Add <code>EDcDataEntry::Extension</code>.</li>
<li>Add <code>FDcPropertyDatum</code> template constructor to directly construct one from a <code>FSturct*</code>.</li>
<li><code>FPrettyPrintWriter</code> now print blobs with hash, previously it's pointer value.</li>
<li><code>DcAutomationUtils::SerializeIntoJson/DeserializeIntoJson</code> -&gt; <code>SerializeInto/DeserializeFrom</code> as we're supporting other formats.</li>
<li>Add <code>HeuristicVerifyPointer</code> to check common magic invalid pointers.</li>
</ul>
</li>
<li>Misc fixes and QOL improvements.
<ul>
<li>Fixed linux build. Now the headless program target cross compiles and runs under wsl.</li>
<li>Serializer/Deserializer now also report diagnostics.</li>
<li>Better Json reader diagnostic formatting. Now it clamps long lines properly.</li>
<li>Add <code>DataConfigEditorExtra.DcCoreTestsCommandlet</code> as tests runner.</li>
<li>Add performance benchmark.</li>
<li>Restructured DataConfig book for topics on serializer and MsgPack.</li>
</ul>
</li>
</ul>
<h2 id="111---2021-10-6"><a class="header" href="#111---2021-10-6">1.1.1 - 2021-10-6</a></h2>
<ul>
<li>Support for UE 4.27</li>
<li>Support for UE 5</li>
</ul>
<h2 id="110---2021-4-24"><a class="header" href="#110---2021-4-24">1.1.0 - 2021-4-24</a></h2>
<ul>
<li>Integrate <a href="https://github.com/nst/JSONTestSuite">nst/JSONTestSuite</a>. Now <code>DcJSONParser</code> pass most of them. Skipped tests are also documented.</li>
<li><code>FDcAnsiJsonReader</code> now detect and convert non ASCII UTF8 characters. Previously these characters are dropped.</li>
<li>Headless test runner pass along parameters to tests, for example
<code>DataConfigHeadless-Win64-Debug.exe Parsing -- n_array_just_minus</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license-1"><a class="header" href="#license-1">License</a></h1>
<p>DataConfig is released under <a href="https://choosealicense.com/licenses/mit/" title="MIT License">MIT License</a>.</p>
<pre><code>MIT License

Copyright (c) 2021-2022 Chen Tao 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>If you find DataConfig useful in your project, consider credit us in your project with the full license above or the shorter snippets below. </p>
<pre><code>DataConfig &lt;https//slowburn.dev/dataconfig&gt;
MIT License, Copyright (c) 2021-2022 Chen Tao
</code></pre>
<p>There's also <a href="https://www.unrealengine.com/marketplace/en-US/product/dataconfig-json-asset" title="DataConfig JSON Asset">DataConfig JSON Asset</a> on UE Marketplace. It's a premium plugin for importing JSON to UE data assets.</p>
<p>You can reach us by email to <a href="mailto:hislowburn@gmail.com">hislowburn@gmail.com</a> or on twitter <a href="https://twitter.com/slowburndev">@slowburndev</a>. </p>
<p>We'll setup a section showcasing projects using DataConfig in the future.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
