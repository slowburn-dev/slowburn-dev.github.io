<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DataConfig Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Serialization framework for Unreal Engine Property System that just works!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item "><a href="Examples.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li class="chapter-item "><a href="Integration.html"><strong aria-hidden="true">3.</strong> Integration</a></li><li class="chapter-item "><a href="Design.html"><strong aria-hidden="true">4.</strong> Design</a></li><li class="chapter-item "><a href="Programming/index.html"><strong aria-hidden="true">5.</strong> Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Programming/CoreTypes.html"><strong aria-hidden="true">5.1.</strong> Core Types</a></li><li class="chapter-item "><a href="Programming/ErrorHandling.html"><strong aria-hidden="true">5.2.</strong> Error Handling</a></li><li class="chapter-item "><a href="Programming/Env.html"><strong aria-hidden="true">5.3.</strong> Env</a></li><li class="chapter-item "><a href="Programming/BuiltinReaderWriters.html"><strong aria-hidden="true">5.4.</strong> Built-in Reader and Writers</a></li><li class="chapter-item "><a href="Programming/Deserializer.html"><strong aria-hidden="true">5.5.</strong> Deserializer</a></li></ol></li><li class="chapter-item "><a href="Deserialize/index.html"><strong aria-hidden="true">6.</strong> Deserialize</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Deserialize/DeserializeJSON.html"><strong aria-hidden="true">6.1.</strong> Deserialize JSON</a></li><li class="chapter-item "><a href="Deserialize/PipeDeserialize.html"><strong aria-hidden="true">6.2.</strong> Pipe Deserialize</a></li></ol></li><li class="chapter-item "><a href="Extra/index.html"><strong aria-hidden="true">7.</strong> Extra</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Extra/DataConfigExtra.html"><strong aria-hidden="true">7.1.</strong> DataConfigExtra</a></li><li class="chapter-item "><a href="Extra/DataConfigEditorExtra.html"><strong aria-hidden="true">7.2.</strong> DataConfigEditorExtra</a></li></ol></li><li class="chapter-item "><a href="License.html"><strong aria-hidden="true">8.</strong> License</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">DataConfig Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#dataconfig-book" id="dataconfig-book">DataConfig Book</a></h1>
<p><strong>Serialization framework for Unreal Engine Property System that just works!</strong></p>
<p><a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig"><strong>DataConfig</strong></a> is a serialization framework built on top of Unreal Engine's Property System. It aims to be friendly and robust while offering good performance. </p>
<h2><a class="header" href="#getting-started" id="getting-started">Getting Started.</a></h2>
<ul>
<li>See: <a href="Examples.html">Examples</a> to look at some code.</li>
<li>See: <a href="Integration.html">Integration</a> for quick integration guide.</li>
<li>See: <a href="Design.html">Design</a> for more context about the project.</li>
</ul>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p><strong>DataConfig</strong> is released under a free and permissive license. But we really appreciate you to credit us if you find it useful. See <a href="License.html">License</a> for details</p>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>This page shows some short and quick examples showcasing DataConfig API usage and features. All code shown here can be found in the sources.</p>
<h2><a class="header" href="#json-deserialization" id="json-deserialization">JSON Deserialization</a></h2>
<p>This is the example shown on front page. Given the struct<code>FDcTestExampleStruct</code>:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.h
UENUM()
enum class EDcTestExampleEnum
{
    Foo, Bar, Baz
};

USTRUCT()
struct FDcTestExampleStruct
{
    GENERATED_BODY()
    UPROPERTY() FString StrField;
    UPROPERTY() EDcTestExampleEnum EnumField;
    UPROPERTY() TArray&lt;FColor&gt; Colors;
};
</code></pre>
<p>We can deserialize an instance from JSON with the snippet below:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
        &quot;EnumField&quot; : &quot;Bar&quot;,
        &quot;Colors&quot; : [
            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
        ]
    }
)&quot;);

FDcTestExampleStruct Dest;

//  create and setup a deserializer
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);
Deserializer.AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(DcExtra::PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(DcExtra::HandlerColorDeserialize)
);

//  prepare context for this run
FDcPropertyDatum Datum(FDcTestExampleStruct::StaticStruct(), &amp;Dest);
FDcJsonReader Reader(Str);
FDcPropertyWriter Writer(Datum);

FDcDeserializeContext Ctx;
Ctx.Reader = &amp;Reader;
Ctx.Writer = &amp;Writer;
Ctx.Deserializer = &amp;Deserializer;
Ctx.Properties.Push(Datum.Property);
DC_TRY(Ctx.Prepare());

//  kick off deserialization
DC_TRY(Deserializer.Deserialize(Ctx));

//  validate results
check(Dest.StrField == TEXT(&quot;Lorem ipsum dolor sit amet&quot;));
check(Dest.EnumField == EDcTestExampleEnum::Bar);
check(Dest.Colors[0] == FColor::Red);
check(Dest.Colors[1] == FColor::Green);
check(Dest.Colors[2] == FColor::Blue);
</code></pre>
<p>Note that <code>EDcTestExampleEnum</code> is deserialized by its name and <code>FColor</code> is deserialized from a html color string like <code>#RRGGBBAA</code>.</p>
<p>Say if we accidentally mistyped the <code>EnumField</code> value:</p>
<pre><code class="language-json">{
    &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
    &quot;EnumField&quot; : &quot;Far&quot;,
</code></pre>
<p>It would fail gracefully with diagnostics:</p>
<pre><code># DataConfig Error: Enum name not found in enum type: EDcTestExampleEnum, Actual: 'Far'
- [JsonReader] --&gt; &lt;in-memory&gt;4:25
   2 |    {
   3 |        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
   4 |        &quot;EnumField&quot; : &quot;Far&quot;,
     |                           ^
   5 |        &quot;Colors&quot; : [
   6 |            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
- [PropertyWriter] Writing property: (FDcTestExampleStruct)$root.(EEDcTestExampleEnum)EnumField
</code></pre>
<h2><a class="header" href="#custom-deserialization-logic" id="custom-deserialization-logic">Custom Deserialization Logic</a></h2>
<p>To deserialize <code>FColor</code> with  <code>#RRGGBBAA</code> we'll need to provide custom logic to the deserializer. First you'll need to implement a  <code>FDcDeserializePredicate</code> delegate to pick out <code>FColor</code>:</p>
<pre><code class="language-c++">//	DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
EDcDeserializePredicateResult PredicateIsColorStruct(FDcDeserializeContext&amp; Ctx)
{
	UScriptStruct* Struct = DcPropertyUtils::TryGetStructClass(Ctx.TopProperty());
	return Struct &amp;&amp; Struct == TBaseStructure&lt;FColor&gt;::Get()
		? EDcDeserializePredicateResult::Process
		: EDcDeserializePredicateResult::Pass;
}
</code></pre>
<p>Then we'll need to implement a <code>FDcDeserializeDelegate</code> to deserialize a <code>FColor</code>. Here we'll do it by writing through <code>R/G/B/A</code> fields by name with the <code>FDcWriter</code> API.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriterAPI&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
	DC_TRY(Ctx.Writer-&gt;WriteStructRoot(FDcStructStat{ TEXT(&quot;Color&quot;), FDcStructStat::WriteCheckName }));

	DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;B&quot;)));
	DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.B));

	DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;G&quot;)));
	DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.G));

	DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;R&quot;)));
	DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.R));

	DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;A&quot;)));
	DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.A));

	DC_TRY(Ctx.Writer-&gt;WriteStructEnd(FDcStructStat{ TEXT(&quot;Color&quot;), FDcStructStat::WriteCheckName }));

	return DcOk();
}
</code></pre>
<p>Then we'll need to register these pair of delegates to the <code>FDcDeserializer</code>.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);
Deserializer.AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(DcExtra::PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(DcExtra::HandlerColorDeserialize)
);
</code></pre>
<p>And then it's done. It would work recursively on <code>FColor</code> everywhere, like in <code>UCLASS/USTRUCT</code> members, in <code>TArray/TSet</code> and in <code>TMap</code> as key or values.</p>
<h2><a class="header" href="#writer-api-alternatives" id="writer-api-alternatives">Writer API Alternatives</a></h2>
<p>In the example above we're deserializing <code>FColor</code> by writing into its member fields separately, which is a bit dumb. In this case DataConfig do support better alternatives.</p>
<p>Since we know that <code>FColor</code> is POD type we can construct one by filling in correct bit pattern. In this case <code>FDcPropertyWriter</code> allow struct property to be coerced from a blob:</p>
<pre><code class="language-c++">//	DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriteBlob&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
	return Ctx.Writer-&gt;WriteBlob({
		(uint8*)&amp;Color,	// treat `Color` as opaque blob data
		sizeof(FColor)
	});
}
</code></pre>
<p>Alternatively we can get <code>FProperty</code> and data pointer in place and setting the value through Unreal's <code>FProperty</code> API:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriteDataEntry&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
	FDcPropertyDatum Datum;
	DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

	Datum.CastFieldChecked&lt;FStructProperty&gt;()-&gt;CopySingleValue(Datum.DataPtr, &amp;Color);
	return DcOk();
}
</code></pre>
<p>Note that we already know that <code>Datum.DataPtr</code> points to a allocated <code>FColor</code> instance. Thus we can simply cast it into a <code>FColor*</code> and directly manipulate the pointer.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WritePointer&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
	FDcPropertyDatum Datum;
	DC_TRY(Ctx.Writer-&gt;WriteDataEntry(FStructProperty::StaticClass(), Datum));

	FColor* ColorPtr = (FColor*)Datum.DataPtr;
	*ColorPtr = Color;	// deserialize by assignment

	return DcOk();
}
</code></pre>
<h2><a class="header" href="#debug-dump" id="debug-dump">Debug Dump</a></h2>
<p><code>DcAutomationUtils::DumpToLog()</code> can dump a <code>FDcPropertyDatum</code> to a string representation, in which <code>FDcPropertyDatum</code> is simply a <code>FProperty</code> + <code>void*</code> pair that can represent anything in the property system:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FVector Vec(1.0f, 2.0f, 3.0f);
FDcPropertyDatum VecDatum(TBaseStructure&lt;FVector&gt;::Get(), &amp;Vec);

DcAutomationUtils::DumpToLog(VecDatum);
</code></pre>
<p>Output would be:</p>
<pre><code>-----------------------------------------
# Datum: 'ScriptStruct', 'Vector'
&lt;StructRoot&gt; 'Vector'
|---&lt;Name&gt; 'X'
|---&lt;Float&gt; '1.000000'
|---&lt;Name&gt; 'Y'
|---&lt;Float&gt; '2.000000'
|---&lt;Name&gt; 'Z'
|---&lt;Float&gt; '3.000000'
&lt;StructEnd&gt; 'Vector'
-----------------------------------------
</code></pre>
<p>Additionally we wrapped this into <code>gDcDebug</code> that can be invoked in MSVC immediate window. Calling it during debug would dump into MSVC <strong>Output</strong> window:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Automation/DcAutomationUtils.h
struct DATACONFIGCORE_API FDcDebug
{
	FORCENOINLINE void DumpStruct(char* StructNameChars, void* Ptr);
	FORCENOINLINE void DumpObject(UObject* Obj);
	FORCENOINLINE void DumpDatum(void* DatumPtr);
};

///	Access `gDcDebugg` in MSVC immediate window:
///
///	- in monolith builds:
///	gDcDebug.DumpObject(Obj)
///
///	- in DLL builds prefix with dll name:
///	({,,UE4Editor-DataConfigCore}gDcDebug).DumpObject(ObjPtr)

extern FDcDebug gDcDebug;
</code></pre>
<p>Here's an animated demo showing dumping the vector above <em>during debug break</em> in MSVC:</p>
<p><img src="Images/Examples-DebugDumpVecDatum.png" alt="Examples-DebugDumpVecDatum" /></p>
<p>The full expression to evaluate is:</p>
<pre><code>({,,UE4Editor-DataConfigCore}gDcDebug).DumpDatum(&amp;VecDatum)
</code></pre>
<p>We need DLL name to locate <code>gDcDebug</code> in a non monolith build.</p>
<h2><a class="header" href="#more" id="more">More</a></h2>
<p>There's more detailed examples in <a href="./Extra/DataConfigExtra.html">DataConfigExtra</a> and <a href="./Extra/DataConfigEditorExtra.html">DataConfigEditorExtra</a></p>
<h1><a class="header" href="#integration" id="integration">Integration</a></h1>
<p>This page shows integration instructions for DataConfig. At the moment it supports these the engine versions below:</p>
<ul>
<li>UE 4.25</li>
<li>UE 4.26</li>
</ul>
<h2><a class="header" href="#integrate-dataconfig-plugin" id="integrate-dataconfig-plugin">Integrate <code>DataConfig</code> Plugin</a></h2>
<p>The easiest way to try out DataConfig is to add it as a plugin into your C++ project.  In this section we'll walk through the steps of integrating DataConfig plugin into a empty UE C++ Project.</p>
<ol>
<li>
<p>Get a copy of <a href="https://github.com/slowburn-dev/DataConfig" title="slowburn-dev/DataConfig">the repository</a>. Then copy  <code>./DataConfig</code> (where <code>DataConfig.uplugin</code> is located) into your project's <code>Plugins</code> directory.</p>
</li>
<li>
<p>Restart your project. There should be a prompt to compile plugin sources. Confirm and wait until your project launches. Then open <code>Settings -&gt; Plugins</code> you should see <strong>Data Config</strong> listed under Project Editor category.</p>
<p><img src="Images/Integration-DataConfigPlugin.png" alt="Integration-DataConfigPlugin" /></p>
</li>
<li>
<p>The plugin comes with a set of tests. Open menu <code>Window -&gt; Developer Tools  -&gt; Session Frontend</code>. Find and run the <code>DataConfig</code> tests and it should all pass.</p>
<p><img src="Images/Integration-DataConfigAutomations.png" alt="Integration-DataConfigAutomations" /></p>
</li>
</ol>
<h2><a class="header" href="#integrate-dataconfigcore-module" id="integrate-dataconfigcore-module">Integrate <code>DataConfigCore</code> Module</a></h2>
<p>DataConfig is packed into a plugin to bundle automation tests with a few assets. You're encouraged to integrate only the <code>DataConfigCore</code> module. It contains all core features with minimal dependencies. </p>
<p>Most projects should has a editor module already setup. In this section we'll go through the steps of integrating <code>DataConfigCore</code> and build it with the project's <code>FooProjectEditor</code> module.</p>
<ol>
<li>
<p>Get a copy of this repository. Then copy <code>DataConfig/Source/DataConfigCore</code> into your project's <code>Source</code> directory.</p>
</li>
<li>
<p>Edit <code>FooProjectEditor.Build.cs</code> add add <code>DataConfigCore</code> as an extra module:</p>
<pre><code class="language-c++">using UnrealBuildTool;

public class FooProjectEditor : ModuleRules
{
    public FooProjectEditor(ReadOnlyTargetRules Target) : base(Target)
    {
        PublicDependencyModuleNames.AddRange(new string[] { 
			//...
            &quot;DataConfigCore&quot;,	// &lt;- add this
            });
    }
}
</code></pre>
</li>
<li>
<p>DataConfig needs to be explicitly initialized before use. Find <code>FooProjectEditor</code> module's start up and shut down methods and setup DataConfig accordingly.</p>
<pre><code class="language-c++">#include &quot;DataConfig/DcEnv.h&quot;
#include &quot;DataConfig/Automation/DcAutomationUtils.h&quot;

void FFooProjectEditorModule::StartupModule()
{
    // ...
    DcStartUp(EDcInitializeAction::SetAsConsole);
    // dump a FVector to try it out
    FVector Vec(1.0f, 2.0f, 3.0f);
    FDcPropertyDatum VecDatum(TBaseStructure&lt;FVector&gt;::Get(), &amp;Vec);

    DcAutomationUtils::DumpToLog(VecDatum);
}

void FFooProjectEditorModule::ShutdownModule()
{
    // ...
	DcShutDown();
}
</code></pre>
</li>
<li>
<p>Rebuild the project and restart the editor. Open <code>Output Log</code> and use <code>LogDataConfigCore</code> filter and find the dump output. </p>
<p><img src="Images/Integration-DataConfigCoreOutput.png" alt="Integration-DataConfigCoreOutput" /></p>
</li>
</ol>
<p>You can refer to <code>DataConfigEditorExtra</code> module for more detailed integration options.</p>
<h1><a class="header" href="#design" id="design">Design</a></h1>
<p>This page documents the overall design, goals and reasoning around DataConfig.</p>
<h2><a class="header" href="#rationale" id="rationale">Rationale</a></h2>
<p>At the time we started this project we're looking for a JSON parser that:</p>
<ul>
<li>Supports a relaxed JSON spec, i.e. comment and trailing comma.</li>
<li>Supports custom deserialization logic, i.e. deserialize <code>FColor</code> from <code>#RRGGBBAA</code>.</li>
<li>Supports UE4 instanced sub objects and polymorphism.</li>
</ul>
<p>Eventually we implemented all these in DataConfig. We also tried not limit this to be a JSON parser but deliver as a set of tools for reading-from and writing-to the property system. </p>
<h2><a class="header" href="#manifesto" id="manifesto">Manifesto</a></h2>
<ul>
<li>
<p>Deliver as a quality C++ source library.</p>
<p>DataConfig should ship with no UI nor tooling code. Users are expected to integrate only <code>DataConfigCore</code> as a source module. We're intentionally limiting the scope of DataConfig to be a &quot;C++ Library&quot;. Our users should be proficient UE4 C++ programmers.</p>
<ul>
<li>DataConfig should ship with good test and documentation coverage.</li>
<li>DataConfig follows idiomatic UE4 C++ conventions and has no external dependency.</li>
<li><code>DataConfigCore</code> only depends on <code>Core</code> and <code>CoreUObject</code> and can be used in standalone <code>Program</code> targets.</li>
<li>DataConfig API are <code>UObject</code> free and stack friendly.</li>
<li>Built-in features serve as examples and sensible defaults. Users are expected to write on their own <code>Reader/Writer/Handlers</code>.</li>
</ul>
</li>
<li>
<p>Runtime performance is <em>not</em> top priority.</p>
<p>We expect users to use DataConfig in a offline, editor only scenario. In this use case we favor some other aspects over runtime performance:</p>
<ul>
<li>Idiomatic. We follow <a href="https://docs.unrealengine.com/en-US/ProductionPipelines/DevelopmentSetup/CodingStandard/index.html" title="UE4 Coding Standard">UE4 c++ coding conventions</a> and keep core dependency to only <code>Core</code> and <code>CoreUObject</code>.</li>
<li>Friendly. When processing invalid data and invalid API usage DataConfig should not crash. It should fail explicitly with detailed context and diagnostics.</li>
<li>Small code size / fast compile time. DataConfig try not to expose template API. <code>TDcJsonReader</code> is explicit instantiated with its definition in private files.</li>
<li>Light memory footprint. Our JSON parser do stream parsing and would <em>not</em> construct the loaded JSON document in memory at all.</li>
</ul>
</li>
<li>
<p>Works with whatever property system supports.</p>
<p>The idea is that DataConfig supports everything that can be marked with <code>UCLASS/USTRUCT/UPROPERTY/UENUM</code> macros, which covers the full data model of the property system.</p>
<p>Fields like weak object reference and delegates doesn't make much sense to be serialized into textual format. But turns out supporting the full data model makes DataConfig suitable to some other tasks like debug dump and in-memory data wrangling.</p>
<p>This also means that DataConfig only focus on reading from and writing into C++ data structures. For example we don't have a DOM or object like API for JSON at all. The only use case DataConfig supports is to deserialize from JSON into native C++ objects.</p>
</li>
</ul>
<h1><a class="header" href="#programming-guides" id="programming-guides">Programming Guides</a></h1>
<p>This section contains doc for programming DataConfig APIs.</p>
<h1><a class="header" href="#core-types" id="core-types">Core Types</a></h1>
<p>This page documents core data types in <code>DataConfigCore</code></p>
<h2><a class="header" href="#dataconfig-data-model" id="dataconfig-data-model">DataConfig Data Model</a></h2>
<p>Conceptually the DataConfig data model is defined by 3 C++ types:</p>
<ol>
<li><code>EDcDataEntry</code> - enum covers every possible data type.</li>
<li><code>FDcReader</code> - methods to read from the data model.</li>
<li><code>FDcWriter</code> - methods to write into the data model.</li>
</ol>
<p>And that's it. The obvious missing thing is a DOM like object that you can random access and serialize into -  we choose to not implement that and it's crucial to understand this to get to know how DataConfig works.</p>
<h2><a class="header" href="#edcdataentry" id="edcdataentry"><code>EDcDataEntry</code></a></h2>
<p>The enum covers all possible types:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/DcTypes.h
UENUM()
enum class EDcDataEntry : uint16
{
	Nil,

	Bool,
	Name,
	String,
	Text,
	Enum,

	Float,
	Double,

	Int8,
	Int16,
	Int32,
	Int64,

	UInt8,
	UInt16,
	UInt32,
	UInt64,

	//	Struct
	StructRoot,
	StructEnd,

	//	Class
	ClassRoot,
	ClassEnd,

	//	Map
	MapRoot,
	MapEnd,

	//	Array
	ArrayRoot,
	ArrayEnd,

	//	Set,
	SetRoot,
	SetEnd,

	//	Reference
	ObjectReference,
	ClassReference,

	WeakObjectReference,
	LazyObjectReference,
	SoftObjectReference,
	SoftClassReference,
	InterfaceReference,

	//	Delegates
	Delegate,
	MulticastInlineDelegate,
	MulticastSparseDelegate,

	//	Field
	FieldPath,

	//	Extension
	Blob,

	//	End
	Ended,
};
</code></pre>
<p>Most enumerators directly maps to a <code>FProperty</code> type:</p>
<ul>
<li><code>EDcDataEntry::Bool</code>  - <code>FBoolProperty</code></li>
<li><code>EDcDataEntry::Name</code> - <code>FNameProperty</code></li>
<li><code>EDcDataEntry::String</code> - <code>FStrProperty</code></li>
<li><code>EDcDataEntry::ArrayRoot/ArrayEnd</code>- <code>FArrayProperty</code></li>
</ul>
<p>It should've covered all possible <code>FProperty</code> types. Addition to that there're a few that has </p>
<ul>
<li><code>EDcDataEntry::Nil</code> -  It's added to match <code>null</code> in JSON, and it's also used to explicitly represent null object reference.</li>
<li><code>EDcDataEntry::Ended</code> - It's a phony type that is returned when there's no more data or reader/writer is in a invalid state.</li>
<li><code>EDcDataEntry::Blob</code> - It's a extension to allow direct memory read/write from given fields. </li>
</ul>
<h2><a class="header" href="#fdcreader" id="fdcreader"><code>FDcReader</code></a></h2>
<p><code>FDcReader</code> is the one and only way to read from DataConfig data model. For every enumerator in <code>EDcDataEntry</code> there's a member method on <code>FDcReader</code> to from it.</p>
<p>Here we set up a simple struct trying out the reader methods:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.h
USTRUCT()
struct FDcTestExampleSimple
{
	GENERATED_BODY()

	UPROPERTY() FString StrField;
	UPROPERTY() int IntField;
};

// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcTestExampleSimple SimpleStruct;
SimpleStruct.StrField = TEXT(&quot;Foo Str&quot;);
SimpleStruct.IntField = 253;
</code></pre>
<p>Since we know exactly how the <code>FDcTestExampleSimple</code> looks like we can manually arrange the read calls:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcPropertyReader Reader(FDcPropertyDatum(FDcTestExampleSimple::StaticStruct(), &amp;SimpleStruct));

DC_TRY(Reader.ReadStructRoot(&amp;Struct));   // `FDcTestExampleSimple` Struct Root

    DC_TRY(Reader.ReadName(&amp;FieldName));  // 'StrField' as FName
    DC_TRY(Reader.ReadString(&amp;StrValue)); // &quot;Foo STr&quot;

    DC_TRY(Reader.ReadName(&amp;FieldName));  // 'IntField' as FName
    DC_TRY(Reader.ReadInt32(&amp;IntValue));  // 253

DC_TRY(Reader.ReadStructEnd(&amp;Struct));    // `FDcTestExampleSimple` Struct Root
</code></pre>
<p>In the example above <code>FDcReader</code> behave like a iterator as each <code>ReadXXX()</code> call emits value and move the internal cursor into the next slot. In case we're reading a unknown structure, we can use <code>FReader::PeekRead()</code> to peek what's coming next.</p>
<h2><a class="header" href="#fdcwriter" id="fdcwriter"><code>FDcWriter</code></a></h2>
<p><code>FDcWriter</code> is the counter part of writing into the data config model. To write into the example instance above:</p>
<pre><code class="language-c++">DC_TRY(Writer.WriteStructRoot(FDcStructStat{})); // `FDcTestExampleSimple` Struct Root

    DC_TRY(Writer.WriteName(TEXT(&quot;StrField&quot;)));      // 'StrField' as FName
    DC_TRY(Writer.WriteString(TEXT(&quot;Alt Str&quot;)));     // &quot;Foo STr&quot;

    DC_TRY(Writer.WriteName(TEXT(&quot;IntField&quot;)));      // 'IntField' as FName
    DC_TRY(Writer.WriteInt32(233));                  // 233

DC_TRY(Writer.WriteStructEnd(FDcStructStat{}));  // `FDcTestExampleSimple` Struct Root
</code></pre>
<p>There's also <code>FDcWriter::PeekRead()</code> to query whether it's possible to write given data type.</p>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>DataConfig provide <code>FDcReader</code> and <code>FDcWriter</code> to access the property system. It can be considered as a friendly alternative to the property system API. It's also how we implemented flexible JSON deserialization, which would be described in later chapters.</p>
<h1><a class="header" href="#error-handling" id="error-handling">Error Handling</a></h1>
<p>Proper error handling is crucial to implement robust serialization as it needs to deal with unknown user input. DataConfig also provide diagnostic to help users quickly pin down common errors like typo or missing colons in JSON. Here's an example:</p>
<pre><code># DataConfig Error: Enum name not found in enum type: EDcTestExampleEnum, Actual: 'Far'
- [JsonReader] --&gt; &lt;in-memory&gt;4:25
   2 |    {
   3 |        &quot;StrField&quot; : &quot;Lorem ipsum dolor sit amet&quot;,
   4 |        &quot;EnumField&quot; : &quot;Far&quot;,
     |                           ^
   5 |        &quot;Colors&quot; : [
   6 |            &quot;#FF0000FF&quot;, &quot;#00FF00FF&quot;, &quot;#0000FFFF&quot;
- [PropertyWriter] Writing property: (FDcTestExampleStruct)$root.(EEDcTestExampleEnum)EnumField
</code></pre>
<p>Internally DataConfig is applying a consistent error handling strategy across all API. User code are expected to follow along.</p>
<h2><a class="header" href="#returning-fdcresult" id="returning-fdcresult">Returning <code>FDcResult</code></a></h2>
<p>The gist is that if a method can fail, return a <code>FDcResult</code>, which is a simple struct:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/DcTypes.h
struct DATACONFIGCORE_API DC_NODISCARD FDcResult
{
    enum class EStatus : uint8
    {
        Ok,
        Error
    };

    EStatus Status;

    FORCEINLINE bool Ok() const
    {
        return Status == EStatus::Ok;
    }
};

//  See FDcReader's methods as example
// DataConfig/Source/DataConfigCore/Public/DataConfig/Reader/DcReader.h
struct DATACONFIGCORE_API FDcReader
{
    //...
    virtual FDcResult ReadBool(bool* OutPtr);
    virtual FDcResult ReadName(FName* OutPtr);
    virtual FDcResult ReadString(FString* OutPtr);
    virtual FDcResult ReadText(FText* OutPtr);
    virtual FDcResult ReadEnum(FDcEnumData* OutPtr);
    //...
};
</code></pre>
<p>Then use <code>DC_TRY</code> to call these kinds of functions. The macro itself does early return when result is not ok:</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/DcTypes.h
#define DC_TRY(expr)                        \
    do {                                    \
        ::FDcResult Ret = (expr);           \
        if (!Ret.Ok()) {                    \
            return Ret;                     \
        }                                   \
    } while (0)

//  Example of calling methods returning `FDcResult`
// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
template&lt;&gt;
FDcResult TemplatedWriteColorDispatch&lt;EDcColorDeserializeMethod::WriterAPI&gt;(const FColor&amp; Color, FDcDeserializeContext&amp; Ctx)
{
    DC_TRY(Ctx.Writer-&gt;WriteStructRoot(FDcStructStat{ TEXT(&quot;Color&quot;), FDcStructStat::WriteCheckName }));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;B&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.B));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;G&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.G));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;R&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.R));

    DC_TRY(Ctx.Writer-&gt;WriteName(TEXT(&quot;A&quot;)));
    DC_TRY(Ctx.Writer-&gt;WriteUInt8(Color.A));

    DC_TRY(Ctx.Writer-&gt;WriteStructEnd(FDcStructStat{ TEXT(&quot;Color&quot;), FDcStructStat::WriteCheckName }));

    return DcOk();
}
</code></pre>
<p>This pattern is similar to <a href="https://ned14.github.io/outcome/">Outcome</a> and <a href="https://wg21.link/p0323">std::expected</a> except we give up using the return value. Return values should be passed through reference or pointers in function arguments.</p>
<h2><a class="header" href="#diagnostics" id="diagnostics">Diagnostics</a></h2>
<p>When implementing a method that returns <code>FDcResult</code> you have 2 options:</p>
<ul>
<li>Return <code>DcOk()</code> on succeed.</li>
<li>Return <code>DC_FAIL(&lt;Catetory&gt;, &lt;ErrId&gt;)</code> on error.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FDcResult Succeed() {
    // succeed
    return DcOk();
}

FDcResult Fail() {
    // fail !
    return DC_FAIL(DcDCommon, Unexpected1) &lt;&lt; &quot;My Custom Message&quot;;
}
</code></pre>
<p>In the examples above <code>DcDCommon</code> and <code>Unexpected1</code> are called <strong>error category</strong> and <strong>error id</strong> respectively. <code>DcDCommon</code> is a built-in error category:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Diagnostic/DcDiagnosticCommon.h
namespace DcDCommon
{
static const uint16 Category = 0x1;

enum Type : uint16
{
    //...
    Unexpected1,
};

} // namespace DcDCommon

// DataConfig/Source/DataConfigCore/Private/DataConfig/Diagnostic/DcDiagnosticCommon.cpp
namespace DcDCommon
{
static FDcDiagnosticDetail _CommonDetails[] = {
    // ...
    { Unexpected1, TEXT(&quot;Unexpected: '{0}'&quot;) },
};
</code></pre>
<p>Note that we can pipe argument into the diagnostic. The diagnostic reported by invoking <code>Fail()</code> would be like:</p>
<pre><code>* # DataConfig Error: Unexpected: 'My Custom Message'
</code></pre>
<h2><a class="header" href="#conclusion-1" id="conclusion-1">Conclusion</a></h2>
<p>DataConfig uses <code>FDcResult</code>, <code>DC_TRY</code>, <code>DC_FAIL</code> for error handling. It's lightweight and relatively easy to grasp. There's still some limitations in this regard:</p>
<ul>
<li><code>FDcResult</code> occupied the return position making passing value to parent a bit cumbersome.</li>
<li>For now we always stop as the first error. There's no plan to support error recovery.</li>
</ul>
<p>Some closing notes:</p>
<ul>
<li>Reported diagnostics get queued. You'll need to call <code>FDcEnv::FlushDiags()</code> to flush them to consumers.</li>
<li>See <code>DcDiagnosticExtra.h/cpp</code> for how to register user category.</li>
<li>See <code>DcEditorExtraModule.cpp - FDcMessageLogDiagnosticConsumer</code> for custom diagnostic handler and formatting.</li>
</ul>
<h1><a class="header" href="#env" id="env">Env</a></h1>
<p>DataConfig put most global state into a stack of <code>FDcEnv</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/DcEnv.h
struct DATACONFIGCORE_API FDcEnv
{
    TArray&lt;FDcDiagnostic&gt; Diagnostics;

    TSharedPtr&lt;IDcDiagnosticConsumer&gt; DiagConsumer;

    TArray&lt;FDcReader*&gt; ReaderStack;
    TArray&lt;FDcWriter*&gt; WriterStack;

    bool bExpectFail = false;   // mute debug break

    FDcDiagnostic&amp; Diag(FDcErrorCode InErr);

    void FlushDiags();

    FORCEINLINE FDcDiagnostic&amp; GetLastDiag() 
    {
        checkf(Diagnostics.Num(), TEXT(&quot;&lt;empty diagnostics&gt;&quot;));
        return Diagnostics.Last();
    }

    ~FDcEnv();
};
</code></pre>
<p>DataConfig needs explicit initializatioon before use. This is done through manually <code>DcStartUp()</code>. There's also a paired <code>DcShutdown()</code> that should be called when DataConfig isn't used anymore. Here's an example:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DcEditorExtraModule.cpp
void FDcEditorExtraModule::StartupModule()
{
    UE_LOG(LogDataConfigCore, Log, TEXT(&quot;DcEditorExtraModule module starting up&quot;));
    DcRegisterDiagnosticGroup(&amp;DcDExtra::Details);
    DcRegisterDiagnosticGroup(&amp;DcDEditorExtra::Details);

    DcStartUp(EDcInitializeAction::Minimal);
    //...
}

void FDcEditorExtraModule::ShutdownModule()
{
    DcShutDown();
    //...
}
</code></pre>
<p>The active <code>FDcEnv</code> is accessed by calling global function <code>DcEnv()</code>. Inside the Env:</p>
<ul>
<li><code>Diagnostics</code>: all diagnostics are flushed into env.</li>
<li><code>DiagConsumer</code>: diagnostic handler, format and print diagnostic to log or <code>MessageLog</code> or even on screen.</li>
<li><code>ReaderStack/WriterStack</code>: used to pass along reader/writer down the callstack. See <code>FScopedStackedReader</code> uses for example.</li>
<li>... and everything else.</li>
</ul>
<p>You can use <code>DcPushEnv()</code> to create new env then destroy it calling <code>DcPopEnv()</code>. At this moment it's mostly used to handle reentrant during serialization. See <code>FDcScopedEnv</code> uses for examples.</p>
<h1><a class="header" href="#built-in-reader-and-writers" id="built-in-reader-and-writers">Built-in Reader and Writers</a></h1>
<p>This page briefly walks through <code>FDcReader/FDcWriter</code> classes bundled in <code>DataConfigCore</code>.</p>
<h2><a class="header" href="#fdcpipevisitor-and-fdcprettyprintwriter" id="fdcpipevisitor-and-fdcprettyprintwriter"><code>FDcPipeVisitor</code> and <code>FDcPrettyPrintWriter</code></a></h2>
<p><code>FDcPipeVisitor</code> takes a <code>FDcReader</code> and a <code>FDcWriter</code> then start peek-read-write loop until it peeks <code>EDcDataEntry::Ended</code> from reader or an error happens.</p>
<p>Then there's <code>FDcPrettyPrintWriter</code> that dumps everything write into it as string.</p>
<p>Combining these two we get a way to dump arbitrary <code>FDcReader</code> into a string!. This is how built-in debug dump features are implemented:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Private/DataConfig/Automation/DcAutomationUtils.cpp
void DumpToOutputDevice(...)
{
    //...
    FDcPropertyReader PropReader(Datum);
    FDcPrettyPrintWriter PrettyWriter(Output);
    FDcPipeVisitor PrettyPrintVisit(&amp;PropReader, &amp;PrettyWriter);

    if (!PrettyPrintVisit.PipeVisit().Ok())
        ScopedEnv.Get().FlushDiags();
    //...
}
</code></pre>
<p>In following sections we'll see some other usages of the pipe visitor.</p>
<h2><a class="header" href="#fdcpropertyreaderfdcpropertywriter" id="fdcpropertyreaderfdcpropertywriter"><code>FDcPropertyReader/FDcPropertyWriter</code></a></h2>
<p>This pair of classes is used to access the actual Unreal Property System. Both takes a <code>FDcPropertyDatum</code> to construct:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyDatum.h
struct DATACONFIGCORE_API FDcPropertyDatum
{
    FFieldVariant Property;
    void* DataPtr;
    //...
}
</code></pre>
<p>It's simply a property plus opaque pointer pair. These constructs are also called &quot;Fat Pointers&quot;. Turns out this is enough to represent everything in the Property System. Property reader/writer needs one of these as a root and start reading/writing from there.</p>
<p>A simple use case of these is to roundtrip two objects so that every property in the first one is copied into latter:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestCommon.h
FDcResult DcTestPropertyRoundtrip(...)
{
    FDcPropertyReader Reader(FromDatum);
    FDcPropertyWriter Writer(ToDatum);
    //...
    FDcPipeVisitor RoundtripVisit(&amp;Reader, &amp;Writer);
    return RoundtripVisit.PipeVisit();
}
</code></pre>
<p>There's a quirk that you cannot create a <code>FDcPropertyDatum</code> for stack allocated <code>TArray</code> :</p>
<pre><code class="language-c++">void f()
{
    // this is ok
    FDcTestExampleStruct MyStruct;
    FDcPropertyDatum StructDatum(&amp;FDcTestExampleStruct::StaticStruct(), &amp;MyStruct);

    // this is not
    TArray&lt;int&gt; myArr;
    FDcPropertyDatum myDatum(&amp;???, &amp;myArr);
}
</code></pre>
<p>We can, however, get datum for member <code>TArray</code> and other fields. We'll see related example in later chapters.</p>
<h2><a class="header" href="#fdcjsonreader" id="fdcjsonreader"><code>FDcJsonReader</code></a></h2>
<p>This is the only reader that reads a external textual format. It's also an example showcasing that the DataConfig data model is actually a superset of the property system.</p>
<pre><code class="language-c++">// DataConfig/DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;Str&quot;:    &quot;Fooo&quot;,
        &quot;Number&quot;: 1.875,
        &quot;Bool&quot;:   true
    } 
)&quot;);

FDcJsonReader Reader(Str);

//  calling read methods
FString KeyStr;
FString GotStr;
double GotNumber;
bool GotBool;

DC_TRY(Reader.ReadMapRoot());

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadString(&amp;GotStr));

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadDouble(&amp;GotNumber));

    DC_TRY(Reader.ReadString(&amp;KeyStr));
    DC_TRY(Reader.ReadBool(&amp;GotBool));

DC_TRY(Reader.ReadMapEnd());

//  validate results
check(GotStr == TEXT(&quot;Fooo&quot;));
check(GotNumber == 1.875);
check(GotBool == true);
</code></pre>
<p>In the example above we deserialized a <code>JSON</code> object from string. The first and the last call is <code>ReadMapRoot</code> and <code>ReadMapEnd</code>, which is also used to read Unreal's <code>TMap</code> properties. The difference is that UE's <code>TMap</code> is strictly typed but JSON object values can have arbitrary type. This means that if you use <code>FDcPipeVisitor</code> to pipe a <code>FDcJsonReader</code> into a <code>FDcPropertyWriter</code> it won't work.</p>
<p>The good news is that DataConfig data model is designed to support these use cases. As long as you can use <code>FDcReader/FDcWriter</code> API to describe the format you want to serialize you're good to go. Mapping and conversion between these different shapes of reader/writers are handled by <a href="Programming/./Deserializer.html">deserializers</a>.</p>
<p>Some additional caveats:</p>
<ul>
<li>Similar to Unreal's <code>TJsonReader</code>, we provide <code>TDcJsonReader</code> with 2 specializations:
<ul>
<li><code>FDcJsonReader</code> that reads <code>TCHAR*, FString</code></li>
<li><code>FDcAnsiJsonReader</code> that reads <code>char*</code>.</li>
</ul>
</li>
<li>We're supporting a relaxed superset of JSON:
<ul>
<li>Allow C Style comments, i.e <code>/* block */</code> and <code>// line</code> .</li>
<li>Allow trailing comma, i.e <code>[1,2,3,],</code> .</li>
<li>Allow non object root. You can put a list as the root.</li>
</ul>
</li>
<li>String parsing and number parsing are delegated to Unreal's built-ins:
<ul>
<li>Parse string: <code>FParse::QuotedString()</code></li>
<li>Parse numbers:  <code>TCString::Atof/Strtoi/Strtoi64</code></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#utilities" id="utilities">Utilities</a></h2>
<p>Finally there're some utility reader/writers for various purposes.</p>
<ul>
<li><code>FDcNoopWriter</code> - a writer that does literally nothing. Useful to benchmark reader performance.</li>
<li><code>FDcWeakCompositeWriter</code> - a writer that multiplex into a list of writers. Useful to trace writing calls.</li>
<li><code>FDcPutbackReader</code> - <code>FDcReader</code> doesn't support lookahead. It can only peek next item's type but not value. This class is used to support limited lookahead by <em>putting back</em> read value. It's used in implementing custom deserializer handlers.</li>
</ul>
<h2><a class="header" href="#conclusion-2" id="conclusion-2">Conclusion</a></h2>
<p>You should consider implement new <code>FDcReader/FDcWriter</code> when you want to support a new file format. You can also implement utility reader/writer that nest other reader/writers.</p>
<h1><a class="header" href="#deserializer" id="deserializer">Deserializer</a></h1>
<p>In the <a href="Programming/./BuiltinReaderWriters.html">previous chapter</a> we mentioned that DataConfig data model is a super set of the property system. <code>FDcDeserializer</code> is used to convert different subsets of it into the property system.</p>
<h2><a class="header" href="#context" id="context">Context</a></h2>
<p>A company class to the deserializer is <code>FDcDeserializeContext</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Deserialize/DcDeserializeTypes.h
struct DATACONFIGCORE_API FDcDeserializeContext
{
    //...
    FDcDeserializer* Deserializer;
    FDcReader* Reader;
    FDcPropertyWriter* Writer;
    //...
};
</code></pre>
<p>Comparing to <code>FDcPipeVisitor</code> which takes a <code>FDcReader</code> and a <code>FDcWriter</code>, <code>FDcDeserializeContext</code> takes explicitly a <code>FDcPropertyWriter</code> to construct. The deserializer reads from arbitrary reader but writes only into the property system objects.</p>
<h2><a class="header" href="#handlers" id="handlers">Handlers</a></h2>
<p>Custom deserialize logic is provided through <code>FDcDeserializeDelegate</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Deserialize/DcDeserializeTypes.h
using FDcDeserializeDelegateSignature = FDcResult(*)(FDcDeserializeContext&amp; Ctx);
DECLARE_DELEGATE_RetVal_OneParam(FDcResult, FDcDeserializeDelegate, FDcDeserializeContext&amp;);
</code></pre>
<p>We call these functions <strong>handlers</strong>. Here's a simple one that deserialize booleans:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Private/DataConfig/Deserialize/Handlers/Json/DcJsonPrimitiveDeserializers.cpp
FDcResult HandlerBoolDeserialize(FDcDeserializeContext&amp; Ctx)
{
    EDcDataEntry Next;
    DC_TRY(Ctx.Reader-&gt;PeekRead(&amp;Next));

    if (Next != EDcDataEntry::Bool)
    {
        return DC_FAIL(DcDDeserialize, DataEntryMismatch)
            &lt;&lt; EDcDataEntry::Bool &lt;&lt; Next;
    }

    bool Value;
    DC_TRY(Ctx.Reader-&gt;ReadBool(&amp;Value));
    DC_TRY(Ctx.Writer-&gt;WriteBool(Value));

    return DcOk();
}
</code></pre>
<p>Note how we propagate errors to the caller by using <code>DC_TRY</code> or fail explicitly by returning <code>DC_FAIL</code>with diagnostic.</p>
<h2><a class="header" href="#predicates" id="predicates">Predicates</a></h2>
<p>In many occasions we want to provide custom deserialization logic for a very specific class. The selection process is done through <code>FDcDeserializePredicate</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Deserialize/DcDeserializeTypes.h
using FDcDeserializePredicateSignature = EDcDeserializePredicateResult(*)(FDcDeserializeContext&amp; Ctx);
DECLARE_DELEGATE_RetVal_OneParam(EDcDeserializePredicateResult, FDcDeserializePredicate, FDcDeserializeContext&amp;);
</code></pre>
<p>We call these <code>Predicates</code>. Here's an example of selecting the bulit-in <code>FColor</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
EDcDeserializePredicateResult PredicateIsColorStruct(FDcDeserializeContext&amp; Ctx)
{
    UScriptStruct* Struct = DcPropertyUtils::TryGetStructClass(Ctx.TopProperty());
    return Struct &amp;&amp; Struct == TBaseStructure&lt;FColor&gt;::Get()
        ? EDcDeserializePredicateResult::Process
        : EDcDeserializePredicateResult::Pass;
}
</code></pre>
<p>Similar to handlers it's checking <code>Ctx.TopProperty()</code> and return a <code>EDcDeserializePredicateResult</code> to decide to process or pass.</p>
<h2><a class="header" href="#deserializer-1" id="deserializer-1">Deserializer</a></h2>
<p>Finally there's the <code>FDcDeserializer</code> which is just a collection of predicates and handlers. It contains no mutable state as those are put in <code>FDcDeserializeContext</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Public/DataConfig/Deserialize/DcDeserializer.h
struct DATACONFIGCORE_API FDcDeserializer : public FNoncopyable
{
    //...
    FDcResult Deserialize(FDcDeserializeContext&amp; Ctx);

    void AddDirectHandler(FFieldClass* PropertyClass, FDcDeserializeDelegate&amp;&amp; Delegate);
    void AddDirectHandler(UClass* PropertyClass, FDcDeserializeDelegate&amp;&amp; Delegate);
    void AddPredicatedHandler(FDcDeserializePredicate&amp;&amp; Predicate, FDcDeserializeDelegate&amp;&amp; Delegate);
    //...
};
</code></pre>
<p><code>AddDirectHandler()</code> registers handlers for a specific property type. Here's an example of registering the <code>HandlerBoolDeserialize</code> above:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Private/DataConfig/Deserialize/DcDeserializerSetup.cpp
Deserializer.AddDirectHandler(
    FBoolProperty::StaticClass(), 
    FDcDeserializeDelegate::CreateStatic(HandlerBoolDeserialize)
);
</code></pre>
<p><code>AddPredicatedHandler()</code> registers a predicate and handler pair. Here's an example of registering the <code>PredicateIsColorStruct</code> predicate above:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
Deserializer.AddPredicatedHandler(
    FDcDeserializePredicate::CreateStatic(DcExtra::PredicateIsColorStruct),
    FDcDeserializeDelegate::CreateStatic(DcExtra::HandlerColorDeserialize)
);
</code></pre>
<p>To start deserialization you need to prepare a <code>FDcDeserializeContext</code> and call <code>FDcDeserializer::Deserialize(Ctx)</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
//  prepare context for this run
FDcPropertyDatum Datum(FDcTestExampleStruct::StaticStruct(), &amp;Dest);
FDcJsonReader Reader(Str);
FDcPropertyWriter Writer(Datum);

FDcDeserializeContext Ctx;
Ctx.Reader = &amp;Reader;
Ctx.Writer = &amp;Writer;
Ctx.Deserializer = &amp;Deserializer;
Ctx.Properties.Push(Datum.Property);
DC_TRY(Ctx.Prepare());

//  kick off deserialization
DC_TRY(Deserializer.Deserialize(Ctx));
</code></pre>
<h2><a class="header" href="#tips-for-writing-handlers" id="tips-for-writing-handlers">Tips for writing handlers</a></h2>
<p>There're some recurring patterns when writing deserialization handlers in DataConfig.</p>
<h3><a class="header" href="#recursive-deserialize" id="recursive-deserialize">Recursive Deserialize</a></h3>
<p>When deserializing a container like <code>USTRUCT</code> root or <code>TArray</code> you'll need to recursively deserialize children properties. Here's how it's done:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigCore/Private/DataConfig/Deserialize/Handlers/Json/DcJsonStructDeserializers.cpp
FDcScopedProperty ScopedValueProperty(Ctx);
DC_TRY(ScopedValueProperty.PushProperty());
DC_TRY(Ctx.Deserializer-&gt;Deserialize(Ctx));
</code></pre>
<p><code>FDcScopedProperty</code> is used to push writer's next property into <code>FDcDeserializeContext::Properties</code> to satisfiy the invariant that <code>FDcDeserializeContext::TopProperty()</code> always points to the current writing property.</p>
<h3><a class="header" href="#provide-topobject" id="provide-topobject">Provide <code>TopObject()</code></a></h3>
<p>Sometimes deserialization will create new <code>UObject</code> along the way. In this case you'll need to fill in <code>FDcDeserializeContext::Objects</code> so the top one is used for <code>NewObject()</code> calls. For transient objecst you can use <code>GetTransientPackage()</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
Ctx.Objects.Push(GetTransientPackage());
</code></pre>
<h3><a class="header" href="#peek-by-value" id="peek-by-value">Peek By Value</a></h3>
<p>Sometimes you want to peek the content of the next entry. For example in <code>DcExtra::HandlerBPDcAnyStructDeserialize()</code> we're dealing with a JSON like this:</p>
<pre><code class="language-json">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeBPClass.cpp
{
    &quot;AnyStructField1&quot; : {
        &quot;$type&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintStructWithColor&quot;,
        &quot;NameField&quot; : &quot;Foo&quot;,
        //...
    }
}
</code></pre>
<p>We want to consume the <code>$type</code> key and its value, and then delegate the logic back to the deserializer. The solution here is first to consume the pair. Then we put back a <code>{</code>  then replace the reader:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeBPClass.cpp
FDcPutbackReader PutbackReader(Ctx.Reader);
PutbackReader.Putback(EDcDataEntry::MapRoot);
TDcStoreThenReset&lt;FDcReader*&gt; RestoreReader(Ctx.Reader, &amp;PutbackReader);

FDcScopedProperty ScopedValueProperty(Ctx);
DC_TRY(ScopedValueProperty.PushProperty());
DC_TRY(Ctx.Deserializer-&gt;Deserialize(Ctx));
</code></pre>
<p>Beware that <code>Putback</code> only support a limited subset of data types.</p>
<h1><a class="header" href="#deserialize" id="deserialize">Deserialize</a></h1>
<p>This section contains doc for existing deserialize handlers sets.</p>
<h1><a class="header" href="#deserialize-json" id="deserialize-json">Deserialize JSON</a></h1>
<p>DataConfig bundles a set of JSON deserialize handlers. Setup by calling <code>DcSetupJsonDeserializeHandlers()</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
#include &quot;DataConfig/Deserialize/DcDeserializerSetup.h&quot;

//...
//  create and setup a deserializer
FDcDeserializer Deserializer;
DcSetupJsonDeserializeHandlers(Deserializer);
</code></pre>
<h2><a class="header" href="#basics" id="basics">Basics</a></h2>
<p>JSON types get mapped into DataConfig data model in a very unsurprising way.</p>
<table><thead><tr><th align="left">JSON Type</th><th>DcDataEntry</th></tr></thead><tbody>
<tr><td align="left">Boolean</td><td>Bool</td></tr>
<tr><td align="left">Null</td><td>Nil</td></tr>
<tr><td align="left">String</td><td>String, Name, Text, Enum</td></tr>
<tr><td align="left">Number</td><td>(All numerics)</td></tr>
<tr><td align="left">Array</td><td>Array, Set</td></tr>
<tr><td align="left">Object</td><td>Class, Struct, Map</td></tr>
</tbody></table>
<p>Here's an example:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;BoolField&quot; : true,
        &quot;NameField&quot; : &quot;AName&quot;,
        &quot;StringField&quot; : &quot;AStr&quot;,
        &quot;TextField&quot; : &quot;AText&quot;,
        &quot;EnumField&quot; : &quot;Tard&quot;,

        &quot;FloatField&quot; : 17.5,
        &quot;DoubleField&quot; : 19.375,

        &quot;Int8Field&quot; : -43,
        &quot;Int16Field&quot; : -2243,
        &quot;Int32Field&quot; : -23415,
        &quot;Int64Field&quot; : -1524523,

        &quot;UInt8Field&quot; : 213,
        &quot;UInt16Field&quot; : 2243,
        &quot;UInt32Field&quot; : 23415,
        &quot;UInt64Field&quot; : 1524523,
    }
)&quot;);

//  deserialized equivelent

FDcTestStruct1 Expect;
Expect.BoolField = true;
Expect.NameField = TEXT(&quot;AName&quot;);
Expect.StringField = TEXT(&quot;AStr&quot;);
Expect.TextField = FText::FromString(TEXT(&quot;AText&quot;));
Expect.EnumField = EDcTestEnum1::Tard;

Expect.FloatField = 17.5f;
Expect.DoubleField = 19.375;

Expect.Int8Field = -43;
Expect.Int16Field = -2243;
Expect.Int32Field = -23415;
Expect.Int64Field = -1524523;

Expect.UInt8Field = 213;
Expect.UInt16Field = 2243,
Expect.UInt32Field = 23415;
Expect.UInt64Field = 1524523;
</code></pre>
<h2><a class="header" href="#enum-flags" id="enum-flags">Enum Flags</a></h2>
<p><code>UENUM</code> that get marked with <code>Bitflags</code> meta are deserialized from a list of strings:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Public/DcTestDeserialize.h
UENUM(meta = (Bitflags))
enum class EDcTestEnumFlag :uint32
{
    None    = 0,
    One     = (1 &lt;&lt; 0),
    Two     = (1 &lt;&lt; 1),
    //...
};
ENUM_CLASS_FLAGS(EDcTestEnumFlag);

// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;EnumFlagField1&quot; : [],
        &quot;EnumFlagField2&quot; : [&quot;One&quot;, &quot;Three&quot;, &quot;Five&quot;],
    }
)&quot;);

//  deserialized equivelent
FDcTestStructEnumFlag1 Expect;
Expect.EnumFlagField1 = EDcTestEnumFlag::None;
Expect.EnumFlagField2 = EDcTestEnumFlag::One | EDcTestEnumFlag::Three | EDcTestEnumFlag::Five;
</code></pre>
<h2><a class="header" href="#sub-objects" id="sub-objects">Sub Objects</a></h2>
<p>By default We treat <code>UOBJECT</code> marked with <code>DefaultToInstanced, EditInlineNew</code> and <code>UPROPERTY</code> marked with <code>Instanced</code> as sub object. In this case we'll actually instantiate new object during deserialization, using <code>Ctx.TopObject()</code> as parent:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Public/DcTestProperty.h
UCLASS(BlueprintType, EditInlineNew, DefaultToInstanced)
class UDcBaseShape : public UObject
{
    //...
    UPROPERTY() FName ShapeName;
};

UCLASS()
class UDcShapeBox : public UDcBaseShape
{
    //...
    UPROPERTY() float Height;
    UPROPERTY() float Width;
};

UCLASS()
class UDcShapeSquare : public UDcBaseShape
{
    //...
    UPROPERTY() float Radius;
};

// DataConfig/Source/DataConfigTests/Public/DcTestDeserialize.h
USTRUCT()
struct FDcTestStructShapeContainer1
{
    GENERATED_BODY()

    UPROPERTY() UDcBaseShape* ShapeField1;
    UPROPERTY() UDcBaseShape* ShapeField2;
    UPROPERTY() UDcBaseShape* ShapeField3;
}USTRUCT()
struct FDcEditorExtraTestObjectRefs1
{
    GENERATED_BODY()

    UPROPERTY() UObject* ObjField1;
    UPROPERTY() UObject* ObjField2;
    UPROPERTY() UObject* ObjField3;
    UPROPERTY() UObject* ObjField4;
};

// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ShapeField1&quot; :  {
            &quot;$type&quot; : &quot;DcShapeBox&quot;,
            &quot;ShapeName&quot; : &quot;Box1&quot;,
            &quot;Height&quot; : 17.5,
            &quot;Width&quot; : 1.9375
        },
        &quot;ShapeField2&quot; : {
            &quot;$type&quot; : &quot;DcShapeSquare&quot;,
            &quot;ShapeName&quot; : &quot;Square1&quot;,
            &quot;Radius&quot; : 1.75,
        },
        &quot;ShapeField3&quot; : null
    }
)&quot;);

//  deserialized equivelent
UDcShapeBox* Shape1 = NewObject&lt;UDcShapeBox&gt;();
Shape1-&gt;ShapeName = TEXT(&quot;Box1&quot;);
Shape1-&gt;Height = 17.5;
Shape1-&gt;Width = 1.9375;
Expect.ShapeField1 = Shape1;

UDcShapeSquare* Shape2 = NewObject&lt;UDcShapeSquare&gt;();
Shape2-&gt;ShapeName = TEXT(&quot;Square1&quot;);
Shape2-&gt;Radius = 1.75;
Expect.ShapeField2 = Shape2;

Expect.ShapeField3 = nullptr;
</code></pre>
<p>Note that the sub object criteria can be easily overridden with a new deserialize predicate or alternative <code>FDcPropertyConfig</code> when constructing the reader.</p>
<h2><a class="header" href="#object-and-class-reference" id="object-and-class-reference">Object and Class Reference</a></h2>
<p>We support multiple ways of referencing a <code>UObject</code> in memory or serialized on disk:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Tests/DcTestDeserializeEditor.h
USTRUCT()
struct FDcEditorExtraTestObjectRefs1
{
    GENERATED_BODY()

    UPROPERTY() UObject* ObjField1;
    UPROPERTY() UObject* ObjField2;
    UPROPERTY() UObject* ObjField3;
    UPROPERTY() UObject* ObjField4;
};

// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Tests/DcTestDeserializeEditor.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ObjField1&quot; : &quot;DcEditorExtraNativeDataAsset'/DataConfig/DcFixture/DcTestNativeDataAssetAlpha.DcTestNativeDataAssetAlpha'&quot;,
        &quot;ObjField2&quot; : &quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;,
        &quot;ObjField3&quot; : 
        {
            &quot;$type&quot; : &quot;DcEditorExtraNativeDataAsset&quot;,
            &quot;$path&quot; : &quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;
        },
        &quot;ObjField4&quot; : null,
    }
)&quot;);

//  deserialized equivelent
UDcEditorExtraNativeDataAsset* DataAsset = Cast&lt;UDcEditorExtraNativeDataAsset&gt;(StaticLoadObject(
    UDcEditorExtraNativeDataAsset::StaticClass(),
    nullptr,
    TEXT(&quot;/DataConfig/DcFixture/DcTestNativeDataAssetAlpha&quot;),
    nullptr
));

Expect.ObjField1 = DataAsset;
Expect.ObjField2 = DataAsset;
Expect.ObjField3 = DataAsset;
Expect.ObjField4 = nullptr;
</code></pre>
<p>In the example above, <code>ObjField1</code> is using the reference string that can be retrieved in editor context menu:</p>
<p><img src="Deserialize/Images/Deserialize-CopyReference.png" alt="Deserialize-CopyReference" /></p>
<p>For <code>ObjField2/ObjField3</code> it's using a relative path to the <code>uasset</code> but without file name suffix.</p>
<p>We also support class reference fields of <code>TSubclassOf&lt;&gt;</code>s:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.h
USTRUCT()
struct FDcTestStructSubClass1
{
    GENERATED_BODY()

    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField1;
    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField2;
    UPROPERTY() TSubclassOf&lt;UStruct&gt; StructSubClassField3;
};

// DataConfig/Source/DataConfigTests/Private/DcTestDeserialize.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StructSubClassField1&quot; : null,
        &quot;StructSubClassField2&quot; : &quot;ScriptStruct&quot;,
        &quot;StructSubClassField3&quot; : &quot;DynamicClass&quot;,
    }
)&quot;);

//  deserialized equivelent
FDcTestStructSubClass1 Expect;
Expect.StructSubClassField1 = nullptr;
Expect.StructSubClassField2 = UScriptStruct::StaticClass();
Expect.StructSubClassField3 = UDynamicClass::StaticClass();
</code></pre>
<p>Note that these do not support Blueprint classes. The direct reason is that Blueprint depends on <code>Engine</code> module and we'd like not to take dependency on in <code>DataConfigCore</code>. </p>
<p>We do have an example that supports Blueprint classes, see <code>DataConfigEditorExtra -  DcDeserializeBPClass.h/cpp</code></p>
<h2><a class="header" href="#caveats" id="caveats">Caveats</a></h2>
<p>Here're some closing notes:</p>
<ul>
<li>
<p>For meta fields like <code>$type</code> we require it to be the first member, meaning object fields are order dependent. This means that the JSON we're supporting is a super set of standard JSON spec (again).</p>
</li>
<li>
<p>There're many data types that can not be deserialized from JSON, for example <code>Delegate/WeakObjectReference</code>. Remember that you always have the option to override or selectively enable the handlers to support additional property that makes sense in your context. See <code>DcSetupJsonDeserializeHandlers()</code> body how handlers are registered. You can skip this method and select the ones you want and provide additional handlers.</p>
</li>
<li>
<p>The JSON handlers are designed to <em>NOT</em> read anything during the deserialization. This is crucial since <code>USTRUCT</code> can contain uninitialized fields. For example:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
FString Str = TEXT(R&quot;(
    {
        // pass
    } 
)&quot;);
FDcJsonReader Reader(Str);

FDcTestExampleSimple Dest;
FDcPropertyDatum DestDatum(FDcTestExampleSimple::StaticStruct(), &amp;Dest);

DC_TRY(DcAutomationUtils::DeserializeJsonInto(&amp;Reader, DestDatum));

check(Dest.StrField.IsEmpty());
//  but Dest.IntField contains uninitialized value
DcAutomationUtils::DumpToLog(DestDatum);

// dump results
&lt;StructRoot&gt; 'DcTestExampleSimple'
|---&lt;Name&gt; 'StrField'
|---&lt;String&gt; ''
|---&lt;Name&gt; 'IntField'
|---&lt;Int32&gt; '1689777552' // &lt;- arbitrary value
&lt;StructEnd&gt; 'DcTestExampleSimple'
</code></pre>
<p>This would cause trouble when you try read a pointer field during deserialization. Remember that primitive fields might be uninitialized during deserialization when implementing your own handlers.</p>
</li>
<li>
<p>One interesting trait of the pull/push styled API is that <code>FDcJsonReader</code> does <strong>not</strong> preemptively parse number into double and convert it to <code>int/float</code> later on. When reading a number token it would do the number parsing at call site. If <code>ReadIntX()</code> is called then the number is parsed as integer. If <code>ReadFloat()/ReadDouble()</code> is called the token will be parsed as floating point.</p>
</li>
</ul>
<h1><a class="header" href="#pipe-deserialize" id="pipe-deserialize">Pipe Deserialize</a></h1>
<p>There's a set of deserialize handlers in <code>DcPropertyPipeHandlers</code> namespace. It's used to roundtripping property system objects.</p>
<p>Simply speaking it's equivalent to doing a <code>FDcPipeVisitor</code>  pipe visit.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigTests/Private/DcTestBlurb.cpp
//  these two blocks are equivalent
{
    FDcPropertyReader Reader(FromDatum);
    FDcPropertyWriter Writer(ToDatum);
    FDcPipeVisitor RoundtripVisit(&amp;Reader, &amp;Writer);

    DC_TRY(RoundtripVisit.PipeVisit());
}

{
    FDcDeserializer Deserializer;
    DcSetupPropertyPipeDeserializeHandlers(Deserializer);

    FDcPropertyReader Reader(FromDatum);
    FDcPropertyWriter Writer(ToDatum);

    FDcDeserializeContext Ctx;
    Ctx.Reader = &amp;Reader;
    Ctx.Writer = &amp;Writer;
    Ctx.Deserializer = &amp;Deserializer;
    Ctx.Properties.Push(FromDatum.Property);
    DC_TRY(Ctx.Prepare());

    DC_TRY(Deserializer.Deserialize(Ctx));
}
</code></pre>
<p>These are provided as a set of basis to for building custom property wrangling utils. See <code>DataConfigExtra - DcDeserializeRenameStructFieldNames.h/cpp</code> for example.</p>
<h1><a class="header" href="#extra" id="extra">Extra</a></h1>
<p>Alongside <code>DataConfigCore</code> we have two other modules <code>DataConfigExtra</code> and <code>DataConfigEditorExtra</code>. It have self contained samples built on top of DataConfig framework.</p>
<p>Note that these are not intended to be integrated directly. You can take these as references when implementing custom features.</p>
<h1><a class="header" href="#dataconfigextra" id="dataconfigextra">DataConfigExtra</a></h1>
<p>Module <code>DataConfigExtra</code> contains examples that doesn't dependent on <code>Engine/UnrealEd</code>.</p>
<h2><a class="header" href="#deserialize-json-into-struct" id="deserialize-json-into-struct">Deserialize JSON into Struct</a></h2>
<p>There's a built-in method in <code>JsonUtilities</code> module that simply deserialize a JSON string into a struct. In this example we implemented a similar method with almost identical API:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcJsonConverter.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;StrField&quot; : &quot;Foo&quot;,
        &quot;IntField&quot; : 253,
        &quot;BoolField&quot; : true
    }
)&quot;);

FDcTestJsonConverter1 Lhs;
bool LhsOk = DcExtra::JsonObjectStringToUStruct(Str, &amp;Lhs);

FDcTestJsonConverter1 Rhs;
bool RhsOk = FJsonObjectConverter::JsonObjectStringToUStruct(Str, &amp;Rhs, 0, 0);
</code></pre>
<p>Comparing to the stock method <code>DcExtra::JsonObjectStringToUStruct</code> allows relaxed JSON with comments and trailing comma. It would also provide better diagnostics on parse error.</p>
<h2><a class="header" href="#deserialize-fcolor" id="deserialize-fcolor">Deserialize <code>FColor</code></a></h2>
<p>This has been shown multiple times in previous chapters. It's also a benchmark use case for our custom deserialization logic:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeColor.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
        &quot;ColorField2&quot; : &quot;#FF0000FF&quot;,
    }
)&quot;);

// deserialized equivelent
FDcExtraTestStructWithColor1 Expect;

Expect.ColorField1 = FColor::Blue;
Expect.ColorField2 = FColor::Red;
</code></pre>
<h2><a class="header" href="#deserialize-base64-string-as-blob" id="deserialize-base64-string-as-blob">Deserialize Base64 string as Blob</a></h2>
<p>In this example we deserialize <code>TArray&lt;uint8&gt;</code> from Base64 strings in JSON:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeBase64.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;BlobField1&quot; : &quot;dGhlc2UgYXJlIG15IHR3aXN0ZWQgd29yZHM=&quot;,
        &quot;BlobField2&quot; : &quot;&quot;,
    }
)&quot;);

// deserialized equivelent
FDcExtraTestStructWithBase64 Expect;

const char* Literal = &quot;these are my twisted words&quot;;
Expect.BlobField1 = TArray&lt;uint8&gt;((uint8*)Literal, FCStringAnsi::Strlen(Literal));
Expect.BlobField2 = TArray&lt;uint8&gt;();
</code></pre>
<p>In the predicate we are checking for <code>Array</code>s with custom meta data <code>DcExtraBlob</code>:</p>
<pre><code class="language-c++">// DataConfig\Source\DataConfigExtra\Public\DataConfig\Extra\Deserialize\DcDeserializeBase64.h
USTRUCT()
struct FDcExtraTestStructWithBase64
{
    GENERATED_BODY()

    UPROPERTY(meta = (DcExtraBase64)) TArray&lt;uint8&gt; BlobField1;
    UPROPERTY(meta = (DcExtraBase64)) TArray&lt;uint8&gt; BlobField2;
};
</code></pre>
<p>UE support arbitrary meta data in the <code>meta = ()</code> segment. But beware that the meta data is only available when <code>WITH_EDITORDATA</code> flag is defined.</p>
<h2><a class="header" href="#deserialize-fdcanystruct" id="deserialize-fdcanystruct">Deserialize <code>FDcAnyStruct</code></a></h2>
<p>we've implemented <code>FDcAnyStruct</code> that can be used to store a heap allocated <code>USTRUCT</code> of any type while keep proper value sematic on itself:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeAnyStruct.cpp
//  instantiate from heap allocated structs
FDcAnyStruct Any1 = new FDcExtraTestSimpleStruct1();
Any1.GetChecked&lt;FDcExtraTestSimpleStruct1&gt;()-&gt;NameField = TEXT(&quot;Foo&quot;);

//  supports moving
FDcAnyStruct Any2 = MoveTemp(Any1);
check(!Any1.IsValid());
check(Any2.GetChecked&lt;FDcExtraTestSimpleStruct1&gt;()-&gt;NameField == TEXT(&quot;Foo&quot;));
Any2.Reset();

//  supports shared referencing
Any2 = new FDcExtraTestSimpleStruct2();
Any2.GetChecked&lt;FDcExtraTestSimpleStruct2&gt;()-&gt;StrField = TEXT(&quot;Bar&quot;);

Any1 = Any2;

check(Any1.DataPtr == Any2.DataPtr);
check(Any1.StructClass == Any2.StructClass);
</code></pre>
<p>In this example we implemented predicate and handler to support deserializing <code>FDcAnyStruct</code> from a JSON object with a <code>$type</code> field, or a <code>null</code>.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeAnyStruct.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;AnyStructField1&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestSimpleStruct1&quot;,
            &quot;NameField&quot; : &quot;Foo&quot;
        },
        &quot;AnyStructField2&quot; : {
            &quot;$type&quot; : &quot;DcExtraTestStructWithColor1&quot;,
            &quot;ColorField1&quot; : &quot;#0000FFFF&quot;,
            &quot;ColorField2&quot; : &quot;#FF0000FF&quot;
        },
        &quot;AnyStructField3&quot; : null
    }
)&quot;);

//...

UTEST_TRUE(&quot;...&quot;, Dest.AnyStructField1.GetChecked&lt;FDcExtraTestSimpleStruct1&gt;()-&gt;NameField == TEXT(&quot;Foo&quot;));
UTEST_TRUE(&quot;...&quot;, Dest.AnyStructField2.GetChecked&lt;FDcExtraTestStructWithColor1&gt;()-&gt;ColorField1 == FColor::Blue);
UTEST_TRUE(&quot;...&quot;, Dest.AnyStructField2.GetChecked&lt;FDcExtraTestStructWithColor1&gt;()-&gt;ColorField2 == FColor::Red);
UTEST_TRUE(&quot;...&quot;, !Dest.AnyStructField3.IsValid());
</code></pre>
<p>Note how custom <code>FColor</code> deserializing works inside a <code>FDcAnyStruct</code>.</p>
<h2><a class="header" href="#copying-struct-while-renaming-field-names" id="copying-struct-while-renaming-field-names">Copying struct while renaming field names</a></h2>
<p>This is an example of using <code>FDcDeserializer</code> with non <code>FDcJsonReader</code>. It uses <code>FDcPropertyReader</code> with the <code>DcPropertyPipeHandlers</code> to do renaming:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Deserialize/DcDeserializeRenameStructFieldNames.cpp
//  struct equivelent to this:
FString Str = TEXT(R&quot;(
    {
        &quot;FromName1&quot; : &quot;Foo&quot;,
        &quot;FromStructSet1&quot; : 
        [
            {
                &quot;FromStr1&quot; : &quot;One&quot;,
                &quot;FromInt1&quot; : 1,
            },
            {
                &quot;FromStr1&quot; : &quot;Two&quot;,
                &quot;FromInt1&quot; : 2,
            }
        ]
    }
)&quot;);

// ... deserialize with a functor renaming `FromXXX` to `ToXXX`:
UTEST_OK(&quot;...&quot;, DcExtra::DeserializeStructRenaming(FromDatum, ToDatum, FDcExtraRenamer::CreateLambda([](const FName&amp; FromName){
    FString FromStr = FromName.ToString();
    if (FromStr.StartsWith(TEXT(&quot;From&quot;)))
        return FName(TEXT(&quot;To&quot;) + FromStr.Mid(4));
    else
        return FromName;
})));

// ... results into a struct equivelent to this: 
FString Str = TEXT(R&quot;(
    {
        &quot;ToName1&quot; : &quot;Foo&quot;,
        &quot;ToStructSet1&quot; : 
        [
            {
                &quot;ToStr1&quot; : &quot;One&quot;,
                &quot;ToInt1&quot; : 1,
            },
            {
                &quot;ToStr1&quot; : &quot;Two&quot;,
                &quot;ToInt1&quot; : 2,
            }
        ]
    }
)&quot;);
</code></pre>
<h2><a class="header" href="#access-property-by-path" id="access-property-by-path">Access property by path</a></h2>
<p>UE built-in module <code>PropertyPath</code> allow accessing nested object properties by a path like <code>Foo.Bar.Baz</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcPropertyPathAccess.cpp
FString Str;
UTEST_TRUE(&quot;...&quot;, PropertyPathHelpers::GetPropertyValue(Outer, TEXT(&quot;StructRoot.Middle.InnerMost.StrField&quot;), Str));
UTEST_TRUE(&quot;...&quot;, Str == TEXT(&quot;Foo&quot;));

UTEST_TRUE(&quot;...&quot;, PropertyPathHelpers::SetPropertyValue(Outer, TEXT(&quot;StructRoot.Middle.InnerMost.StrField&quot;), FString(TEXT(&quot;Bar&quot;))));
UTEST_TRUE(&quot;...&quot;, Outer-&gt;StructRoot.Middle.InnerMost.StrField == TEXT(&quot;Bar&quot;));
</code></pre>
<p>We implemented a pair of methods <code>GetDatumPropertyByPath/SetDatumPropertyByPath</code> with <code>FDcPropertyReader</code>:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigExtra/Private/DataConfig/Extra/Types/DcPropertyPathAccess.cpp
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Middle.InnerMost.StrField&quot;), TEXT(&quot;Foo&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.0.StrField&quot;), TEXT(&quot;Bar0&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.1.StrField&quot;), TEXT(&quot;Bar1&quot;)));
UTEST_TRUE(&quot;...&quot;, CheckStrPtr(GetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.NameMap.FooKey.StrField&quot;), TEXT(&quot;FooValue&quot;)));

UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Middle.InnerMost.StrField&quot;, TEXT(&quot;AltFoo&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.0.StrField&quot;, TEXT(&quot;AltBar0&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.Arr.1.StrField&quot;, TEXT(&quot;AltBar1&quot;)));
UTEST_TRUE(&quot;...&quot;, SetDatumPropertyByPath&lt;FString&gt;(FDcPropertyDatum(Outer), &quot;StructRoot.NameMap.FooKey.StrField&quot;, TEXT(&quot;AltFooValue&quot;)));
</code></pre>
<p>Comparing to <code>PropertyPathHelpers</code> these new ones support <code>Array</code> and <code>Map</code>, and support <code>USTRUCT</code> roots. We're also missing some features like expanding weak/lazy object references but it should be easy to implement.</p>
<h1><a class="header" href="#dataconfigeditorextra" id="dataconfigeditorextra">DataConfigEditorExtra</a></h1>
<p>Module <code>DataConfigEditorExtra</code> contains examples that need to be run in a editor context.</p>
<h2><a class="header" href="#dceditorextramodule" id="dceditorextramodule"><code>DcEditorExtraModule</code></a></h2>
<p>This is a good reference of integrating <code>DataConfigCore</code> in a editor module. Here's a checklist:</p>
<ul>
<li>Register additional diagnostics early. </li>
<li>Call <code>DcStartUp()/DcShutDonw()</code> pair.</li>
<li>Register custom diagnostic consumer.</li>
</ul>
<p><code>FDcMessageLogDiagnosticConsumer</code> is an example of redirecting diagnostics into UE Message Log window with its own category.</p>
<h2><a class="header" href="#deserialize-blueprint-class-instances" id="deserialize-blueprint-class-instances">Deserialize Blueprint Class Instances</a></h2>
<p>The Property System is so powerful that you can create new Blueprint Class, which is equivalent to C++ <code>UCLASS</code> to some extents, within the Blueprint Editor. In this example we implemented deserializing these.</p>
<p>Blueprint Class can be referenced by the blueprint asset path:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeBPClass.cpp
FString Str = TEXT(R&quot;(
    {
        //...
        &quot;ClassField3&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintClassBeta&quot;,
    }
)&quot;);

UTEST_TRUE(&quot;...&quot;, Dest.ClassField3-&gt;GetFName() == TEXT(&quot;DcTestBlueprintClassBeta_C&quot;));
</code></pre>
<p>And Blueprint structs can also be deserialized from JSON. We need to rewrite the handler <code>HandlerBPDcAnyStructDeserialize</code> for looking up Blueprint Struct by path:</p>
<pre><code class="language-C++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeBPClass.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;AnyStructField1&quot; : {
            &quot;$type&quot; : &quot;/DataConfig/DcFixture/DcTestBlueprintStructWithColor&quot;,
            &quot;NameField&quot; : &quot;Foo&quot;,
            &quot;StrField&quot; : &quot;Bar&quot;,
            &quot;IntField&quot; : 123,
            &quot;ColorField&quot; : &quot;#FF0000FF&quot;
        }
    }
)&quot;);
</code></pre>
<p>There's a quirk that Blueprint Struct actually mangle its field names. The struct above dumps to something like this:</p>
<pre><code>-----------------------------------------
# Datum: 'UserDefinedStruct', 'DcTestBlueprintStructWithColor'
&lt;StructRoot&gt; 'DcTestBlueprintStructWithColor'
|---&lt;Name&gt; 'NameField_5_97BFF114405C1934C2F33E8668BF1652'
|---&lt;Name&gt; 'Foo'
|---&lt;Name&gt; 'StrField_9_FAA71EFE4896F4E6B1478B9C13B2CE52'
|---&lt;String&gt; 'Bar'
|---&lt;Name&gt; 'IntField_11_3BC7CB0F42439CE2196F7AA82A1AC374'
|---&lt;Int32&gt; '123'
|---&lt;Name&gt; 'ColorField_14_F676BCF245B2977B678B65A8216E94EB'
|---&lt;StructRoot&gt; 'Color'
|   |---&lt;Name&gt; 'B'
|   |---&lt;UInt8&gt; '0'
|   |---&lt;Name&gt; 'G'
|   |---&lt;UInt8&gt; '0'
|   |---&lt;Name&gt; 'R'
|   |---&lt;UInt8&gt; '255'
|   |---&lt;Name&gt; 'A'
|   |---&lt;UInt8&gt; '255'
|---&lt;StructEnd&gt; 'Color'
&lt;StructEnd&gt; 'DcTestBlueprintStructWithColor'
-----------------------------------------
</code></pre>
<p>The good news is that DataConfig already got this covered. </p>
<h2><a class="header" href="#deserialize-gameplaytags" id="deserialize-gameplaytags">Deserialize GameplayTags</a></h2>
<p><a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Tags/index.html" title="Gameplay Tags">GameplayTags</a> is a built-in runtime module that implements hierarchical tags. In this example we implemented deserializing into <code>FGameplayTag</code> from a string.</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;TagField1&quot; : null,
        &quot;TagField2&quot; : &quot;DataConfig.Foo.Bar&quot;
    }
)&quot;);

UTEST_FALSE(&quot;...&quot;, Dest.TagField1.IsValid());
UTEST_TRUE(&quot;...&quot;, Dest.TagField2.IsValid());
UTEST_TRUE(&quot;...&quot;, Dest.TagField2 == UGameplayTagsManager::Get().RequestGameplayTag(TEXT(&quot;DataConfig.Foo.Bar&quot;)));
</code></pre>
<p>We also implemented deserializing <code>FGameplayTagContainer</code> from a list of strings:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.cpp
FString Str = TEXT(R&quot;(
    {
        &quot;TagContainerField1&quot; : [],
        &quot;TagContainerField2&quot; : [
            &quot;DataConfig.Foo.Bar&quot;,
            &quot;DataConfig.Foo.Bar.Baz&quot;,
            &quot;DataConfig.Tar.Taz&quot;,
        ]
    }
)&quot;);

UTEST_TRUE(&quot;...&quot;, Dest.TagContainerField1.Num() == 0);
UTEST_TRUE(&quot;...&quot;, Dest.TagContainerField2.Num() == 3);
UTEST_TRUE(&quot;...&quot;, Dest.TagContainerField2.HasTagExact(
    UGameplayTagsManager::Get().RequestGameplayTag(TEXT(&quot;DataConfig.Foo.Bar&quot;))
));
UTEST_TRUE(&quot;...&quot;, Dest.TagContainerField2.HasTagExact(
    UGameplayTagsManager::Get().RequestGameplayTag(TEXT(&quot;DataConfig.Foo.Bar.Baz&quot;))
));
UTEST_TRUE(&quot;...&quot;, Dest.TagContainerField2.HasTagExact(
    UGameplayTagsManager::Get().RequestGameplayTag(TEXT(&quot;DataConfig.Tar.Taz&quot;))
));

</code></pre>
<p>Note that gameplay tag parsing has error reporting built-in. In this case we can pipe it into our diagnostic:</p>
<pre><code class="language-c++">// DataConfig/Source/DataConfigEditorExtra/Private/DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayTags.cpp
static FDcResult _StringToGameplayTag(FDcDeserializeContext&amp; Ctx, const FString&amp; Str, FGameplayTag* OutTagPtr)
{
    FString FixedString;
    FText Err;
    if (!FGameplayTag::IsValidGameplayTagString(Str, &amp;Err, &amp;FixedString))
    {
        return DC_FAIL(DcDEditorExtra, InvalidGameplayTagStringFixErr)
            &lt;&lt; Str &lt;&lt; FixedString &lt;&lt; Err;
    }
    //...
}
</code></pre>
<p>In case of a invalid tag it would report the reason and fixed string:</p>
<pre><code># DataConfig Error: Invalid Gameplay Tag String, Actual: 'DataConfig.Invalid.Tag.', Fixed: 'DataConfig.Invalid.Tag', Error: 'Tag ends with .'
- [JsonReader] --&gt; &lt;in-memory&gt;5:4
   3 |        { 
   4 |            &quot;TagField1&quot; : null, 
   5 |            &quot;TagField2&quot; : &quot;DataConfig.Invalid.Tag.&quot; 
     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^
   6 |        } 
   7 |    
- [PropertyWriter] Writing property: (FDcEditorExtraTestStructWithGameplayTag1)$root.(FGameplayTag)TagField2
 [C:\DevUE\UnrealEngine\Engine\Source\Developer\MessageLog\Private\Model\MessageLogListingModel.cpp(73)]
</code></pre>
<h2><a class="header" href="#deserialize-gameplay-abilities" id="deserialize-gameplay-abilities">Deserialize Gameplay Abilities</a></h2>
<p>We'll conclude examples with a concrete user story: populating <code>GameplayAbility</code> and <code>GameplayEffect</code> blueprint from JSON file.</p>
<p><a href="https://docs.unrealengine.com/en-US/InteractiveExperiences/GameplayAbilitySystem/index.html" title="Gameplay Ability System">Gameplay Ability System</a> is a built-in plugin for building data driven abilities. Users are expected to derived and modify <code>GameplayAbility</code> and <code>GameplayEffect</code> blueprint for custom logic. </p>
<p>Given a JSON like this:</p>
<pre><code class="language-c++">// DataConfig/Tests/Fixture_AbilityAlpha.json
{
    /// Tags
    &quot;AbilityTags&quot; : [
        &quot;DataConfig.Foo.Bar&quot;,
        &quot;DataConfig.Foo.Bar.Baz&quot;,
    ],
    &quot;CancelAbilitiesWithTag&quot; : [
        &quot;DataConfig.Foo.Bar.Baz&quot;,
        &quot;DataConfig.Tar.Taz&quot;,
    ],
    /// Costs
    &quot;CostGameplayEffectClass&quot; : &quot;/DataConfig/DcFixture/DcTestGameplayEffectAlpha&quot;,
    /// Advanced
    &quot;ReplicationPolicy&quot; : &quot;ReplicateYes&quot;,
    &quot;InstancingPolicy&quot; : &quot;NonInstanced&quot;,
}
</code></pre>
<p>Right click on a <code>GameplayAbility</code> blueprint asset and select <code>Load From JSON</code>， then select this file and confirm. It would correctly populate the fields with the values in JSON, as seen in the pic below:</p>
<p><img src="Extra/Images/DataConfigEditorExtra-LoadJsonIntoAbility.png" alt="DataConfigEditorExtra-LoadJsonIntoAbility" /></p>
<p>Most of the logic is in <code>DataConfig/EditorExtra/Deserialize/DcDeserializeGameplayAbility.cpp</code>:</p>
<ul>
<li>The context menu is added from <code>GameplayAbilityEffectExtender</code>. There's another handy item named <code>Dump To Log</code> which dumps any blueprint CDO into the log.</li>
<li>DataConfig deserializer is setup in <code>LazyInitializeDeserializer()</code>. We added custom logic for deserializing <code>FGameplayAttribute</code> from a string like <code>DcTestAttributeSet.Mana</code>.</li>
<li>We also reused many methods from previous examples to support <code>FGameplayTag</code> deserialization and Blueprint class look up by path.</li>
</ul>
<h1><a class="header" href="#license-1" id="license-1">License</a></h1>
<p>DataConfig is released under <a href="https://choosealicense.com/licenses/mit/" title="MIT License">MIT License</a>.</p>
<pre><code>MIT License

Copyright (c) 2021 Chen Tao 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<h2><a class="header" href="#attribution" id="attribution">Attribution</a></h2>
<p>If you find DataConfig useful in your project, consider credit us in your project with the full license above or the shorter snippets below. </p>
<pre><code>DataConfig &lt;https//slowburn.dev/dataconfig&gt;
MIT License, Copyright (c) 2021 Chen Tao
</code></pre>
<p>You can also reach us by email to <a href="mailto:hislowburn@gmail.com">hislowburn@gmail.com</a> or on twitter <a href="https://twitter.com/slowburndev">@slowburndev</a>. </p>
<p>We'll setup a section showcasing projects using DataConfig in the future.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
